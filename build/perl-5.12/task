#!/usr/bin/env perl

our $VERSION = "4.00";

# DO NOT EDIT -- this is an auto generated file

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Task/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_BASE';
  package App::Task::Base;use Moo;use IO::CaptureOutput qw(capture_exec capture_exec_combined);use IO::Interactive qw(is_interactive);use Getopt::Long;use Term::ANSIColor;use App::Task::ContentTracker;use App::Task::Config;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through require_order));our$VERSION='4.00';my$instance;sub instance {return$instance if$instance;die __PACKAGE__ .' instance has not been built yet'}sub BUILD {my ($self,$args)=@_;$instance=$self;if (my$message=App::Task::Config->configure($args->{config_file})){if (grep {/--help|-h/}@ARGV){$self->run}else {usage($message)}}GetOptions('help|h'=>sub {usage()},'verbose|v+'=>\($App::Task::Config::options{verbose}),)or usage()}sub run {my ($self)=@_;my$content_tracker=App::Task::ContentTracker->new;my$command_name=shift@ARGV;usage()if!$command_name;my$command=App::Task::Config->find_command($command_name);if (!$command){usage("Invalid command: $command_name")}my$command_instance=$command->{module}->new(content_tracker=>$content_tracker,);$command_instance->run}sub prompt {my ($self,%options)=@_;$self=instance()if!ref$self;print 'Enter ' .join(', ',map {"'$_' to $options{$_}"}grep {!/default/}keys%options).', anything else to exit: ';chomp(my$response=<STDIN>);if (defined$options{lc$response}){return$options{lc$response}}elsif (defined$options{default}){return$options{default}}else {print "Exiting...\n";exit}}sub system_call {my ($self,$command,%options)=@_;$self=ref$self ? $self : instance();$command=[$command ]if!ref$command;my$command_text=join(' ',@$command);if (App::Task::Config->get_option('verbose')&& App::Task::Config->get_option('verbose')>= 1 || $options{verbose}){printf("\r%s\r",' ' x 80)if is_interactive();print "* $command_text\n"}my ($stdout,$stderr);if ($options{combine}){($stdout)=capture_exec_combined(@$command)}else {($stdout,$stderr)=capture_exec(@$command)}my$exit_status=$? & 127 ? $? & 127 : $? >> 8;my$output='';if ($stdout){chomp(my$stdout_copy=$stdout);$stdout_copy =~ s/(?!\A)^/** /gims;$output .= "** stdout: '$stdout_copy'\n"}if ($stderr){chomp(my$stderr_copy=$stderr);$stderr_copy =~ s/(?!\A)^/** /gims;$output .= "** stderr: '$stderr_copy'\n"}if (!defined$options{ignore_exit_status}and $exit_status){$self->highlighted_die("Command failed: $command_text\n$output\n")}if (App::Task::Config->get_option('verbose')&& App::Task::Config->get_option('verbose')>= 2){print$output}return ($stdout,$stderr,$exit_status)}sub highlighted_die {my ($self,$message)=@_;$message =~ s/(\n?)\z/color('reset') . $1/e;die color('red').$message}sub environments {my ($class)=@_;return App::Task::Config->config->{environments}}sub usage {my ($message)=@_;print <<"END_USAGE";for my$command_name (App::Task::Config->command_list){printf "    %-12s %s\n",$command_name,App::Task::Config->find_command($command_name)->{description}}print "\nUse 'task <subcommand> --help' for more information\n";print "\n$message\n" if$message;exit 1}no Moo;1;
  Usage: task <subcommand>
  
  task is a release management tool for git designed to aid multi-user
  development in tiny chunks (task branches). It supports
  multiple environments and can build de facto releases (defined by whatever is
  on a given branch) or versioned releases
  
  Available subcommands are:
  END_USAGE
APP_TASK_BASE

$fatpacked{"App/Task/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND';
  package App::Task::Command;use Moo::Role;use Types::Standard qw(ArrayRef HashRef InstanceOf);use Cwd qw(getcwd);use Getopt::Long;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through permute));has 'environment'=>(is=>'ro',isa=>HashRef,reader=>'get_environment');has 'content_tracker'=>(is=>'ro',required=>1,isa=>InstanceOf['App::Task::ContentTracker'],reader=>'content_tracker');has 'task_branch'=>(is=>'rw');has 'original_dir'=>(is=>'ro',default=>sub {getcwd()},reader=>'get_original_dir');has 'allow_branch_switch'=>(is=>'rw',default=>sub {0});has 'deployment_branch'=>(is=>'rw',reader=>'get_deployment_branch',writer=>'set_deployment_branch');requires 'run';requires 'usage';around 'run'=>sub {my ($next,$self,%options)=@_;my$original_branch=$self->content_tracker->get_current_branch;if (!$original_branch){$self->usage("No branches yet! Create one to get started")}$self->content_tracker->update_remotes;my@returned_values;eval {@returned_values=$next->($self)};my$error;if ($@){$error=$@}$self->return_to_original_dir;my$current_branch=$self->content_tracker->get_current_branch;if ($current_branch ne $original_branch and!$self->allow_branch_switch){App::Task::Base->system_call("git checkout '$original_branch'")}die$error if$error;return (@returned_values)};sub return_to_original_dir {my ($self)=@_;my$current_dir=getcwd;my$original_dir=$self->get_original_dir;if ($original_dir ne $current_dir){chdir$self->get_original_dir or die "Couldn't change back to $original_dir from $current_dir"}}sub set_environment {my ($self,$env)=@_;if ($env){$self->{environment}=App::Task::Base->environments->{$env}or die "Invalid destination environment: $env"}else {my$destination_env=shift@ARGV;$self->usage("error: No environment specified")if!defined$destination_env;$self->{environment}=App::Task::Base->environments->{$destination_env};if (!defined$self->{environment}){$self->usage("error: '$destination_env' is not a valid environment\nvalid environments are: " .join(', ',sort keys %{App::Task::Base->environments}))}}}sub env {my ($self)=@_;return$self->{environment}}sub add_task {my ($self,$branch_name)=@_;if (my ($valid_branch)=sort$self->content_tracker->get_branches_by_prefix($branch_name)){$self->task_branch($valid_branch);return 1}return 0}sub resolve_file {my ($self,$path)=@_;my$relative_to_root=`git rev-parse --show-cdup`;chomp$relative_to_root;if (-e $path){if ($relative_to_root){return abs2rel(abs_path(rel2abs$path),$self->content_tracker->get_repository_root)}else {return$path}}return$path if -e "$relative_to_root$path";die "Couldn't find file: $path"}sub parse_options {my ($self,%options)=@_;$options{'verbose|v+'}=\($App::Task::Config::options{verbose});GetOptions(%options)or $self->usage};no Moo::Role;no Types::Standard;1;
APP_TASK_COMMAND

$fatpacked{"App/Task/Command/Cleanup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_CLEANUP';
  package App::Task::Command::Cleanup;use Moo;use App::Task::Config;with 'App::Task::Command';App::Task::Config->register_command(cleanup=>'Cleanup branches that have been deployed or abandoned');sub BUILD {my ($self,$args)=@_;my$deployed_to_env='prod';my$days=7;$self->parse_options('help|h'=>sub {$self->usage},'delete|d'=>sub {App::Task::Config->set_option('delete-task-branches'=>1)},'days=i'=>\$days,'deployed-to=s'=>\$deployed_to_env,);die "Invalid env '$deployed_to_env'" if!defined App::Task::Base->environments->{$deployed_to_env};App::Task::Config->set_option('deployed-to'=>$deployed_to_env);App::Task::Config->set_option('days-since-last-commit'=>$days);for my$arg (@ARGV){if (!$self->add_task($arg)){print "Unknown option: $arg\n"}}}sub run {my ($self)=@_;$self->content_tracker->update_remotes;my ($local_branches)=App::Task::Base->system_call("git branch");my ($current_branch)=$local_branches =~ /^\* ([^\n]+)/ims;LOCAL_BRANCH: for my$raw_branch (split /\n/,$local_branches){my ($branch_name)=$raw_branch =~ /^\*?[ \t]*\b(.*)/ims;next LOCAL_BRANCH if!$branch_name;next LOCAL_BRANCH if$self->task_branch !~ /^\Q$branch_name/;my ($deployed_envs)=$self->content_tracker->get_deployed_envs($branch_name);my$target_env=App::Task::Config->get_option('deployed-to');if (defined$deployed_envs->{integration}and defined$deployed_envs->{$target_env}){chomp(my ($last_commit_timestamp)=App::Task::Base->system_call("git log -1 --pretty=format:'%ct' '$target_env/$branch_name'",ignore_exit_status=>1));if (!$last_commit_timestamp){chomp(my ($sha1)=App::Task::Base->system_call("git rev-parse $branch_name"));chomp(($last_commit_timestamp)=App::Task::Base->system_call("git log -1 --pretty=format:'%ct' '$sha1'"))}my$actual_days_since_last_commit=int((time()- $last_commit_timestamp)/ 86400);if ($actual_days_since_last_commit >= App::Task::Config->get_option('days-since-last-commit')){print "Branch '$branch_name' has existed on $target_env for $actual_days_since_last_commit days and can be deleted\n";if (App::Task::Config->get_option('delete-task-branches')){system("git branch -D '$branch_name'")}}}}}sub usage {my ($self,$message)=@_;print <<"END_USAGE";print "\n$message\n" if$message;exit 1}1;
  Usage: task cleanup [-hd] <branch_name>
  
  Show (and delete) task branches that have been deployed to production or another environment
  
  Options:
  
      -h, --help                   Show a brief help message and exit
      -n, --noconfirm  Don't show a confirmation message before doing the deploy
      -d, --delete                 Delete the branches that exist on the target
                                   environment
      --deployed-to=<environment>  Sets the target environment for which task
                                   branches must have been deployed to.
                                   Defaults to what your mainline branch is set to
      --days=<number>              Make sure the task branches have existed on the
                                   target environment for at least this many days
  
  Examples:
  
      task cleanup
  
  Show local branches whose tips have existed on prod for at least 7 days
  
      task cleanup -d
  
  Delete local branches whose tips have existed on prod for at least 7 days
  END_USAGE
APP_TASK_COMMAND_CLEANUP

$fatpacked{"App/Task/Command/Deploy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_DEPLOY';
  package App::Task::Command::Deploy;use Moo;use Cwd qw(getcwd);use Term::ANSIColor;use App::Task::Config;use App::Task::Hooks;with 'App::Task::Command';App::Task::Config->register_command(deploy=>'Deploy a task branch to a given environment (and all its dependent envs too)');sub highlighted_die {my ($message)=@_;$message =~ s/(\n?)\z/color('reset') . $1/e;die color('red').$message}sub BUILD {my ($self,$args)=@_;$self->parse_options('help|h'=>sub {$self->usage},'noconfirm|n'=>sub {App::Task::Config->set_option('noconfirm'=>1)},'again'=>sub {App::Task::Config->set_option('redeploy'=>1)},);$self->set_environment($args->{destination_environment});my$branch_name=$self->env->{branch_name};$self->content_tracker->update_remotes;my ($branch_tip,$err,$exit_status)=App::Task::Base->system_call("git rev-parse 'origin/$branch_name'",ignore_exit_status=>1);if (!$branch_tip or $exit_status){$self->usage("No branch origin/$branch_name exists. Create it to do something useful")}chomp$branch_tip;if (scalar@ARGV and!$self->task_branch){my@files;while (my$arg=pop@ARGV){if ($arg =~ /-deploy\d+$/ && $self->add_task($arg)){$self->set_deployment_branch($arg)}elsif (!$self->add_task($arg)){my$file=$self->resolve_file($arg);push@files,$file}}if (@files){my$deployment_branch=$self->content_tracker->add_files_to_new_deployment_branch($self->task_branch,\@files);$self->set_deployment_branch($deployment_branch)}}}sub run {my ($self)=@_;my$current_dir=getcwd;my$env_name=$self->env->{name};my@branches;TASK: my$task_branch=$self->task_branch;my$ready=App::Task::Command::Ready->new(destination_environment=>$self->env->{name},content_tracker=>$self->content_tracker,deployment_branch=>$self->get_deployment_branch,);$ready->add_task($task_branch);my$branch_name=$ready->run;push(@branches,$branch_name);my@unpushed_files;my@deployment_branches;my$target_branch_name=$self->env->{branch_name};$task_branch=$self->task_branch;my$current_branch_name=$self->content_tracker->get_branch_name($task_branch);my$deployment_branch_name=$self->get_deployment_branch || $current_branch_name;my@files=$self->content_tracker->get_changed_files($task_branch,"origin/$target_branch_name",branch_name=>$deployment_branch_name);push(@unpushed_files,@files);my$mainline_branch=App::Task::Config->config->{mainline_branch};if (App::Task::Config->get_option('redeploy')){my ($file_list,$err,$exit_status)=App::Task::Base->system_call("git diff --name-only origin/$mainline_branch...$env_name/$deployment_branch_name",ignore_exit_status=>1);if (!$exit_status){chomp$file_list;my@files=map {s/^\s*|\s*$//ms;$_}split(/\n/,$file_list);push(@unpushed_files,@files)}}push@deployment_branches,$deployment_branch_name;my$changed_file_count=scalar@unpushed_files;if ($changed_file_count){print "$changed_file_count " .($changed_file_count > 1 ? 'files' : 'file')." to deploy to $env_name\n"}else {print "No changed files to deploy to $env_name";print "\n\n";return}my$remote_files=join(' ',map {"'$_'"}@unpushed_files);my$original_branch=$self->content_tracker->get_current_branch;my$temp_branch_exists=0;eval {my%merged_branches;my$temp_branch_name="temp_deploy_${env_name}";App::Task::Base->system_call("git checkout --track -b '$temp_branch_name' origin/$target_branch_name");$temp_branch_exists=1;for my$deployment_branch_name (@deployment_branches){if (!$self->env->{allow_ready}){$self->content_tracker->safe_merge($deployment_branch_name,$env_name,$target_branch_name,'','deploy')}else {$self->content_tracker->safe_merge("origin/$env_name-ready/$deployment_branch_name",$env_name,$temp_branch_name,'--ff-only','deploy')}$merged_branches{$deployment_branch_name}=1}my ($diffstat)=App::Task::Base->system_call("git diff --stat=120,100 'origin/$target_branch_name'..'$temp_branch_name'");print "Deploying the following changes to $env_name:\n$diffstat\n";if (!App::Task::Config->get_option('noconfirm')){print "Enter 'y' to continue, anything else to exit: ";chomp(my$response=<STDIN>);if (lc$response ne 'y'){$self->return_to_original_dir;App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D 'temp_deploy_$env_name'");exit}}App::Task::Base->system_call("git pull origin '$target_branch_name'");App::Task::Base->system_call("git push origin 'temp_deploy_$env_name:$target_branch_name'");print "Updated git $env_name branch\n";App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -d 'temp_deploy_$env_name'");$temp_branch_exists=0;my$current_dir=getcwd;my%deployed_branches;for my$branch_name (@branches){$deployed_branches{$branch_name}++}chomp(my ($deploy_sha)=App::Task::Base->system_call("git rev-parse HEAD"));my$hooks_ok=App::Task::Hooks->run_hooks($self,'post_deploy',{TASK_DEPLOY_ENVIRONMENT=>$env_name,TASK_DEPLOY_SHA=>$deploy_sha,});die "Failed to run hooks" unless$hooks_ok;if ($self->env->{branch_name}eq App::Task::Config->config->{mainline_branch}and $self->env->{dependent_environment}){App::Task::Config->set_option('needs-update'=>1);$self->content_tracker->update_remotes;my$dependent_env_name=$self->env->{dependent_environment};$self->merge_back_to_dependent_environments($env_name,$dependent_env_name)}chdir$current_dir or highlighted_die "Couldn't chdir to: $current_dir"};if ($@){$self->return_to_original_dir;App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D 'temp_deploy_$env_name'")if$temp_branch_exists;die $@}else {print color 'green';print "finished deploying to $env_name\n\n";print color 'reset'}}sub merge_back_to_dependent_environments {my ($self,$top_level_env,$dependent_env_name)=@_;my$top_level_env_branch=App::Task::Base->environments->{$top_level_env}{branch_name};my$dependent_env_branch=App::Task::Base->environments->{$dependent_env_name}{branch_name};my$temp_branch_name="temp_merge_${top_level_env}_back_to_${dependent_env_name}";App::Task::Base->system_call("git checkout -b '$temp_branch_name' origin/$dependent_env_branch");$self->content_tracker->safe_merge("origin/$top_level_env_branch",$dependent_env_name,"origin/$dependent_env_branch",'','');App::Task::Base->system_call("git push origin '$temp_branch_name:$dependent_env_branch'");my$mainline_branch=App::Task::Config->config->{mainline_branch};App::Task::Base->system_call("git checkout $mainline_branch");App::Task::Base->system_call("git branch -D '$temp_branch_name'");print "Merged changes from $top_level_env back to $dependent_env_name\n";if (my$next_dependent_env=App::Task::Base->environments->{$dependent_env_name}{dependent_environment}){$self->merge_back_to_dependent_environments($top_level_env,$next_dependent_env)}else {return}}no Moo;sub usage {my ($self,$message)=@_;print <<"END_USAGE";print "\n$message\n" if$message;exit 1}1;
  Usage: task deploy [-hn] [--again] environment <branch_name>
  
  Merge and deploy task branches
  
  Options:
  
      -h, --help       Show a brief help message and exit
      -n, --noconfirm  Don't show a confirmation message before doing the deploy
      --again          Ignore if a branch has already been deployed to an
                       environment and re-deploy again anyway. Basically this
                       will rerun your hooks for this environment without merging
                       anything
  END_USAGE
APP_TASK_COMMAND_DEPLOY

$fatpacked{"App/Task/Command/Ready.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_READY';
  package App::Task::Command::Ready;use Moo;use Term::ANSIColor;use App::Task::Config;with 'App::Task::Command';App::Task::Config->register_command(ready=>'Pre-merge a task branch with an environment branch for later deployment');sub BUILD {my ($self,$args)=@_;$self->parse_options('help|h'=>sub {$self->usage},);$self->set_environment($args->{destination_environment});if (scalar@ARGV and!$self->task_branch){my@files;while (my$arg=pop@ARGV){if ($arg =~ /-deploy\d+$/ && $self->add_task($arg)){$self->set_deployment_branch($arg)}elsif (!$self->add_task($arg)){my$file=$self->resolve_file($arg);push@files,$file}}if (@files){my$deployment_branch=$self->content_tracker->add_files_to_new_deployment_branch($self->task_branch,\@files);$self->set_deployment_branch($deployment_branch)}}}sub run {my ($self)=@_;my$is_final_command=(caller(4))[0]=~ /^App::Task::Base$/ ? 1 : 0;my (@changed_files,@ready_tasks,$diff_stat);my$env_name=$self->env->{name};my ($remotes)=App::Task::Base->system_call("git remote");my%remotes=map {$_=>1}split(/\n/,$remotes);if (!exists$remotes{'origin'}){die color('red')."You don't have a remote set up. Please re-clone the repository" .color('reset')}my$original_branch=$self->content_tracker->get_current_branch;my$merge_commit_id;my$repository_root=$self->content_tracker->get_repository_root;my$task_branch=$self->task_branch;my$branch_name=$self->content_tracker->get_branch_name($task_branch);my$deployment_branch_name=$self->get_deployment_branch || $branch_name;my$deployed_envs=$self->content_tracker->get_deployed_envs($deployment_branch_name);my$dependent_env=$self->env->{dependent_environment};if (defined$dependent_env and!exists$deployed_envs->{$dependent_env}){my$dependent_deploy=App::Task::Command::Deploy->new(destination_environment=>$self->env->{dependent_environment},content_tracker=>$self->content_tracker,deployment_branch=>$self->get_deployment_branch,);$dependent_deploy->add_task($task_branch);$dependent_deploy->run}App::Task::Base->system_call("git checkout $original_branch");my$remote_task_branch_name='';my$allow_ready=$self->env->{allow_ready};if (!$allow_ready){($remote_task_branch_name)=map {/^\s*(origin\/$deployment_branch_name)$/ims ? $1 : ()}`git branch -r`}else {($remote_task_branch_name)=map {/^\s*(origin\/$env_name-ready\/$deployment_branch_name)$/ims ? $1 : ()}`git branch -r`}my$temp_branch_name="temp_${env_name}_merge_$deployment_branch_name";eval {my$diff_branch=$temp_branch_name;my$env_branch_name=App::Task::Base->environments->{$env_name}{branch_name};if ($remote_task_branch_name){App::Task::Base->system_call("git checkout -b $temp_branch_name $remote_task_branch_name")}elsif ($allow_ready){App::Task::Base->system_call("git checkout -b $temp_branch_name origin/$env_branch_name")}else {App::Task::Base->system_call("git checkout -b $temp_branch_name $deployment_branch_name");$diff_branch="origin/$env_branch_name"}@changed_files=$self->content_tracker->get_changed_files($task_branch,$diff_branch,branch_name=>$deployment_branch_name);if ($is_final_command){($diff_stat)=App::Task::Base->system_call("git diff -p --stat --color '$diff_branch'...'$deployment_branch_name'",ignore_exit_status=>1)}$self->content_tracker->safe_merge($deployment_branch_name,$env_name,$temp_branch_name,'--no-ff --log',$remote_task_branch_name ? 're-ready' : 'ready');if ($allow_ready){$self->content_tracker->safe_merge("origin/$env_branch_name",$env_name,$temp_branch_name,'--no-ff --log',$remote_task_branch_name ? 're-ready' : 'ready')}chomp(($merge_commit_id)=App::Task::Base->system_call("git rev-parse '$temp_branch_name'"));push(@ready_tasks,$task_branch);if (!$allow_ready){App::Task::Base->system_call("git push origin 'HEAD:$deployment_branch_name'")}else {App::Task::Base->system_call("git push origin 'HEAD:$env_name-ready/$deployment_branch_name'")}App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D $temp_branch_name")};if ($@){App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D $temp_branch_name",ignore_exit_status=>1);App::Task::Base->instance->highlighted_die($@)}my$changed_file_count=scalar@changed_files;if ($changed_file_count){print "\n$changed_file_count " .($changed_file_count > 1 ? 'files' : 'file')." ready for $env_name\n"}else {print "\nNo changed files to set as ready for $env_name\n";return}print join('',map {"\t$deployment_branch_name\t$_\n"}@changed_files);print "\n";print "ready for $env_name - commit id: $merge_commit_id\n";my$github_url=App::Task::Config->config->{github_url};my$env_branch_name=App::Task::Base->environments->{$env_name}{branch_name};if ($github_url){print "View the full diff here: $github_url/compare/$env_branch_name...$merge_commit_id\n"}return$deployment_branch_name}sub usage {my ($self,$message)=@_;print <<"END_USAGE";print "\n$message\n" if$message;exit 1}1;
  Usage: task ready [-hn] environment <branch_name>
  
  Pre-merge task branches and set them as ready for deployment without actually deploying them
  
  Options:
  
      -h, --help     Show a brief help message and exit
  END_USAGE
APP_TASK_COMMAND_READY

$fatpacked{"App/Task/Command/Start.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_START';
  package App::Task::Command::Start;use Moo;use App::Task::Config;with 'App::Task::Command';App::Task::Config->register_command(start=>'Start work on a new or existing task branch');sub BUILD {my ($self,$args)=@_;$self->parse_options('help|h'=>sub {$self->usage},);my$arg=shift@ARGV;if ($arg){$self->task_branch($arg)}$self->{allow_branch_switch}=1;$self->usage("No feature branch name specified to start work on")if!$self->task_branch}sub run {my ($self)=@_;$self->content_tracker->update_remotes;if (my$branch=$self->task_branch){$self->create_task_branch($branch)}}sub create_task_branch {my ($self,$branch)=@_;my$branch_name=$self->content_tracker->get_branch_name($branch);$self->content_tracker->_create_branch($branch_name)}sub usage {my ($self,$message)=@_;print <<"END_USAGE";print "\n$message\n" if$message;exit 1}1;
  Usage: task start [-h] <branch_name>
  
  Properly starts a task branch from your mainline branch
  
  Options:
  
      -h, --help     Show a brief help message and exit
  
  Examples:
  
      task start feature/docs
  
      creates a branch feature/docs from origin/master
      or checks it out if someone else already created it
  END_USAGE
APP_TASK_COMMAND_START

$fatpacked{"App/Task/Command/Status.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_STATUS';
  package App::Task::Command::Status;use Moo;use Types::Standard qw(HashRef ArrayRef);use Term::ANSIColor;use IO::Interactive qw(is_interactive);use App::Task::Config;with 'App::Task::Command';has 'envs'=>(is=>'ro',isa=>HashRef,default=>sub {{}});has 'visited_commits'=>(is=>'rw',isa=>HashRef,default=>sub {return {}});has 'args'=>(is=>'rw',isa=>HashRef,default=>sub {return {}});has 'ordered_envs'=>(is=>'lazy',isa=>ArrayRef);has 'indent'=>(is=>'rw',default=>sub {0});has 'columns'=>(is=>'lazy');$|=1;App::Task::Config->register_command(status=>'View the status of a task branch');sub _build_columns {my$self=shift;return unless is_interactive();my ($wchar)=$ENV{COLUMNS}|| 80;return$wchar - 2};sub BUILD {my ($self,$args)=@_;$self->args->{color}=1 if is_interactive();$self->parse_options('help|h'=>sub {$self->usage},'diff|p!'=>\$self->args->{diff},'diff-options=s'=>\$self->args->{diff_options},'log|l!'=>\$self->args->{log},'log-options=s'=>\$self->args->{log_options},'color|colour|c!'=>\$self->args->{color},'all-commits!'=>\$self->args->{all_commits},'name-only!'=>\$self->args->{name_only},);my@new_argv;if (!scalar@ARGV){my$current_branch=$self->content_tracker->get_current_branch;$self->add_task($current_branch)}for my$arg (@ARGV){if (!$self->add_task($arg)){push(@new_argv,$arg)}}if (scalar@new_argv){$self->abort("Unrecognized option: '@new_argv'")}$self->usage if!$self->task_branch}sub _build_ordered_envs {my$self=shift;my$environments=App::Task::Base->environments;my ($current_top_level_env)=map {$environments->{$_}{branch_name}eq App::Task::Config->config->{mainline_branch}? $_ : ()}keys %$environments;my@ordered_envs;while ($current_top_level_env && defined$environments->{$current_top_level_env}){push(@ordered_envs,$current_top_level_env);push(@ordered_envs,"ready for $current_top_level_env")if$environments->{$current_top_level_env}{allow_ready};$current_top_level_env=$environments->{$current_top_level_env}{dependent_environment}|| undef}push(@ordered_envs,'Un-merged changes');return \@ordered_envs}sub increase_indent {my$self=shift;$self->indent($self->indent()+ 4)}sub decrease_indent {my$self=shift;$self->indent($self->indent()- 4)}sub print_indented {my ($self,$text)=@_;print " " x $self->indent(),$text,"\n"}sub get_status {my ($self,$task_branch_name)=@_;my$mainline_branch=App::Task::Config->config->{mainline_branch};chomp(my ($merged_to_master)=App::Task::Base->system_call("git rev-list -n 1 origin/$mainline_branch ^$task_branch_name"));my$master_before_merge=$merged_to_master ? "$merged_to_master^" : "origin/$mainline_branch";chomp(my ($merge_base)=App::Task::Base->system_call("git merge-base $master_before_merge $task_branch_name"));my$start=$merge_base;my$definitive_branch=$task_branch_name;my@branch_commits=$self->get_rev_list($start,$definitive_branch);unless (@branch_commits){$definitive_branch="origin/$task_branch_name";@branch_commits=$self->get_rev_list($start,$definitive_branch)}my%env_commits=$self->get_env_commits(start=>$start,branch=>$task_branch_name,branch_commits=>\@branch_commits,);return (env_commits=>\%env_commits,branch_commits=>\@branch_commits,)}sub get_env_commits {my ($self,%args)=@_;die "start not specified" if!$args{start};die "branch not specified" if!$args{branch};my$branch=$args{branch};my@envs=@{$self->ordered_envs};my@branch_rev_list=$args{branch_commits}? @{$args{branch_commits}}: $self->get_rev_list($args{start},$branch);$self->die_no_commits($branch)unless (@branch_rev_list);my%branch_rev_hash=map {$_=>1}@branch_rev_list;my%env_commits;my$prev_env;for my$env (@envs){my ($remote_branch,$repo)=$self->get_remote_branch_for_env($env,$branch);$remote_branch=$repo ? "$repo/$remote_branch" : $remote_branch;my$len=print_disappearing(msg=>"Fetching rev-list for '$env'...");my%remote_rev_list=map {exists$branch_rev_hash{$_}? ($_=>1): ()}$self->get_rev_list($args{start},$remote_branch);print_disappearing(len=>$len);$env_commits{$env}={abs_commits=>{list=>[],hash=>{}},rel_commits=>{list=>[],hash=>{}},};for my$commit (@branch_rev_list){if ($remote_rev_list{$commit}){push @{$env_commits{$env}->{abs_commits}->{list}},$commit;$env_commits{$env}->{abs_commits}->{hash}->{$commit}=1}}$env_commits{$env}->{branch_start_name}=$args{start};chomp(my ($start_ref)=App::Task::Base->system_call("git show-ref $args{start}",ignore_exit_status=>1,));$start_ref ||=$args{start};$env_commits{$env}->{branch_start_ref}=(split(/\s+/,$start_ref))[0];$env_commits{$env}->{branch_tip}=$env_commits{$env}->{abs_commits}->{list}->[0]|| '';if ($prev_env && $env_commits{$env}->{branch_tip}eq $env_commits{$prev_env}->{branch_tip}){$env_commits{$env}->{same_as_prev_env}=1}for my$commit (@{$env_commits{$env}->{abs_commits}->{list}}){my$prev_branch_tip=$prev_env && $env_commits{$prev_env}->{branch_tip};if ($prev_env && $prev_branch_tip && $commit eq $prev_branch_tip){$prev_env=$env;last}push @{$env_commits{$env}->{rel_commits}->{list}},$commit;$env_commits{$env}->{rel_commits}->{hash}->{$commit}=1}$prev_env=$env}return%env_commits}sub die_no_commits {my$self=shift;my ($branch)=@_;chomp(my ($stdout)=App::Task::Base->system_call("git branch -a"));my@all_branches=grep {s/^..//}split("\n",$stdout);my@branches=grep {m{(\w+/)*$branch}}@all_branches;if (@branches){warn$self->print_color(['red'],"The branch: '$branch' exists on the repositories below, but has no commits."),"\n";$self->increase_indent;$self->print_indented($_)for@branches;$self->decrease_indent;die "\n"}else {die$self->print_color(['red'],"The branch: '$branch' does not exist locally, or on any remote."),"\n"}}sub print_disappearing {my (%args)=@_;return unless is_interactive();if ($args{msg}){print$args{msg};return length$args{msg}}elsif ($args{len}){my$spaces=(' ')x $args{len};print "\r$spaces\r"}}sub get_branch_range {my ($start,$end)=@_;return$end ? "$start..$end" : $start}sub get_rev_list {my$self=shift;my ($start,$end)=@_;my$refspec=get_branch_range($start,$end);my@cmd_rev_list=('git rev-list --no-merges',$refspec);my$cmd=join ' ',@cmd_rev_list;my ($stdout,$stderr,$exit_status)=App::Task::Base->system_call($cmd,ignore_exit_status=>1,);my@rev_list=split "\n",$stdout;return@rev_list}sub get_remote_branch_for_env {my ($self,$env,$task_branch_name)=@_;my ($target_branch_name,$remote);my$final_env=$env;if ($env =~ /^ready for (\w+)/){$target_branch_name=$task_branch_name;$final_env=$1;if (!App::Task::Base->environments->{$final_env}{allow_ready}){$remote='origin'}else {$remote="origin/$final_env-ready"}}elsif ($env eq 'Un-merged changes'){$target_branch_name=$task_branch_name;$remote=''}else {$target_branch_name=App::Task::Base->environments->{$final_env}{branch_name};$remote="origin"}if ($target_branch_name eq App::Task::Config->config->{mainline_branch}){$target_branch_name=App::Task::Base->environments->{$final_env}{branch_name}}return ($target_branch_name,$remote)}sub print_git_command {my$self=shift;my ($cmd)=@_;my ($output,$error,$exit_status)=App::Task::Base->system_call($cmd);my@lines=split(/\n/,$output);if ($cmd =~ /--stat\b/){if (grep {$_ =~ m{ \.\.\./}}@lines){push@lines,$self->print_color(['black']," (specify --name-only to see full file names)")}}$self->print_indented($_)for@lines;print "\n";return [$output,$error,$exit_status]}sub get_indented_screen_width {my$self=shift;return unless$self->columns;return$self->columns - $self->indent}sub make_git_stat_cmd {my$self=shift;my$w=$self->get_indented_screen_width;return '--stat' unless$w;return "--stat=$w,$w"}sub print_color {my$self=shift;my ($color_list,$string)=@_;if ($self->args->{color}){return colored($color_list,$string)}else {return$string}}sub run {my ($self)=@_;if (my$branch=$self->task_branch){my$task_branch_name=$self->content_tracker->get_branch_name($branch);my@deployment_branches=$self->content_tracker->get_all_deployment_branches($branch);for my$branch_name ($task_branch_name,@deployment_branches){my%status=$self->get_status($branch_name);$self->print_status_info(branch=>$branch_name,status=>\%status,)}}}sub print_status_info {my$self=shift;my%args=@_;my$task_branch_name=$args{branch};die "branch not specified" if!$args{branch};die "status not specified" if!$args{status};my$git_args=$self->args->{color}? '--color' : '';$self->print_indented($self->print_color(['bold'],"Deployment status for $task_branch_name:\n"));$self->increase_indent;my@envs=@{$self->ordered_envs};my$prev_env;for my$env (@envs){my%env_commits=%{$args{status}->{env_commits}->{$env}};my$commit_key='rel_commits';my@commits=@{$env_commits{$commit_key}->{list}|| []};if (!scalar@commits || $env_commits{same_as_prev_env}){$prev_env=$env;next}my$commit_last=$env_commits{branch_tip};my$commit_first;if ($prev_env && $commit_key eq 'rel_commits'){$commit_first=$args{status}{env_commits}{$prev_env}{branch_tip}}$commit_first ||=$env_commits{branch_start_ref};my$commit_range="$commit_first..$commit_last";$self->print_env_label($env);$self->increase_indent;if ($self->args->{log}){my@log_args=('--no-merges');push@log_args,$self->make_git_stat_cmd();push@log_args,'-p' if$self->args->{diff};push@log_args,'--name-only' if$self->args->{name_only};$self->print_git_command(sprintf("git log $git_args %s %s %s",defined$self->args->{log_options}? $self->args->{log_options}: '',join(' ',@log_args),$commit_range))}else {my$l=$self->print_color(['blue'],"Branch tip:  ");my$c=$self->print_color(['yellow'],$commit_last);$self->print_indented("$l $c");my$short_range=$commit_first eq $commit_last ? substr($commit_first,0,7): substr($commit_first,0,7).'..' .substr($commit_last,0,7);$self->print_indented(sprintf("%s %s (%d commit%s)",$self->print_color(['blue'],"Commit range:"),$self->print_color(['yellow'],"$short_range"),scalar@commits,scalar@commits==1 ? '' : 's',));if ($self->args->{all_commits}){$self->print_indented($self->print_color(['blue'],"All commits:"));$self->increase_indent;for my$commit (@commits){$self->print_indented($self->print_color(['yellow'],$commit))}$self->decrease_indent}print "\n";my@diff_args;push@diff_args,'--name-only' if$self->args->{name_only};push@diff_args,$self->make_git_stat_cmd();push@diff_args,sprintf('-p %s',(defined$self->args->{diff_options}? $self->args->{diff_options}: ''))if$self->args->{diff};$self->print_git_command(sprintf("git diff $git_args %s %s",join(' ',@diff_args),$commit_range,))}$self->decrease_indent;$prev_env=$env}$self->decrease_indent}sub print_env_label {my$self=shift;my ($env)=@_;my$env_label="$env" ;$self->print_indented($self->print_color(['bold green'],"$env_label:"));if ($self->args->{log}|| $self->args->{diff}){$self->print_indented($self->print_color(['bold green'],'-' x ($self->get_indented_screen_width || 80)))}}sub abort {my ($self,$message)=@_;print color 'red';print "$message\n";print color 'reset';exit}no Moo;no Types::Standard;sub usage {my ($self,$message)=@_;print <<"END_USAGE";print "\n$message\n" if$message;exit 1}1;
  Usage: task status [-h] <branch_name>
  
  Get info about which environments files for a task have been pushed to. Checks
  the status of the current task branch if none is specified.
  
  The most current version of the file (on HEAD) always shows up in bold.
  
  Options:
  
      -h, --help               Show a brief help message and exit
      --all-commits            Print a list of commits affected for each
                               environment, rather than just the commit range. This
                               gives a complete list of commits, without the
                               verbosity of --log.
      -c, --color, --colour    Enable colored output. On by default. Off when the
                               terminal isn't interactive, but can be forced by
                               manually setting --color.
      --diff-options <options> Specifies extra options to pass to `git diff` when
                               -p or --diff are used.
      -l, --log                Print `git log` information for each environment.
                               Can be used with --stat and -p or --diff to print
                               stat and diff information for each log entry.
      --log-options <options>  Specifies extra options to pass to `git log` when
                               --log is used.
      --name-only              Print a list of files affected for each environment,
                               without the verbosity of --stat. Can also be used if
                               the files affected printed by --stat are
                               abbreviated, since --name-only will not abbreviate
                               file names.
      -p, --diff               Print `git diff` information for each environment.
                               This will show diffs for entire environments, or
                               per log entry if used with --log.
  END_USAGE
APP_TASK_COMMAND_STATUS

$fatpacked{"App/Task/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_CONFIG';
  package App::Task::Config;use strict;use warnings;use YAML qw(LoadFile);my (%commands,%config_data);our%options;sub register_command {my ($module,$name,$description)=@_;if ($module eq __PACKAGE__){($module)=caller}$commands{$name}={description=>$description,module=>$module,}}sub command_list {return sort keys%commands}sub find_command {my ($package,$name)=@_;return$commands{$name}}sub get_option {my ($package,$option_name)=@_;return$options{$option_name}}sub set_option {my ($package,$option_name,$value)=@_;$options{$option_name}=$value}sub configure {my ($package,$config_file)=@_;undef%config_data;my ($relative_to_root)=`git rev-parse --show-cdup 2>/dev/null`;if ($?){return "You are not in a git repository."}chomp$relative_to_root;if (!$config_file){$config_file=($relative_to_root ? "$relative_to_root/" : '').'deployment.yaml'}if (-e $config_file && -r $config_file){my$repo_config=LoadFile$config_file or die "Couldn't load config file '$config_file'. Malformed yaml\n";$config_data{environments}=$repo_config->{environments};$config_data{mainline_branch}=$repo_config->{mainline_branch}|| 'master';$config_data{github_url}=$repo_config->{github_url};$config_data{hooks}=$repo_config->{hooks}}else {return "Can't read config file: $config_file"}$config_data{repo_root}=$relative_to_root || ".";for my$env (keys %{$config_data{environments}}){$config_data{environments}{$env}{name}=$env}return}sub config {return \%config_data}1;
APP_TASK_CONFIG

$fatpacked{"App/Task/ContentTracker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_CONTENTTRACKER';
  package App::Task::ContentTracker;use Moo;use File::Spec::Functions qw(rel2abs abs2rel);use Cwd qw(getcwd);use Term::ANSIColor;use IO::Interactive qw(is_interactive);has 'current_branch'=>(is=>'rw',lazy=>1,builder=>'_build_current_branch',clearer=>'_clear_current_branch',);has 'all_branches'=>(is=>'ro',lazy=>1,builder=>'_build_all_branches',clearer=>'_clear_all_branches',);no Moo;sub get_repository_root {my ($abs_top_level_dir)=App::Task::Base->system_call("git rev-parse --show-toplevel");chomp$abs_top_level_dir;return$abs_top_level_dir}sub create_deployment_branch {my ($self,$branch)=@_;my$task_branch_name=$self->get_branch_name($branch);my$deployment_branch_name=$self->get_next_deployment_branch_name($branch);my$mainline_branch=App::Task::Config->config->{mainline_branch};my ($merge_commit)=App::Task::Base->system_call("git merge-base $task_branch_name $mainline_branch",ignore_exit_status=>1);$self->_create_branch($deployment_branch_name,$merge_commit);return$deployment_branch_name}sub _create_branch {my ($self,$branch_name,$start_ref)=@_;my$mainline_branch=App::Task::Config->config->{mainline_branch};my@branches=@{$self->all_branches};if (!$start_ref){if (scalar grep {/^remotes\/origin\/$mainline_branch/ims}@branches){$start_ref="origin/$mainline_branch"}else {$start_ref=$mainline_branch}}my$original_branch=$self->get_current_branch;my$current_dir=getcwd;if (scalar grep {/^\Q$branch_name/i}@branches){my ($output)=App::Task::Base->system_call("git checkout $branch_name",combine=>1);print$output}elsif (scalar grep {/^remotes\/origin\/\Q$branch_name\E$/i}@branches){my ($output)=App::Task::Base->system_call("git checkout --track -b $branch_name origin/$branch_name");print$output}else {App::Task::Base->system_call("git checkout --no-track -b $branch_name $start_ref");print "Created and switched to branch '$branch_name' from $start_ref\n";if ($start_ref eq "origin/$mainline_branch"){App::Task::Base->system_call("git branch --set-upstream $branch_name $start_ref")}}$self->_clear_all_branches;$self->current_branch($branch_name);return$branch_name}sub add_files_to_new_deployment_branch {my ($self,$branch,$files)=@_;die "No branch specified to add files to" if!$branch;my$original_branch=$self->get_current_branch;my$current_dir=getcwd;my$branch_name=$self->create_deployment_branch($branch);$self->_add_files_to_branch(source_branch=>$original_branch,target_branch=>$branch_name,current_dir=>$current_dir,files=>$files,);return$branch_name}sub _add_files_to_branch {my ($self,%args)=@_;my$original_branch=$args{source_branch}or die 'no target branch';my$branch_name=$args{target_branch}or die 'no target branch';my$current_dir=$args{current_dir}|| getcwd;my@files=@{$args{files}|| []};chdir$self->get_repository_root;my$file_list=join(' ',map {"'$_'"}@files);App::Task::Base->system_call("git checkout $original_branch $file_list");App::Task::Base->system_call("git commit -n -m \"Added files: $file_list to branch $branch_name from branch $original_branch\"",ignore_exit_status=>1);App::Task::Base->system_call("git checkout $original_branch");chdir$current_dir;if ($original_branch ne $branch_name){print "Added the following " .(scalar(@files)==1 ? 'file' : 'files')." from branch '$original_branch' into branch '$branch_name': $file_list\n"}else {print((scalar(@files)==1 ? 'File is' : 'Files are')." already in branch '$branch_name': $file_list\n")}}sub get_deployed_envs {my ($self,$branch_name)=@_;my ($remote_branches)=App::Task::Base->system_call("git branch -r --contains $branch_name");my%env_names=map {$_=>1}keys %{App::Task::Base->environments};my%deployed_envs;for my$raw_branch (split("\n",$remote_branches)){my ($remote)=$raw_branch =~ / *\*? *origin\/(\w+)$/;next if!$remote;next if!exists$env_names{$remote};$deployed_envs{$remote}=1}return \%deployed_envs}sub get_current_branch {my ($self)=@_;return$self->current_branch}sub _build_current_branch {my ($self)=@_;my ($branches)=App::Task::Base->system_call("git branch");my ($current_branch)=$branches =~ /^\* ([^\n]+)/ims;return$current_branch}sub _build_all_branches {my ($self)=@_;my ($branches)=App::Task::Base->system_call("git branch -a");my@branches;for my$branch (split /^/,$branches){chomp$branch;$branch =~ s/^(\*?)[ \t]*(.*)[ \t]*$/$2/;$self->current_branch($branch)if $1;push@branches,$branch}return \@branches}sub unique_branches {my ($self)=@_;my (%branches,@branches);for my$branch (@{$self->all_branches}){my$non_origin_branch=$branch;$non_origin_branch =~ s/^remotes\/origin\///;next if exists$branches{$non_origin_branch};$branches{$non_origin_branch}=1;push@branches,$non_origin_branch}return \@branches}sub get_branches_by_prefix {my ($self,$prefix)=@_;my@branches=@{$self->unique_branches};my@matches=grep {/^\Q$prefix/}@branches;return@matches}sub get_branch_name {my ($self,$branch)=@_;if ($branch){my@existing_branches_matching=$self->get_branches_by_prefix($branch);if (grep {$_ eq $branch}@existing_branches_matching){return$branch}@existing_branches_matching=grep {!/[\/-]deploy\d+$/}@existing_branches_matching;if (@existing_branches_matching > 1){die "Ambiguous branch specified $branch:\n",join("\n",map "  $_",@existing_branches_matching)}if (@existing_branches_matching){return$existing_branches_matching[0]}return$branch}else {return$self->get_current_branch}}sub get_next_deployment_branch_name {my ($self,$branch)=@_;my@existing=$self->get_all_deployment_branches($branch);my$deployment_branch_count=0;for my$branch_name (@existing){if ($branch_name =~ /[\/-]deploy(\d+)$/i){$deployment_branch_count=$1 if $1 > $deployment_branch_count}}return "$branch-deploy" .($deployment_branch_count + 1)}sub get_all_deployment_branches {my ($self,$branch)=@_;my@branches=@{$self->unique_branches};my%deployment_branches;for my$branch_name (@branches){if ($branch_name =~ /^($branch[\/-]deploy(\d+))/ims){$deployment_branches{$2}=$1}}return map {$deployment_branches{$_}}sort {$a <=> $b}keys%deployment_branches}sub get_changed_files {my ($self,$branch,$commit_id,%options)=@_;my$branch_name;if ($options{branch_name}){$branch_name=$options{branch_name}}else {$branch_name=$self->get_branch_name($branch)}my ($file_list,$error,$exit_status)=App::Task::Base->system_call("git diff --name-only \$(git merge-base $branch_name $commit_id) $branch_name",ignore_exit_status=>1);chomp$file_list;my@files=map {s/^\s*|\s*$//ms;$_}split(/\n/,$file_list);return@files}sub safe_merge {my ($self,$merge_branch_name,$env_name,$target_branch,$options,$action)=@_;my$target_branch_name=App::Task::Base->environments->{$env_name}{branch_name};my ($merge_output,$merge_errors,$exit_status)=App::Task::Base->system_call("git merge $options $merge_branch_name",ignore_exit_status=>1);if ($exit_status){my@bad_files=$self->get_conflicted_files;my$remote_task_branch_exclude='';if ($action eq 're-ready'){print "merging local branch $merge_branch_name into $env_name/$merge_branch_name failed\n";$remote_task_branch_exclude=" ^$target_branch"}elsif ($action eq 'ready'){print "merging local branch $merge_branch_name into origin/$target_branch_name to create $merge_branch_name on $env_name failed\n"}elsif ($action eq 'deploy'){print "merging local branch $merge_branch_name into origin/$target_branch_name failed\n"}else {print "merging local branch $merge_branch_name into $target_branch failed\n"}print "See the entire problem through 'git diff ^origin/$target_branch_name$remote_task_branch_exclude $merge_branch_name'\n";print "This probably means that another task that has been pushed to $env_name conflicts with branch $merge_branch_name. 'git blame' on conflicting files and git branch -r contains <commit_id> for lines with conflicts, should give you enough information to find out which task branch is conflicting. It is recommended to add one branch to the other and make one dependent on the other to make it so you won't have to fix conflicts at every environment deploy\n\n";print "-----------------\n\n";print `git diff`;print "\n\nHow do you want to resolve this conflict?\n";my$response=App::Task::Base->prompt(s=>'open a shell to fix the merge manually',default=>'reset',);eval {if ($response =~ /open a shell/i){print "Fix your conflict and commit\n";print "Exit shell to finish the deployment\n";system('bash')}else {die "Exiting"}my@remaining_bad_files=$self->get_conflicted_files;if (@remaining_bad_files){die "You didn't fix: @remaining_bad_files\n"}print "conflicts resolved\n"};if ($@){print "Resetting merge...\n";App::Task::Base->system_call("git reset --merge");die color('red')."Can't continue after a failed merge to environment: $env_name\n$@\n" .color('reset')}}}sub get_conflicted_files {my$self=shift;my$output=`git status -s`;chomp$output;my@files=split("\n",$output);my$relative_to_root=`git rev-parse --show-cdup`;chomp$relative_to_root;my@conflicted_files;for my$file (@files){if (my ($path)=$file =~ /^ *U\w+ *(.*)/){push@conflicted_files,"$relative_to_root$path"}}return@conflicted_files}sub update_remotes {my ($self)=@_;if (App::Task::Config->get_option('needs-update')){my$msg="Updating remote git repositories...";print$msg if is_interactive();App::Task::Base->system_call("git remote update --prune");printf("\r%s\r",' ' x length($msg))if is_interactive();App::Task::Config->set_option('needs-update'=>0)}}1;
APP_TASK_CONTENTTRACKER

$fatpacked{"App/Task/Hooks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_HOOKS';
  package App::Task::Hooks;use Moo;use App::Task::Config;sub default_env {my$config=App::Task::Config->config;return (TASK_REPO_ROOT=>$config->{repo_root},)}sub find_hooks {my ($self,$command,$hook_name)=@_;my@hooks;my$hooks=$command->env->{hooks};if ($hooks && $hooks->{$hook_name}){push@hooks,@{$hooks->{$hook_name}}}my$global_hooks=App::Task::Config->config->{hooks};if ($global_hooks && $global_hooks->{$hook_name}){push@hooks,@{$global_hooks->{$hook_name}}}return@hooks}sub run_hooks {my ($self,$command,$hook_name,$env)=@_;my@hooks=$self->find_hooks($command,$hook_name);{local%ENV=(%ENV,$self->default_env,%{$env || {}},);for my$hook (@hooks){my$ok=$self->run_hook($command,$hook_name,$hook);if (!$ok){return}}}return 1}sub run_hook {my ($self,$command,$hook_name,$hook)=@_;my$root=App::Task::Config->config->{repo_root};my$hook_path="$root/$hook";my$prelude="Hook '$hook_path' for $hook_name";if (!-e $hook_path){warn "$prelude doesn't exist, skipping";return 1}if (!-x $hook_path){warn "$prelude isn't executable, skipping";return 1}my$system_ret=system($hook_path);if ($system_ret){if ($?==-1){warn "$prelude couldn't be executed: $!"}elsif ($? & 127){warn "$prelude exited with signal ",($? & 127)}else {warn "$prelude exited with nonzero status ",$? >> 8}return 0}else {return 1}}1;
APP_TASK_HOOKS

$fatpacked{"Carp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP';
  package Carp;{use 5.006}use strict;use warnings;BEGIN {if(!defined($warnings::VERSION)|| eval($warnings::VERSION)< 1.06){${^WARNING_BITS}=""}else {"warnings"->unimport("utf8")}}sub _fetch_sub {my($pack,$sub)=@_;$pack .= '::';return unless exists($::{$pack});for ($::{$pack}){return unless ref \$_ eq 'GLOB' && *$_{HASH}&& exists $$_{$sub};for ($$_{$sub}){return ref \$_ eq 'GLOB' ? *$_{CODE}: undef}}}BEGIN {if("$]" < 5.013011){*UTF8_REGEXP_PROBLEM=sub () {1}}else {*UTF8_REGEXP_PROBLEM=sub () {0}}}BEGIN {if(defined(my$sub=_fetch_sub utf8=>'is_utf8')){*is_utf8=$sub}else {*is_utf8=sub {unpack("C","\xaa".$_[0])!=170}}}BEGIN {if(defined(my$sub=_fetch_sub utf8=>'downgrade')){*downgrade=\&{"utf8::downgrade"}}else {*downgrade=sub {my$r="";my$l=length($_[0]);for(my$i=0;$i!=$l;$i++){my$o=ord(substr($_[0],$i,1));return if$o > 255;$r .= chr($o)}$_[0]=$r}}}our$VERSION='1.32';our$MaxEvalLen=0;our$Verbose=0;our$CarpLevel=0;our$MaxArgLen=64;our$MaxArgNums=8;our$RefArgFormatter=undef;require Exporter;our@ISA=('Exporter');our@EXPORT=qw(confess croak carp);our@EXPORT_OK=qw(cluck verbose longmess shortmess);our@EXPORT_FAIL=qw(verbose);our%CarpInternal;our%Internal;$CarpInternal{Carp}++;$CarpInternal{warnings}++;$Internal{Exporter}++;$Internal{'Exporter::Heavy'}++;sub export_fail {shift;$Verbose=shift if $_[0]eq 'verbose';@_}sub _cgc {no strict 'refs';return \&{"CORE::GLOBAL::caller"}if defined &{"CORE::GLOBAL::caller"};return}sub longmess {local($!,$^E);my$cgc=_cgc();my$call_pack=$cgc ? $cgc->(): caller();if ($Internal{$call_pack}or $CarpInternal{$call_pack}){return longmess_heavy(@_)}else {local$CarpLevel=$CarpLevel + 1;return longmess_heavy(@_)}}our@CARP_NOT;sub shortmess {local($!,$^E);my$cgc=_cgc();local@CARP_NOT=$cgc ? $cgc->(): caller();shortmess_heavy(@_)}sub croak {die shortmess @_}sub confess {die longmess @_}sub carp {warn shortmess @_}sub cluck {warn longmess @_}BEGIN {if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015)|| ("$]" >= 5.012005 && "$]" < 5.013)){*CALLER_OVERRIDE_CHECK_OK=sub () {1}}else {*CALLER_OVERRIDE_CHECK_OK=sub () {0}}}sub caller_info {my$i=shift(@_)+ 1;my%call_info;my$cgc=_cgc();{@DB::args=\$i if CALLER_OVERRIDE_CHECK_OK;package DB;@call_info{qw(pack file line sub has_args wantarray evaltext is_require) }=$cgc ? $cgc->($i): caller($i)}unless (defined$call_info{file}){return ()}my$sub_name=Carp::get_subname(\%call_info);if ($call_info{has_args}){my@args;if (CALLER_OVERRIDE_CHECK_OK && @DB::args==1 && ref$DB::args[0]eq ref \$i && $DB::args[0]==\$i){@DB::args=();local $@;my$where=eval {my$func=$cgc or return '';my$gv=(_fetch_sub B=>'svref_2object' or return '')->($func)->GV;my$package=$gv->STASH->NAME;my$subname=$gv->NAME;return unless defined$package && defined$subname;return if$package eq 'CORE::GLOBAL' && $subname eq 'caller';" in &${package}::$subname"}|| '';@args ="** Incomplete caller override detected$where; \@DB::args were not set **"}else {@args=@DB::args;my$overflow;if ($MaxArgNums and @args > $MaxArgNums){$#args=$MaxArgNums;$overflow=1}@args=map {Carp::format_arg($_)}@args;if ($overflow){push@args,'...'}}$sub_name .= '(' .join(', ',@args).')'}$call_info{sub_name}=$sub_name;return wantarray()? %call_info : \%call_info}our$in_recurse;sub format_arg {my$arg=shift;if (ref($arg)){if (!$in_recurse && do {local $@;local$in_recurse=1;local$SIG{__DIE__}=sub{};eval {$arg->can('CARP_TRACE')}}){return$arg->CARP_TRACE()}elsif (!$in_recurse && defined($RefArgFormatter)&& do {local $@;local$in_recurse=1;local$SIG{__DIE__}=sub{};eval {$arg=$RefArgFormatter->($arg);1}}){return$arg}else {my$sub=_fetch_sub(overload=>'StrVal');return$sub ? &$sub($arg): "$arg"}}return "undef" if!defined($arg);downgrade($arg,1);return$arg if!(UTF8_REGEXP_PROBLEM && is_utf8($arg))&& $arg =~ /\A-?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?\z/;my$suffix="";if (2 < $MaxArgLen and $MaxArgLen < length($arg)){substr ($arg,$MaxArgLen - 3)="";$suffix="..."}if(UTF8_REGEXP_PROBLEM && is_utf8($arg)){for(my$i=length($arg);$i--;){my$c=substr($arg,$i,1);my$x=substr($arg,0,0);if($c eq "\"" || $c eq "\\" || $c eq "\$" || $c eq "\@"){substr$arg,$i,0,"\\";next}my$o=ord($c);substr$arg,$i,1,sprintf("\\x{%x}",$o)if$o < 0x20 || $o > 0x7f}}else {$arg =~ s/([\"\\\$\@])/\\$1/g;$arg =~ s/([^ -~])/sprintf("\\x{%x}",ord($1))/eg}downgrade($arg,1);return "\"".$arg."\"".$suffix}sub Regexp::CARP_TRACE {my$arg="$_[0]";downgrade($arg,1);if(UTF8_REGEXP_PROBLEM && is_utf8($arg)){for(my$i=length($arg);$i--;){my$o=ord(substr($arg,$i,1));my$x=substr($arg,0,0);substr$arg,$i,1,sprintf("\\x{%x}",$o)if$o < 0x20 || $o > 0x7f}}else {$arg =~ s/([^ -~])/sprintf("\\x{%x}",ord($1))/eg}downgrade($arg,1);my$suffix="";if($arg =~ /\A\(\?\^?([a-z]*)(?:-[a-z]*)?:(.*)\)\z/s){($suffix,$arg)=($1,$2)}if (2 < $MaxArgLen and $MaxArgLen < length($arg)){substr ($arg,$MaxArgLen - 3)="";$suffix="...".$suffix}return "qr($arg)$suffix"}sub get_status {my$cache=shift;my$pkg=shift;$cache->{$pkg}||=[{$pkg=>$pkg },[trusts_directly($pkg)]];return @{$cache->{$pkg}}}sub get_subname {my$info=shift;if (defined($info->{evaltext})){my$eval=$info->{evaltext};if ($info->{is_require}){return "require $eval"}else {$eval =~ s/([\\\'])/\\$1/g;return "eval '" .str_len_trim($eval,$MaxEvalLen)."'"}}if (!defined($info->{sub})){return '__ANON__::__ANON__'}return ($info->{sub}eq '(eval)')? 'eval {...}' : $info->{sub}}sub long_error_loc {my$i;my$lvl=$CarpLevel;{++$i;my$cgc=_cgc();my@caller=$cgc ? $cgc->($i): caller($i);my$pkg=$caller[0];unless (defined($pkg)){if (%Internal){local%Internal;$i=long_error_loc();last}elsif (defined$caller[2]){redo unless 0 > --$lvl;last}else {return 2}}redo if$CarpInternal{$pkg};redo unless 0 > --$lvl;redo if$Internal{$pkg}}return$i - 1}sub longmess_heavy {return @_ if ref($_[0]);my$i=long_error_loc();return ret_backtrace($i,@_)}sub ret_backtrace {my ($i,@error)=@_;my$mess;my$err=join '',@error;$i++;my$tid_msg='';if (defined&threads::tid){my$tid=threads->tid;$tid_msg=" thread $tid" if$tid}my%i=caller_info($i);$mess="$err at $i{file} line $i{line}$tid_msg";if(defined $.){local $@='';local$SIG{__DIE__};eval {CORE::die};if($@ =~ /^Died at .*(, <.*?> line \d+).$/){$mess .= $1}}$mess .= "\.\n";while (my%i=caller_info(++$i)){$mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n"}return$mess}sub ret_summary {my ($i,@error)=@_;my$err=join '',@error;$i++;my$tid_msg='';if (defined&threads::tid){my$tid=threads->tid;$tid_msg=" thread $tid" if$tid}my%i=caller_info($i);return "$err at $i{file} line $i{line}$tid_msg\.\n"}sub short_error_loc {my$cache={};my$i=1;my$lvl=$CarpLevel;{my$cgc=_cgc();my$called=$cgc ? $cgc->($i): caller($i);$i++;my$caller=$cgc ? $cgc->($i): caller($i);if (!defined($caller)){my@caller=$cgc ? $cgc->($i): caller($i);if (@caller){redo if defined($called)&& $CarpInternal{$called};redo unless 0 > --$lvl;last}else {return 0}}redo if$Internal{$caller};redo if$CarpInternal{$caller};redo if$CarpInternal{$called};redo if trusts($called,$caller,$cache);redo if trusts($caller,$called,$cache);redo unless 0 > --$lvl}return$i - 1}sub shortmess_heavy {return longmess_heavy(@_)if$Verbose;return @_ if ref($_[0]);my$i=short_error_loc();if ($i){ret_summary($i,@_)}else {longmess_heavy(@_)}}sub str_len_trim {my$str=shift;my$max=shift || 0;if (2 < $max and $max < length($str)){substr($str,$max - 3)='...'}return$str}sub trusts {my$child=shift;my$parent=shift;my$cache=shift;my ($known,$partial)=get_status($cache,$child);while (@$partial and not exists$known->{$parent}){my$anc=shift @$partial;next if exists$known->{$anc};$known->{$anc}++;my ($anc_knows,$anc_partial)=get_status($cache,$anc);my@found=keys %$anc_knows;@$known{@found}=();push @$partial,@$anc_partial}return exists$known->{$parent}}sub trusts_directly {my$class=shift;no strict 'refs';my$stash=\%{"$class\::"};for my$var (qw/CARP_NOT ISA/){if ($stash->{$var}&& *{$stash->{$var}}{ARRAY}&& @{$stash->{$var}}){return @{$stash->{$var}}}}return}if(!defined($warnings::VERSION)|| do {no warnings "numeric";$warnings::VERSION < 1.03}){no strict "refs";*{"warnings::$_"}=\&$_ foreach@EXPORT}1;
CARP

$fatpacked{"Carp/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_HEAVY';
  package Carp::Heavy;use Carp ();our$VERSION='1.32';my$cv=defined($Carp::VERSION)? $Carp::VERSION : "undef";if($cv ne $VERSION){die "Version mismatch between Carp $cv ($INC{q(Carp.pm)}) and Carp::Heavy $VERSION ($INC{q(Carp/Heavy.pm)}).  Did you alter \@INC after Carp was loaded?\n"}1;
CARP_HEAVY

$fatpacked{"Class/Method/Modifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_METHOD_MODIFIERS';
  package Class::Method::Modifiers;BEGIN {$Class::Method::Modifiers::AUTHORITY='cpan:SARTAK'}{$Class::Method::Modifiers::VERSION='2.08'}use strict;use warnings;use base ('Exp'.'orter');our@EXPORT=qw(before after around);our@EXPORT_OK=(@EXPORT,qw(fresh install_modifier));our%EXPORT_TAGS=(moose=>[qw(before after around)],all=>\@EXPORT_OK,);BEGIN {*_HAS_READONLY=$] >= 5.008 ? sub(){1}: sub(){0}}our%MODIFIER_CACHE;sub _install_modifier;*_install_modifier=\&install_modifier;sub install_modifier {my$into=shift;my$type=shift;my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';return _fresh($into,$code,@names)if$type eq 'fresh';for my$name (@names){my$hit=$into->can($name)or do {require Carp;Carp::confess("The method '$name' is not found in the inheritance hierarchy for class $into")};my$qualified=$into.'::'.$name;my$cache=$MODIFIER_CACHE{$into}{$name}||={before=>[],after=>[],around=>[],};if (!exists($cache->{"orig"})){no strict 'refs';$cache->{"orig"}=*{$qualified}{CODE};$cache->{"wrapped"}=$cache->{"orig"}|| $hit}if ($type eq 'after'){push @{$cache->{$type}},$code}else {unshift @{$cache->{$type}},$code}if ($type eq 'around'){my$method=$cache->{wrapped};my$attrs=_sub_attrs($code);$cache->{wrapped}=eval "package $into; +sub $attrs { \$code->(\$method, \@_); };"}if (@{$cache->{$type}}==1){my$before=$cache->{"before"};my$after=$cache->{"after"};my$wrapped=\$cache->{"wrapped"};my$attrs=_sub_attrs($cache->{wrapped});my$generated="package $into;\n";$generated .= "sub $name $attrs {";if (@$before){$generated .= '
                      for my $method (@$before) {
                          $method->(@_);
                      }
                  '}if (@$after){$generated .= '
                      my $ret;
                      if (wantarray) {
                          $ret = [$$wrapped->(@_)];
                          '.(_HAS_READONLY ? 'Internals::SvREADONLY(@$ret, 1);' : '').'
                      }
                      elsif (defined wantarray) {
                          $ret = \($$wrapped->(@_));
                      }
                      else {
                          $$wrapped->(@_);
                      }
  
                      for my $method (@$after) {
                          $method->(@_);
                      }
  
                      wantarray ? @$ret : $ret ? $$ret : ();
                  '}else {$generated .= '$$wrapped->(@_);'}$generated .= '}';no strict 'refs';no warnings 'redefine';no warnings 'closure';eval$generated}}}sub before {_install_modifier(scalar(caller),'before',@_)}sub after {_install_modifier(scalar(caller),'after',@_)}sub around {_install_modifier(scalar(caller),'around',@_)}sub fresh {my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';_fresh(scalar(caller),$code,@names)}sub _fresh {my ($into,$code,@names)=@_;for my$name (@names){if ($name !~ /\A [a-zA-Z_] [a-zA-Z0-9_]* \z/xms){require Carp;Carp::confess("Invalid method name '$name'")}if ($into->can($name)){require Carp;Carp::confess("Class $into already has a method named '$name'")}if (_is_in_package($code,$into)){no strict 'refs';*{"$into\::$name"}=$code}else {no warnings 'closure';my$attrs=_sub_attrs($code);eval "package $into; sub $name $attrs { \$code->(\@_) }"}}}sub _sub_attrs {my ($coderef)=@_;local*_sub=$coderef;local $@;(eval 'sub { _sub = 1 }')? ':lvalue' : ''}sub _is_in_package {my ($coderef,$package)=@_;require B;my$cv=B::svref_2object($coderef);return$cv->GV->STASH->NAME eq $package}1;
CLASS_METHOD_MODIFIERS

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.12';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Devel/TypeTiny/Perl56Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL56COMPAT';
  package Devel::TypeTiny::Perl56Compat;use 5.006;use strict;use warnings;our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.034';use B ();unless (exists&B::perlstring){my$d;*B::perlstring=sub {no warnings 'uninitialized';require Data::Dumper;$d ||='Data::Dumper'->new([])->Indent(0)->Purity(0)->Pad('')->Useqq(1)->Terse(1)->Freezer('')->Toaster('');my$perlstring=$d->Values([''.shift])->Dump;($perlstring =~ /^"/)? $perlstring : qq["$perlstring"]}}push@B::EXPORT_OK,'perlstring';5.6;
DEVEL_TYPETINY_PERL56COMPAT

$fatpacked{"Devel/TypeTiny/Perl58Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL58COMPAT';
  package Devel::TypeTiny::Perl58Compat;use 5.006;use strict;use warnings;our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.034';eval 'require re';unless (exists&re::is_regexp){require B;*re::is_regexp=sub {eval {B::svref_2object($_[0])->MAGIC->TYPE eq 'r'}}}5.6;
DEVEL_TYPETINY_PERL58COMPAT

$fatpacked{"Error/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY';
  package Error::TypeTiny;use 5.006001;use strict;use warnings;BEGIN {$Error::TypeTiny::AUTHORITY='cpan:TOBYINK';$Error::TypeTiny::VERSION='0.034'}use overload q[""]=>sub {$_[0]->to_string},q[bool]=>sub {1},fallback=>1,;our%CarpInternal;$CarpInternal{$_}++ for qw(Eval::TypeTiny Eval::TypeTiny::Sandbox Exporter::Tiny Test::TypeTiny Type::Coercion Type::Coercion::Union Error::TypeTiny Type::Library Type::Params Type::Registry Types::Standard Types::Standard::_Stringable Types::TypeTiny Type::Tiny Type::Tiny::Class Type::Tiny::Duck Type::Tiny::Enum Type::Tiny::Intersection Type::Tiny::Role Type::Tiny::Union Type::Utils);sub new {my$class=shift;my%params=(@_==1)? %{$_[0]}: @_;return bless \%params,$class}sub throw {my$class=shift;my ($level,@caller,%ctxt)=0;while (defined scalar caller($level)and $CarpInternal{scalar caller($level)}){$level++};if (((caller($level - 1))[1]||"")=~ /^parameter validation for '(.+?)'$/){my ($pkg,$func)=($1 =~ m{^(.+)::(\w+)$});$level++ if caller($level)eq ($pkg||"")}@ctxt{qw/package file line/}=caller($level);my$stack=undef;if (our$StackTrace){require Devel::StackTrace;$stack="Devel::StackTrace"->new(ignore_package=>[keys%CarpInternal ],)}die(our$LastError=$class->new(context=>\%ctxt,stack_trace=>$stack,@_,))}sub message {$_[0]{message}||=$_[0]->_build_message};sub context {$_[0]{context}};sub stack_trace {$_[0]{stack_trace}};sub to_string {my$e=shift;my$c=$e->context;my$m=$e->message;$m =~ /\n\z/s ? $m : $c ? sprintf("%s at %s line %s.\n",$m,$c->{file}||'file?',$c->{line}||'NaN'): sprintf("%s\n",$m)}sub _build_message {return 'An exception has occurred'}sub croak {my ($fmt,@args)=@_;@_=(__PACKAGE__,message=>sprintf($fmt,@args),);goto \&throw}1;
ERROR_TYPETINY

$fatpacked{"Error/TypeTiny/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_ASSERTION';
  package Error::TypeTiny::Assertion;use 5.006001;use strict;use warnings;BEGIN {if ($] < 5.008){require Devel::TypeTiny::Perl56Compat}}BEGIN {$Error::TypeTiny::Assertion::AUTHORITY='cpan:TOBYINK';$Error::TypeTiny::Assertion::VERSION='0.034'}require Error::TypeTiny;our@ISA='Error::TypeTiny';sub type {$_[0]{type}};sub value {$_[0]{value}};sub varname {$_[0]{varname}||='$_'};sub attribute_step {$_[0]{attribute_step}};sub attribute_name {$_[0]{attribute_name}};sub has_type {defined $_[0]{type}};sub has_attribute_step {exists $_[0]{attribute_step}};sub has_attribute_name {exists $_[0]{attribute_name}};sub new {my$class=shift;my$self=$class->SUPER::new(@_);if (ref$Method::Generate::Accessor::CurrentAttribute){require B;my%d=%{$Method::Generate::Accessor::CurrentAttribute};$self->{attribute_name}=$d{name}if defined$d{name};$self->{attribute_step}=$d{step}if defined$d{step};if (defined$d{init_arg}){$self->{varname}=sprintf('$args->{%s}',B::perlstring($d{init_arg}))}elsif (defined$d{name}){$self->{varname}=sprintf('$self->{%s}',B::perlstring($d{name}))}}return$self}sub message {my$e=shift;$e->varname eq '$_' ? $e->SUPER::message : sprintf('%s (in %s)',$e->SUPER::message,$e->varname)}sub _build_message {my$e=shift;$e->has_type ? sprintf('%s did not pass type constraint "%s"',Type::Tiny::_dd($e->value),$e->type): sprintf('%s did not pass type constraint',Type::Tiny::_dd($e->value))}*to_string=sub {my$e=shift;my$msg=$e->message;my$c=$e->context;$msg .= sprintf(" at %s line %s",$c->{file}||'file?',$c->{line}||'NaN')if$c;my$explain=$e->explain;return$msg unless @{$explain || []};$msg .= "\n";for my$line (@$explain){$msg .= "    $line\n"}return$msg}if $] >= 5.008;sub explain {my$e=shift;return undef unless$e->has_type;$e->type->validate_explain($e->value,$e->varname)}1;
ERROR_TYPETINY_ASSERTION

$fatpacked{"Error/TypeTiny/Compilation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_COMPILATION';
  package Error::TypeTiny::Compilation;use 5.006001;use strict;use warnings;BEGIN {$Error::TypeTiny::Compilation::AUTHORITY='cpan:TOBYINK';$Error::TypeTiny::Compilation::VERSION='0.034'}require Error::TypeTiny;our@ISA='Error::TypeTiny';sub code {$_[0]{code}};sub environment {$_[0]{environment}||={}};sub errstr {$_[0]{errstr}};sub _build_message {my$self=shift;sprintf("Failed to compile source because: %s",$self->errstr)}1;
ERROR_TYPETINY_COMPILATION

$fatpacked{"Error/TypeTiny/WrongNumberOfParameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS';
  package Error::TypeTiny::WrongNumberOfParameters;use 5.006001;use strict;use warnings;BEGIN {$Error::TypeTiny::WrongNumberOfParameters::AUTHORITY='cpan:TOBYINK';$Error::TypeTiny::WrongNumberOfParameters::VERSION='0.034'}require Error::TypeTiny;our@ISA='Error::TypeTiny';sub minimum {$_[0]{minimum}};sub maximum {$_[0]{maximum}};sub got {$_[0]{got}};sub has_minimum {exists $_[0]{minimum}};sub has_maximum {exists $_[0]{maximum}};sub _build_message {my$e=shift;if ($e->has_minimum and $e->has_maximum and $e->minimum==$e->maximum){return sprintf("Wrong number of parameters; got %d; expected %d",$e->got,$e->minimum,)}elsif ($e->has_minimum and $e->has_maximum and $e->minimum < $e->maximum){return sprintf("Wrong number of parameters; got %d; expected %d to %d",$e->got,$e->minimum,$e->maximum,)}elsif ($e->has_minimum){return sprintf("Wrong number of parameters; got %d; expected at least %d",$e->got,$e->minimum,)}else {return sprintf("Wrong number of parameters; got %d",$e->got,)}}1;
ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS

$fatpacked{"Eval/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_TYPETINY';
  package Eval::TypeTiny;use strict;BEGIN {*HAS_LEXICAL_SUBS=($] >= 5.018)? sub(){!!1}: sub(){!!0}};{my$hlv;sub HAS_LEXICAL_VARS () {$hlv=!!eval {require Devel::LexAlias}unless defined$hlv;return$hlv}}sub _clean_eval {local $@;local$SIG{__DIE__};my$r=eval $_[0];my$e=$@;return ($r,$e)}our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.034';our@EXPORT=qw(eval_closure);our@EXPORT_OK=qw(HAS_LEXICAL_SUBS HAS_LEXICAL_VARS);sub import {no warnings "redefine";our@ISA=qw(Exporter::Tiny);require Exporter::Tiny;my$next=\&Exporter::Tiny::import;*import=$next;my$class=shift;my$opts={ref($_[0])? %{+shift}: ()};$opts->{into}||=scalar(caller);return$class->$next($opts,@_)}use warnings;sub eval_closure {my (%args)=@_;my$src=ref$args{source}eq "ARRAY" ? join("\n",@{$args{source}}): $args{source};$args{alias}=0 unless defined$args{alias};$args{line}=1 unless defined$args{line};$args{description}=~ s/[^\w .:-\[\]\(\)\{\}\']//g if defined$args{description};$src=qq{#line $args{line} "$args{description}"\n$src} if defined$args{description}&&!($^P & 0x10);$args{environment}||={};my$sandpkg='Eval::TypeTiny::Sandbox';my$alias=exists($args{alias})? $args{alias}: 0;my@keys=sort keys %{$args{environment}};my$i=0;my$source=join "\n"=>("package $sandpkg;","sub {",map(_make_lexical_assignment($_,$i++,$alias),@keys),$src,"}",);_manufacture_ties()if$alias &&!HAS_LEXICAL_VARS;my ($compiler,$e)=_clean_eval($source);if ($e){chomp$e;require Error::TypeTiny::Compilation;"Error::TypeTiny::Compilation"->throw(code=>(ref$args{source}eq "ARRAY" ? join("\n",@{$args{source}}): $args{source}),errstr=>$e,environment=>$args{environment},)}my$code=$compiler->(@{$args{environment}}{@keys});undef($compiler);if ($alias && HAS_LEXICAL_VARS){Devel::LexAlias::lexalias($code,$_,$args{environment}{$_})for grep!/^\&/,@keys}return$code}my$tmp;sub _make_lexical_assignment {my ($key,$index,$alias)=@_;my$name=substr($key,1);if (HAS_LEXICAL_SUBS and $key =~ /^\&/){$tmp++;my$tmpname='$__LEXICAL_SUB__'.$tmp;return "no warnings 'experimental::lexical_subs';"."use feature 'lexical_subs';"."my $tmpname = \$_[$index];"."my sub $name { goto $tmpname };"}if (!$alias){my$sigil=substr($key,0,1);return "my $key = $sigil\{ \$_[$index] };"}elsif (HAS_LEXICAL_VARS){return "my $key;"}else {my$tieclass={'@'=>'Eval::TypeTiny::_TieArray','%'=>'Eval::TypeTiny::_TieHash','$'=>'Eval::TypeTiny::_TieScalar',}->{substr($key,0,1)};return sprintf('tie(my(%s), "%s", $_[%d]);',$key,$tieclass,$index,)}}{my$tie;sub _manufacture_ties {$tie ||=eval <<'FALLBACK'}}1;
  no warnings qw(void once uninitialized numeric);
  
  {
  	package #
  		Eval::TypeTiny::_TieArray;
  	require Tie::Array;
  	our @ISA = qw( Tie::StdArray );
  	sub TIEARRAY {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(@$self) and return tied(@$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(@$self) and tied(@$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied @{$_[0]} },
  		q[""]    => sub { '' . tied @{$_[0]} },
  		q[0+]    => sub { 0  + tied @{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieHash;
  	require Tie::Hash;
  	our @ISA = qw( Tie::StdHash );
  	sub TIEHASH {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(%$self) and return tied(%$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(%$self) and tied(%$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied %{$_[0]} },
  		q[""]    => sub { '' . tied %{$_[0]} },
  		q[0+]    => sub { 0  + tied %{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieScalar;
  	require Tie::Scalar;
  	our @ISA = qw( Tie::StdScalar );
  	sub TIESCALAR {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied($$self) and return tied($$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied($$self) and tied($$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied ${$_[0]} },
  		q[""]    => sub { '' . tied ${$_[0]} },
  		q[0+]    => sub { 0  + tied ${$_[0]} },
  		fallback => 1,
  	;
  }
  
  1;
  FALLBACK
EVAL_TYPETINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;use 5.006001;use strict;use warnings;no warnings qw(void once uninitialized numeric redefine);our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.030';our@EXPORT_OK=qw<mkopt mkopt_hash _croak>;sub _croak ($;@) {require Carp;my$fmt=shift;@_=sprintf($fmt,@_);goto \&Carp::croak}sub import {my$class=shift;my$global_opts=+{@_ && ref($_[0])eq q(HASH) ? %{+shift}: ()};my@args=do {no strict qw(refs);@_ ? @_ : @{"$class\::EXPORT"}};my$opts=mkopt(\@args);$global_opts->{into}=caller unless exists$global_opts->{into};my@want;while (@$opts){my$opt=shift @{$opts};my ($name,$value)=@$opt;$name =~ /^[:-](.+)$/ ? push(@$opts,$class->_exporter_expand_tag($1,$value,$global_opts)): push(@want,$opt)}$class->_exporter_validate_opts($global_opts);my$permitted=$class->_exporter_permitted_regexp($global_opts);for my$wanted (@want){my%symbols=$class->_exporter_expand_sub(@$wanted,$global_opts,$permitted);$class->_exporter_install_sub($_,$wanted->[1],$global_opts,$symbols{$_})for keys%symbols}}sub _exporter_validate_opts {1}sub _exporter_expand_tag {no strict qw(refs);my$class=shift;my ($name,$value,$globals)=@_;my$tags=\%{"$class\::EXPORT_TAGS"};return map [$_=>$value],$tags->{$name}->($class,@_)if ref($tags->{$name})eq q(CODE);return map [$_=>$value],@{$tags->{$name}}if exists$tags->{$name};return map [$_=>$value],@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"}if$name eq 'all';return map [$_=>$value],@{"$class\::EXPORT"}if$name eq 'default';$globals->{$name}=$value || 1;return}sub _exporter_permitted_regexp {no strict qw(refs);my$class=shift;my$re=join "|",map quotemeta,sort {length($b)<=> length($a)or $a cmp $b}@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"};qr{^(?:$re)$}ms}sub _exporter_expand_sub {my$class=shift;my ($name,$value,$globals,$permitted)=@_;$permitted ||=$class->_exporter_permitted_regexp($globals);no strict qw(refs);if ($name =~ $permitted){my$generator=$class->can("_generate_$name");return$name=>$class->$generator($name,$value,$globals)if$generator;my$sub=$class->can($name);return$name=>$sub if$sub}$class->_exporter_fail(@_)}sub _exporter_fail {my$class=shift;my ($name,$value,$globals)=@_;_croak("Could not find sub '$name' to export in package '$class'")}sub _exporter_install_sub {my$class=shift;my ($name,$value,$globals,$sym)=@_;my$into=$globals->{into};my$installer=$globals->{installer}|| $globals->{exporter};$name=$value->{-as}|| $name;unless (ref($name)eq q(SCALAR)){my ($prefix)=grep defined,$value->{-prefix},$globals->{prefix},q();my ($suffix)=grep defined,$value->{-suffix},$globals->{suffix},q();$name="$prefix$name$suffix"}return$installer->($globals,[$name,$sym])if$installer;return ($$name=$sym)if ref($name)eq q(SCALAR);return ($into->{$name}=$sym)if ref($into)eq q(HASH);require B;for (grep ref,$into->can($name)){my$stash=B::svref_2object($_)->STASH;next unless$stash->can("NAME");$stash->NAME eq $into and _croak("Refusing to overwrite local sub '$name' with export from $class")}no strict qw(refs);*{"$into\::$name"}=$sym}sub mkopt {my$in=shift or return [];my@out;$in=[map(($_=>ref($in->{$_})? $in->{$_}: ()),sort keys %$in)]if ref($in)eq q(HASH);for (my$i=0;$i < @$in;$i++){my$k=$in->[$i];my$v;($i==$#$in)? ($v=undef): !defined($in->[$i+1])? (++$i,($v=undef)): !ref($in->[$i+1])? ($v=undef): ($v=$in->[++$i]);push@out,[$k=>$v ]}\@out}sub mkopt_hash {my$in=shift or return;my%out=map +($_->[0]=>$_->[1]),@{mkopt($in)};\%out}1;
EXPORTER_TINY

$fatpacked{"Exporter/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TYPETINY';
  package Exporter::TypeTiny;require Exporter::Tiny;our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.034';our@ISA='Exporter::Tiny';our@EXPORT_OK=qw|mkopt mkopt_hash _croak|;*import=\&Exporter::Tiny::import;*mkopt=\&Exporter::Tiny::mkopt;*mkopt_hash=\&Exporter::Tiny::mkopt_hash;*_croak=\&Exporter::Tiny::_croak;1;
EXPORTER_TYPETINY

$fatpacked{"File/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_TEMP';
  package File::Temp;our$VERSION='0.2304';use 5.006;use strict;use Carp;use File::Spec 0.8;use Cwd ();use File::Path 2.06 qw/rmtree/;use Fcntl 1.03;use IO::Seekable;use Errno;use Scalar::Util 'refaddr';require VMS::Stdio if $^O eq 'VMS';eval {require Carp::Heavy};require Symbol if $] < 5.006;use parent 0.221 qw/IO::Handle IO::Seekable/;use overload '""'=>"STRINGIFY",'0+'=>"NUMIFY",fallback=>1;use vars qw(@EXPORT_OK %EXPORT_TAGS $DEBUG $KEEP_ALL);$DEBUG=0;$KEEP_ALL=0;use Exporter 5.57 'import';@EXPORT_OK=qw{tempfile tempdir tmpnam tmpfile mktemp mkstemp mkstemps mkdtemp unlink0 cleanup SEEK_SET SEEK_CUR SEEK_END};%EXPORT_TAGS=('POSIX'=>[qw/tmpnam tmpfile/],'mktemp'=>[qw/mktemp mkstemp mkstemps mkdtemp/],'seekable'=>[qw/SEEK_SET SEEK_CUR SEEK_END/],);Exporter::export_tags('POSIX','mktemp','seekable');my@CHARS=(qw/A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 _/);use constant MAX_TRIES=>1000;use constant MINX=>4;use constant TEMPXXX=>'X' x 10;use constant STANDARD=>0;use constant MEDIUM=>1;use constant HIGH=>2;my$OPENFLAGS=O_CREAT | O_EXCL | O_RDWR;my$LOCKFLAG;unless ($^O eq 'MacOS'){for my$oflag (qw/NOFOLLOW BINARY LARGEFILE NOINHERIT/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);no strict 'refs';$OPENFLAGS |=$bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}$LOCKFLAG=eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};&Fcntl::O_EXLOCK()}}my$OPENTEMPFLAGS=$OPENFLAGS;unless ($^O eq 'MacOS'){for my$oflag (qw/TEMPORARY/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);local($@);no strict 'refs';$OPENTEMPFLAGS |=$bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}}my%FILES_CREATED_BY_OBJECT;sub _gettemp {croak 'Usage: ($fh, $name) = _gettemp($template, OPTIONS);' unless scalar(@_)>= 1;my$tempErrStr;my%options=("open"=>0,"mkdir"=>0,"suffixlen"=>0,"unlink_on_close"=>0,"use_exlock"=>1,"ErrStr"=>\$tempErrStr,);my$template=shift;if (ref($template)){carp "File::Temp::_gettemp: template must not be a reference";return ()}if (scalar(@_)% 2!=0){carp "File::Temp::_gettemp: Must have even number of options";return ()}%options=(%options,@_)if @_;${$options{ErrStr}}=undef;if ($options{"open"}&& $options{"mkdir"}){${$options{ErrStr}}="doopen and domkdir can not both be true\n";return ()}my$start=length($template)- 1 - $options{"suffixlen"};if (substr($template,$start - MINX + 1,MINX)ne 'X' x MINX){${$options{ErrStr}}="The template must end with at least ".MINX ." 'X' characters\n";return ()}my$path=_replace_XX($template,$options{"suffixlen"});my ($volume,$directories,$file);my$parent;if ($options{"mkdir"}){($volume,$directories,$file)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);if ($#dirs==0){$parent=File::Spec->curdir}else {if ($^O eq 'VMS'){$parent=File::Spec->catdir($volume,@dirs[0..$#dirs-1]);$parent='sys$disk:[]' if$parent eq ''}else {$parent=File::Spec->catdir(@dirs[0..$#dirs-1]);$parent=File::Spec->catpath($volume,$parent,'')}}}else {($volume,$directories,$file)=File::Spec->splitpath($path);$parent=File::Spec->catpath($volume,$directories,'');$parent=File::Spec->curdir unless$directories ne ''}unless (-e $parent){${$options{ErrStr}}="Parent directory ($parent) does not exist";return ()}unless (-d $parent){${$options{ErrStr}}="Parent directory ($parent) is not a directory";return ()}if (File::Temp->safe_level==MEDIUM){my$safeerr;unless (_is_safe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}elsif (File::Temp->safe_level==HIGH){my$safeerr;unless (_is_verysafe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}for (my$i=0;$i < MAX_TRIES;$i++){if ($options{"open"}){my$fh;if ($] < 5.006){$fh=&Symbol::gensym}local $^F=2;my$open_success=undef;if ($^O eq 'VMS' and $options{"unlink_on_close"}&&!$KEEP_ALL){$fh=VMS::Stdio::vmssysopen($path,$OPENFLAGS,0600,'fop=dlt');$open_success=$fh}else {my$flags=(($options{"unlink_on_close"}&&!$KEEP_ALL)? $OPENTEMPFLAGS : $OPENFLAGS);$flags |=$LOCKFLAG if (defined$LOCKFLAG && $options{use_exlock});$open_success=sysopen($fh,$path,$flags,0600)}if ($open_success){chmod(0600,$path);return ($fh,$path)}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create temp file $path: $!";return ()}}}elsif ($options{"mkdir"}){if (mkdir($path,0700)){chmod(0700,$path);return undef,$path}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create directory $path: $!";return ()}}}else {return (undef,$path)unless -e $path}my$original=$path;my$counter=0;my$MAX_GUESS=50;do {$path=_replace_XX($template,$options{"suffixlen"});$counter++}until ($path ne $original || $counter > $MAX_GUESS);if ($counter > $MAX_GUESS){${$options{ErrStr}}="Tried to get a new temp name different to the previous value $MAX_GUESS times.\nSomething wrong with template?? ($template)";return ()}}${$options{ErrStr}}="Have exceeded the maximum number of attempts (" .MAX_TRIES .") to open temp file/dir";return ()}sub _replace_XX {croak 'Usage: _replace_XX($template, $ignore)' unless scalar(@_)==2;my ($path,$ignore)=@_;my$end=($] >= 5.006 ? "\\z" : "\\Z");if ($ignore){substr($path,0,- $ignore)=~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}else {$path =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}return$path}sub _force_writable {my$file=shift;chmod 0600,$file}sub _is_safe {my$path=shift;my$err_ref=shift;my@info=stat($path);unless (scalar(@info)){$$err_ref="stat(path) returned no values";return 0};return 1 if $^O eq 'VMS';if ($info[4]> File::Temp->top_system_uid()&& $info[4]!=$>){Carp::cluck(sprintf "uid=$info[4] topuid=%s euid=$> path='$path'",File::Temp->top_system_uid());$$err_ref="Directory owned neither by root nor the current user" if ref($err_ref);return 0}if (($info[2]& &Fcntl::S_IWGRP)|| ($info[2]& &Fcntl::S_IWOTH)){unless (-d $path){$$err_ref="Path ($path) is not a directory" if ref($err_ref);return 0}unless (-k $path){$$err_ref="Sticky bit not set on $path when dir is group|world writable" if ref($err_ref);return 0}}return 1}sub _is_verysafe {require POSIX;my$path=shift;print "_is_verysafe testing $path\n" if$DEBUG;return 1 if $^O eq 'VMS';my$err_ref=shift;local($@);my$chown_restricted;$chown_restricted=&POSIX::_PC_CHOWN_RESTRICTED()if eval {&POSIX::_PC_CHOWN_RESTRICTED();1};if (defined$chown_restricted){return _is_safe($path,$err_ref)if POSIX::sysconf($chown_restricted)}unless (File::Spec->file_name_is_absolute($path)){$path=File::Spec->rel2abs($path)}my ($volume,$directories,undef)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);for my$pos (0.. $#dirs){my$dir=File::Spec->catpath($volume,File::Spec->catdir(@dirs[0.. $#dirs - $pos]),'');print "TESTING DIR $dir\n" if$DEBUG;return 0 unless _is_safe($dir,$err_ref)}return 1}sub _can_unlink_opened_file {if (grep {$^O eq $_}qw/MSWin32 os2 VMS dos MacOS haiku/){return 0}else {return 1}}sub _can_do_level {my$level=shift;return 1 if$level==STANDARD;if ($^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'cygwin' || $^O eq 'dos' || $^O eq 'MacOS' || $^O eq 'mpeix'){return 0}else {return 1}}{my (%files_to_unlink,%dirs_to_unlink);END {local($.,$@,$!,$^E,$?);cleanup(at_exit=>1)}sub cleanup {my%h=@_;my$at_exit=delete$h{at_exit};$at_exit=0 if not defined$at_exit;{my@k=sort keys%h;die "unrecognized parameters: @k" if@k}if (!$KEEP_ALL){my@files=(exists$files_to_unlink{$$}? @{$files_to_unlink{$$}}: ());for my$file (@files){close($file->[0]);if (-f $file->[1]){_force_writable($file->[1]);unlink$file->[1]or warn "Error removing ".$file->[1]}}my@dirs=(exists$dirs_to_unlink{$$}? @{$dirs_to_unlink{$$}}: ());my ($cwd,$cwd_to_remove);for my$dir (@dirs){if (-d $dir){if ($at_exit){$cwd=Cwd::abs_path(File::Spec->curdir)if not defined$cwd;my$abs=Cwd::abs_path($dir);if ($abs eq $cwd){$cwd_to_remove=$dir;next}}eval {rmtree($dir,$DEBUG,0)};warn $@ if ($@ && $^W)}}if (defined$cwd_to_remove){chdir$cwd_to_remove or die "cannot chdir to $cwd_to_remove: $!";my$updir=File::Spec->updir;chdir$updir or die "cannot chdir to $updir: $!";eval {rmtree($cwd_to_remove,$DEBUG,0)};warn $@ if ($@ && $^W)}@{$files_to_unlink{$$}}=()if exists$files_to_unlink{$$};@{$dirs_to_unlink{$$}}=()if exists$dirs_to_unlink{$$}}}sub _deferred_unlink {croak 'Usage:  _deferred_unlink($fh, $fname, $isdir)' unless scalar(@_)==3;my ($fh,$fname,$isdir)=@_;warn "Setting up deferred removal of $fname\n" if$DEBUG;$fname=Cwd::abs_path($fname);($fname)=$fname =~ /^(.*)$/;if ($isdir){if (-d $fname){$fname=VMS::Filespec::vmspath($fname)if $^O eq 'VMS';$dirs_to_unlink{$$}=[]unless exists$dirs_to_unlink{$$};push (@{$dirs_to_unlink{$$}},$fname)}else {carp "Request to remove directory $fname could not be completed since it does not exist!\n" if $^W}}else {if (-f $fname){$files_to_unlink{$$}=[]unless exists$files_to_unlink{$$};push(@{$files_to_unlink{$$}},[$fh,$fname])}else {carp "Request to remove file $fname could not be completed since it is not there!\n" if $^W}}}}sub _parse_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? $args{TEMPLATE}: $leading_template ? $leading_template : ());delete$args{TEMPLATE};return(\@template,\%args)}sub new {my$proto=shift;my$class=ref($proto)|| $proto;my ($maybe_template,$args)=_parse_args(@_);my$unlink=(exists$args->{UNLINK}? $args->{UNLINK}: 1);delete$args->{UNLINK};delete$args->{OPEN};my ($fh,$path)=tempfile(@$maybe_template,%$args);print "Tmp: $fh - $path\n" if$DEBUG;${*$fh}=$path;$FILES_CREATED_BY_OBJECT{$$}{$path}=1;%{*$fh}=%$args;bless$fh,$class;$fh->unlink_on_destroy($unlink);return$fh}sub newdir {my$self=shift;my ($maybe_template,$args)=_parse_args(@_);my$cleanup=(exists$args->{CLEANUP}? $args->{CLEANUP}: 1);delete$args->{CLEANUP};my$tempdir=tempdir(@$maybe_template,%$args);my$real_dir=Cwd::abs_path($tempdir);($real_dir)=$real_dir =~ /^(.*)$/;return bless {DIRNAME=>$tempdir,REALNAME=>$real_dir,CLEANUP=>$cleanup,LAUNCHPID=>$$,},"File::Temp::Dir"}sub filename {my$self=shift;return ${*$self}}sub STRINGIFY {my$self=shift;return$self->filename}sub NUMIFY {return refaddr($_[0])}sub unlink_on_destroy {my$self=shift;if (@_){${*$self}{UNLINK}=shift}return ${*$self}{UNLINK}}sub DESTROY {local($.,$@,$!,$^E,$?);my$self=shift;my$file=$self->filename;my$was_created_by_proc;if (exists$FILES_CREATED_BY_OBJECT{$$}{$file}){$was_created_by_proc=1;delete$FILES_CREATED_BY_OBJECT{$$}{$file}}if (${*$self}{UNLINK}&&!$KEEP_ALL){print "# --------->   Unlinking $self\n" if$DEBUG;return unless$was_created_by_proc;_force_writable($file);unlink1($self,$file)or unlink($file)}}sub tempfile {if (@_ && $_[0]eq 'File::Temp'){croak "'tempfile' can't be called as a method"}my%options=("DIR"=>undef,"SUFFIX"=>'',"UNLINK"=>0,"OPEN"=>1,"TMPDIR"=>0,"EXLOCK"=>1,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (!$options{"OPEN"}){warn "tempfile(): temporary filename requested but not opened.\nPossibly unsafe, consider using tempfile() with OPEN set to true\n" if $^W}if ($options{"DIR"}and $^O eq 'VMS'){$options{"DIR"}=VMS::Filespec::vmspath($options{"DIR"})}if (defined$template){if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catfile(File::Spec->tmpdir,$template)}}else {if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catfile(File::Spec->tmpdir,TEMPXXX)}}$template .= $options{"SUFFIX"};my$unlink_on_close=(wantarray ? 0 : 1);my ($fh,$path,$errstr);croak "Error in tempfile() using template $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>$options{'OPEN'},"mkdir"=>0,"unlink_on_close"=>$unlink_on_close,"suffixlen"=>length($options{'SUFFIX'}),"ErrStr"=>\$errstr,"use_exlock"=>$options{EXLOCK},));_deferred_unlink($fh,$path,0)if$options{"UNLINK"};if (wantarray()){if ($options{'OPEN'}){return ($fh,$path)}else {return (undef,$path)}}else {unlink0($fh,$path)or croak "Error unlinking file $path using unlink0";return$fh}}sub tempdir {if (@_ && $_[0]eq 'File::Temp'){croak "'tempdir' can't be called as a method"}my%options=("CLEANUP"=>0,"DIR"=>'',"TMPDIR"=>0,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (defined$template){if ($options{'TMPDIR'}|| $options{'DIR'}){$template=VMS::Filespec::vmspath($template)if $^O eq 'VMS';my ($volume,$directories,undef)=File::Spec->splitpath($template,1);$template=(File::Spec->splitdir($directories))[-1];if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catdir(File::Spec->tmpdir,$template)}}}else {if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catdir(File::Spec->tmpdir,TEMPXXX)}}my$tempdir;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my$errstr;croak "Error in tempdir() using $template: $errstr" unless ((undef,$tempdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));if ($options{'CLEANUP'}&& -d $tempdir){_deferred_unlink(undef,$tempdir,1)}return$tempdir}sub mkstemp {croak "Usage: mkstemp(template)" if scalar(@_)!=1;my$template=shift;my ($fh,$path,$errstr);croak "Error in mkstemp using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkstemps {croak "Usage: mkstemps(template, suffix)" if scalar(@_)!=2;my$template=shift;my$suffix=shift;$template .= $suffix;my ($fh,$path,$errstr);croak "Error in mkstemps using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>length($suffix),"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkdtemp {croak "Usage: mkdtemp(template)" if scalar(@_)!=1;my$template=shift;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my ($junk,$tmpdir,$errstr);croak "Error creating temp directory from template $template\: $errstr" unless (($junk,$tmpdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));return$tmpdir}sub mktemp {croak "Usage: mktemp(template)" if scalar(@_)!=1;my$template=shift;my ($tmpname,$junk,$errstr);croak "Error getting name to temp file from template $template: $errstr" unless (($junk,$tmpname)=_gettemp($template,"open"=>0,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));return$tmpname}sub tmpnam {my$tmpdir=File::Spec->tmpdir;croak "Error temporary directory is not writable" if$tmpdir eq '';my$template=File::Spec->catfile($tmpdir,TEMPXXX);if (wantarray()){return mkstemp($template)}else {return mktemp($template)}}sub tmpfile {my ($fh,$file)=tmpnam();unlink0($fh,$file)or return undef;return$fh}sub tempnam {croak 'Usage tempnam($dir, $prefix)' unless scalar(@_)==2;my ($dir,$prefix)=@_;$prefix .= 'XXXXXXXX';my$template=File::Spec->catfile($dir,$prefix);return mktemp($template)}sub unlink0 {croak 'Usage: unlink0(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;if (_can_unlink_opened_file()){return 1 if$KEEP_ALL;croak "unlink0: $path has become a directory!" if -d $path;unlink($path)or return 0;my@fh=stat$fh;print "Link count = $fh[3] \n" if$DEBUG;return 1 if$fh[3]==0 || $^O eq 'cygwin'}_deferred_unlink($fh,$path,0);return 1}sub cmpstat {croak 'Usage: cmpstat(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;warn "Comparing stat\n" if$DEBUG;my@fh;{local ($^W)=0;@fh=stat$fh}return unless@fh;if ($fh[3]> 1 && $^W){carp "unlink0: fstat found too many links; SB=@fh" if $^W}my@path=stat$path;unless (@path){carp "unlink0: $path is gone already" if $^W;return}unless (-f $path){confess "panic: $path is no longer a file: SB=@fh"}my@okstat=(0..$#fh);if ($^O eq 'MSWin32'){@okstat=(1,2,3,4,5,7,8,9,10)}elsif ($^O eq 'os2'){@okstat=(0,2..$#fh)}elsif ($^O eq 'VMS'){@okstat=(0,1)}elsif ($^O eq 'dos'){@okstat=(0,2..7,11..$#fh)}elsif ($^O eq 'mpeix'){@okstat=(0..4,8..10)}for (@okstat){print "Comparing: $_ : $fh[$_] and $path[$_]\n" if$DEBUG;unless ($fh[$_]eq $path[$_]){warn "Did not match $_ element of stat\n" if$DEBUG;return 0}}return 1}sub unlink1 {croak 'Usage: unlink1(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;close($fh)or return 0;_force_writable($path);return 1 if$KEEP_ALL;return unlink($path)}{my$LEVEL=STANDARD;sub safe_level {my$self=shift;if (@_){my$level=shift;if (($level!=STANDARD)&& ($level!=MEDIUM)&& ($level!=HIGH)){carp "safe_level: Specified level ($level) not STANDARD, MEDIUM or HIGH - ignoring\n" if $^W}else {if ($] < 5.006 && $level!=STANDARD){croak "Currently requires perl 5.006 or newer to do the safe checks"}$LEVEL=$level if _can_do_level($level)}}return$LEVEL}}{my$TopSystemUID=10;$TopSystemUID=197108 if $^O eq 'interix';sub top_system_uid {my$self=shift;if (@_){my$newuid=shift;croak "top_system_uid: UIDs should be numeric" unless$newuid =~ /^\d+$/s;$TopSystemUID=$newuid}return$TopSystemUID}}package File::Temp::Dir;use File::Path qw/rmtree/;use strict;use overload '""'=>"STRINGIFY",'0+'=>\&File::Temp::NUMIFY,fallback=>1;sub dirname {my$self=shift;return$self->{DIRNAME}}sub STRINGIFY {my$self=shift;return$self->dirname}sub unlink_on_destroy {my$self=shift;if (@_){$self->{CLEANUP}=shift}return$self->{CLEANUP}}sub DESTROY {my$self=shift;local($.,$@,$!,$^E,$?);if ($self->unlink_on_destroy && $$==$self->{LAUNCHPID}&&!$File::Temp::KEEP_ALL){if (-d $self->{REALNAME}){eval {rmtree($self->{REALNAME},$File::Temp::DEBUG,0)};warn $@ if ($@ && $^W)}}}1;
FILE_TEMP

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  package Getopt::Long;use 5.004;use strict;use vars qw($VERSION);$VERSION=2.42;use vars qw($VERSION_STRING);$VERSION_STRING="2.42";use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK);@ISA=qw(Exporter);sub GetOptions(@);sub GetOptionsFromArray(@);sub GetOptionsFromString(@);sub Configure(@);sub HelpMessage(@);sub VersionMessage(@);BEGIN {@EXPORT=qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);@EXPORT_OK=qw(&HelpMessage &VersionMessage &Configure &GetOptionsFromArray &GetOptionsFromString)}use vars@EXPORT,@EXPORT_OK;use vars qw($error $debug $major_version $minor_version);use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order $passthrough);use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);sub config(@);sub ConfigDefaults();sub ParseOptionSpec($$);sub OptCtl($);sub FindOption($$$$$);sub ValidValue ($$$$$);my$requested_version=0;sub ConfigDefaults() {if (defined$ENV{"POSIXLY_CORRECT"}){$genprefix="(--|-)";$autoabbrev=0;$bundling=0;$getopt_compat=0;$order=$REQUIRE_ORDER}else {$genprefix="(--|-|\\+)";$autoabbrev=1;$bundling=0;$getopt_compat=1;$order=$PERMUTE}$debug=0;$error=0;$ignorecase=1;$passthrough=0;$gnu_compat=0;$longprefix="(--)"}sub import {my$pkg=shift;my@syms=();my@config=();my$dest=\@syms;for (@_){if ($_ eq ':config'){$dest=\@config;next}push(@$dest,$_)}local$Exporter::ExportLevel=1;push(@syms,qw(&GetOptions))if@syms;$requested_version=0;$pkg->SUPER::import(@syms);Configure(@config)if@config}($REQUIRE_ORDER,$PERMUTE,$RETURN_IN_ORDER)=(0..2);($major_version,$minor_version)=$VERSION =~ /^(\d+)\.(\d+)/;ConfigDefaults();package Getopt::Long::Parser;my$default_config=do {Getopt::Long::Configure ()};sub new {my$that=shift;my$class=ref($that)|| $that;my%atts=@_;my$self={caller_pkg=>(caller)[0]};bless ($self,$class);if (defined$atts{config}){my$save=Getopt::Long::Configure ($default_config,@{$atts{config}});$self->{settings}=Getopt::Long::Configure ($save);delete ($atts{config})}else {$self->{settings}=$default_config}if (%atts){die(__PACKAGE__.": unhandled attributes: ".join(" ",sort(keys(%atts)))."\n")}$self}sub configure {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings},@_);$self->{settings}=Getopt::Long::Configure ($save)}sub getoptions {my ($self)=shift;return$self->getoptionsfromarray(\@ARGV,@_)}sub getoptionsfromarray {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings});my$ret=0;$Getopt::Long::caller=$self->{caller_pkg};eval {local ($SIG{__DIE__})='DEFAULT';$ret=Getopt::Long::GetOptionsFromArray (@_)};Getopt::Long::Configure ($save);die ($@)if $@;return$ret}package Getopt::Long;use constant CTL_TYPE=>0;use constant CTL_CNAME=>1;use constant CTL_DEFAULT=>2;use constant CTL_DEST=>3;use constant CTL_DEST_SCALAR=>0;use constant CTL_DEST_ARRAY=>1;use constant CTL_DEST_HASH=>2;use constant CTL_DEST_CODE=>3;use constant CTL_AMIN=>4;use constant CTL_AMAX=>5;use constant PAT_INT=>"[-+]?_*[0-9][0-9_]*";use constant PAT_XINT=>"(?:"."[-+]?_*[1-9][0-9_]*"."|"."0x_*[0-9a-f][0-9a-f_]*"."|"."0b_*[01][01_]*"."|"."0[0-7_]*".")";use constant PAT_FLOAT=>"[-+]?[0-9_]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";sub GetOptions(@) {unshift(@_,\@ARGV);goto&GetOptionsFromArray}sub GetOptionsFromString(@) {my ($string)=shift;require Text::ParseWords;my$args=[Text::ParseWords::shellwords($string)];$caller ||=(caller)[0];my$ret=GetOptionsFromArray($args,@_);return ($ret,$args)if wantarray;if (@$args){$ret=0;warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n")}$ret}sub GetOptionsFromArray(@) {my ($argv,@optionlist)=@_;my$argend='--';my%opctl=();my$pkg=$caller || (caller)[0];my@ret=();my%linkage;my$userlinkage;my$opt;my$prefix=$genprefix;$error='';if ($debug){local ($^W)=0;print STDERR ("Getopt::Long $Getopt::Long::VERSION ","called from package \"$pkg\".","\n  ","argv: (@$argv)","\n  ","autoabbrev=$autoabbrev,"."bundling=$bundling,","getopt_compat=$getopt_compat,","gnu_compat=$gnu_compat,","order=$order,","\n  ","ignorecase=$ignorecase,","requested_version=$requested_version,","passthrough=$passthrough,","genprefix=\"$genprefix\",","longprefix=\"$longprefix\".","\n")}$userlinkage=undef;if (@optionlist && ref($optionlist[0])and UNIVERSAL::isa($optionlist[0],'HASH')){$userlinkage=shift (@optionlist);print STDERR ("=> user linkage: $userlinkage\n")if$debug}if (@optionlist && $optionlist[0]=~ /^\W+$/ &&!($optionlist[0]eq '<>' && @optionlist > 0 && ref($optionlist[1]))){$prefix=shift (@optionlist);$prefix =~ s/(\W)/\\$1/g;$prefix="([" .$prefix ."])";print STDERR ("=> prefix=\"$prefix\"\n")if$debug}%opctl=();while (@optionlist){my$opt=shift (@optionlist);unless (defined($opt)){$error .= "Undefined argument in option spec\n";next}$opt=$+ if$opt =~ /^$prefix+(.*)$/s;if ($opt eq '<>'){if ((defined$userlinkage)&&!(@optionlist > 0 && ref($optionlist[0]))&& (exists$userlinkage->{$opt})&& ref($userlinkage->{$opt})){unshift (@optionlist,$userlinkage->{$opt})}unless (@optionlist > 0 && ref($optionlist[0])&& ref($optionlist[0])eq 'CODE'){$error .= "Option spec <> requires a reference to a subroutine\n";shift (@optionlist)if@optionlist && ref($optionlist[0]);next}$linkage{'<>'}=shift (@optionlist);next}my ($name,$orig)=ParseOptionSpec ($opt,\%opctl);unless (defined$name){$error .= $orig;shift (@optionlist)if@optionlist && ref($optionlist[0]);next}if (defined$userlinkage){unless (@optionlist > 0 && ref($optionlist[0])){if (exists$userlinkage->{$orig}&& ref($userlinkage->{$orig})){print STDERR ("=> found userlinkage for \"$orig\": ","$userlinkage->{$orig}\n")if$debug;unshift (@optionlist,$userlinkage->{$orig})}else {next}}}if (@optionlist > 0 && ref($optionlist[0])){print STDERR ("=> link \"$orig\" to $optionlist[0]\n")if$debug;my$rl=ref($linkage{$orig}=shift (@optionlist));if ($rl eq "ARRAY"){$opctl{$name}[CTL_DEST]=CTL_DEST_ARRAY}elsif ($rl eq "HASH"){$opctl{$name}[CTL_DEST]=CTL_DEST_HASH}elsif ($rl eq "SCALAR" || $rl eq "REF"){}elsif ($rl eq "CODE"){}else {$error .= "Invalid option linkage for \"$opt\"\n"}}else {my$ov=$orig;$ov =~ s/\W/_/g;if ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;")}elsif ($opctl{$name}[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;")}else {print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;")}}if ($opctl{$name}[CTL_TYPE]eq 'I' && ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY || $opctl{$name}[CTL_DEST]==CTL_DEST_HASH)){$error .= "Invalid option linkage for \"$opt\"\n"}}die ($error)if$error;$error=0;if (defined($auto_version)? $auto_version : ($requested_version >= 2.3203)){if (!defined($opctl{version})){$opctl{version}=['','version',0,CTL_DEST_CODE,undef];$linkage{version}=\&VersionMessage}$auto_version=1}if (defined($auto_help)? $auto_help : ($requested_version >= 2.3203)){if (!defined($opctl{help})&&!defined($opctl{'?'})){$opctl{help}=$opctl{'?'}=['','help',0,CTL_DEST_CODE,undef];$linkage{help}=\&HelpMessage}$auto_help=1}if ($debug){my ($arrow,$k,$v);$arrow="=> ";while (($k,$v)=each(%opctl)){print STDERR ($arrow,"\$opctl{$k} = $v ",OptCtl($v),"\n");$arrow="   "}}my$goon=1;while ($goon && @$argv > 0){$opt=shift (@$argv);print STDERR ("=> arg \"",$opt,"\"\n")if$debug;if (defined($opt)&& $opt eq $argend){push (@ret,$argend)if$passthrough;last}my$tryopt=$opt;my$found;my$key;my$arg;my$ctl;($found,$opt,$ctl,$arg,$key)=FindOption ($argv,$prefix,$argend,$opt,\%opctl);if ($found){next unless defined$opt;my$argcnt=0;while (defined$arg){print STDERR ("=> cname for \"$opt\" is ")if$debug;$opt=$ctl->[CTL_CNAME];print STDERR ("\"$ctl->[CTL_CNAME]\"\n")if$debug;if (defined$linkage{$opt}){print STDERR ("=> ref(\$L{$opt}) -> ",ref($linkage{$opt}),"\n")if$debug;if (ref($linkage{$opt})eq 'SCALAR' || ref($linkage{$opt})eq 'REF'){if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")if$debug;if (defined ${$linkage{$opt}}){${$linkage{$opt}}+= $arg}else {${$linkage{$opt}}=$arg}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to ARRAY\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}=[];print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to HASH\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}={};print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}else {print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")if$debug;${$linkage{$opt}}=$arg}}elsif (ref($linkage{$opt})eq 'ARRAY'){print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif (ref($linkage{$opt})eq 'HASH'){print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}elsif (ref($linkage{$opt})eq 'CODE'){print STDERR ("=> &L{$opt}(\"$opt\"",$ctl->[CTL_DEST]==CTL_DEST_HASH ? ", \"$key\"" : "",", \"$arg\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&{$linkage{$opt}}(Getopt::Long::CallBack->new (name=>$opt,ctl=>$ctl,opctl=>\%opctl,linkage=>\%linkage,prefix=>$prefix,),$ctl->[CTL_DEST]==CTL_DEST_HASH ? ($key): (),$arg)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("Invalid REF type \"",ref($linkage{$opt}),"\" in linkage\n");die("Getopt::Long -- internal error!\n")}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){if (defined$userlinkage->{$opt}){print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")if$debug;push (@{$userlinkage->{$opt}},$arg)}else {print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")if$debug;$userlinkage->{$opt}=[$arg]}}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){if (defined$userlinkage->{$opt}){print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")if$debug;$userlinkage->{$opt}->{$key}=$arg}else {print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")if$debug;$userlinkage->{$opt}={$key=>$arg}}}else {if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$L{$opt} += \"$arg\"\n")if$debug;if (defined$userlinkage->{$opt}){$userlinkage->{$opt}+= $arg}else {$userlinkage->{$opt}=$arg}}else {print STDERR ("=>\$L{$opt} = \"$arg\"\n")if$debug;$userlinkage->{$opt}=$arg}}$argcnt++;last if$argcnt >= $ctl->[CTL_AMAX]&& $ctl->[CTL_AMAX]!=-1;undef($arg);if ($argcnt < $ctl->[CTL_AMIN]){if (@$argv){if (ValidValue($ctl,$argv->[0],1,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}warn("Value \"$$argv[0]\" invalid for option $opt\n");$error++}else {warn("Insufficient arguments for option $opt\n");$error++}}if (@$argv && ValidValue($ctl,$argv->[0],0,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}}}elsif ($order==$PERMUTE){my$cb;if ((defined ($cb=$linkage{'<>'}))){print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&$cb($tryopt)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("=> saving \"$tryopt\" ","(not an option, may permute)\n")if$debug;push (@ret,$tryopt)}next}else {unshift (@$argv,$tryopt);return ($error==0)}}if (@ret && $order==$PERMUTE){print STDERR ("=> restoring \"",join('" "',@ret),"\"\n")if$debug;unshift (@$argv,@ret)}return ($error==0)}sub OptCtl ($) {my ($v)=@_;my@v=map {defined($_)? ($_): ("<undef>")}@$v;"[".join(",","\"$v[CTL_TYPE]\"","\"$v[CTL_CNAME]\"","\"$v[CTL_DEFAULT]\"",("\$","\@","\%","\&")[$v[CTL_DEST]|| 0],$v[CTL_AMIN]|| '',$v[CTL_AMAX]|| '',)."]"}sub ParseOptionSpec ($$) {my ($opt,$opctl)=@_;if ($opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x){return (undef,"Error in option spec: \"$opt\"\n")}my ($names,$spec)=($1,$2);$spec='' unless defined$spec;my$orig;my@names;if (defined$names){@names=split (/\|/,$names);$orig=$names[0]}else {@names=('');$orig=''}my$entry;if ($spec eq '' || $spec eq '+' || $spec eq '!'){$entry=[$spec,$orig,undef,CTL_DEST_SCALAR,0,0]}elsif ($spec =~ /^:(-?\d+|\+)([@%])?$/){my$def=$1;my$dest=$2;my$type=$def eq '+' ? 'I' : 'i';$dest ||='$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$entry=[$type,$orig,$def eq '+' ? undef : $def,$dest,0,1]}else {my ($mand,$type,$dest)=$spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;return (undef,"Cannot repeat while bundling: \"$opt\"\n")if$bundling && defined($4);my ($mi,$cm,$ma)=($5,$6,$7);return (undef,"{0} is useless in option spec: \"$opt\"\n")if defined($mi)&&!$mi &&!defined($ma)&&!defined($cm);$type='i' if$type eq 'n';$dest ||='$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$mi=$mand eq '=' ? 1 : 0 unless defined$mi;$mand=$mi ? '=' : ':';$ma=$mi ? $mi : 1 unless defined$ma || defined$cm;return (undef,"Max must be greater than zero in option spec: \"$opt\"\n")if defined($ma)&&!$ma;return (undef,"Max less than min in option spec: \"$opt\"\n")if defined($ma)&& $ma < $mi;$entry=[$type,$orig,undef,$dest,$mi,$ma||-1]}my$dups='';for (@names){$_=lc ($_)if$ignorecase > (($bundling && length($_)==1)? 1 : 0);if (exists$opctl->{$_}){$dups .= "Duplicate specification \"$opt\" for option \"$_\"\n"}if ($spec eq '!'){$opctl->{"no$_"}=$entry;$opctl->{"no-$_"}=$entry;$opctl->{$_}=[@$entry];$opctl->{$_}->[CTL_TYPE]=''}else {$opctl->{$_}=$entry}}if ($dups && $^W){for (split(/\n+/,$dups)){warn($_."\n")}}($names[0],$orig)}sub FindOption ($$$$$) {my ($argv,$prefix,$argend,$opt,$opctl)=@_;print STDERR ("=> find \"$opt\"\n")if$debug;return (0)unless defined($opt);return (0)unless$opt =~ /^($prefix)(.*)$/s;return (0)if$opt eq "-" &&!defined$opctl->{''};$opt=substr($opt,length($1));my$starter=$1;print STDERR ("=> split \"$starter\"+\"$opt\"\n")if$debug;my$optarg;my$rest;if (($starter=~/^$longprefix$/ || ($getopt_compat && ($bundling==0 || $bundling==2)))&& (my$oppos=index($opt,'=',1))> 0){my$optorg=$opt;$opt=substr($optorg,0,$oppos);$optarg=substr($optorg,$oppos + 1);print STDERR ("=> option \"",$opt,"\", optarg = \"$optarg\"\n")if$debug}my$tryopt=$opt;if ($bundling && $starter eq '-'){$tryopt=$ignorecase ? lc($opt): $opt;if ($bundling==2 && length($tryopt)> 1 && defined ($opctl->{$tryopt})){print STDERR ("=> $starter$tryopt overrides unbundling\n")if$debug}else {$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$rest=undef unless$rest ne ''}}elsif ($autoabbrev && $opt ne ""){my@names=sort(keys (%$opctl));$opt=lc ($opt)if$ignorecase;$tryopt=$opt;my$pat=quotemeta ($opt);my@hits=grep (/^$pat/,@names);print STDERR ("=> ",scalar(@hits)," hits (@hits) with \"$pat\" ","out of ",scalar(@names),"\n")if$debug;unless ((@hits <= 1)|| (grep ($_ eq $opt,@hits)==1)){my%hit;for (@hits){my$hit=$opctl->{$_}->[CTL_CNAME]if defined$opctl->{$_}->[CTL_CNAME];$hit="no" .$hit if$opctl->{$_}->[CTL_TYPE]eq '!';$hit{$hit}=1}if (keys(%hit)==2){if ($auto_version && exists($hit{version})){delete$hit{version}}elsif ($auto_help && exists($hit{help})){delete$hit{help}}}unless (keys(%hit)==1){return (0)if$passthrough;warn ("Option ",$opt," is ambiguous (",join(", ",@hits),")\n");$error++;return (1,undef)}@hits=keys(%hit)}if (@hits==1 && $hits[0]ne $opt){$tryopt=$hits[0];$tryopt=lc ($tryopt)if$ignorecase;print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")if$debug}}elsif ($ignorecase){$tryopt=lc ($opt)}my$ctl=$opctl->{$tryopt};unless (defined$ctl){return (0)if$passthrough;if ($bundling==1 && length($starter)==1){$opt=substr($opt,0,1);unshift (@$argv,$starter.$rest)if defined$rest}if ($opt eq ""){warn ("Missing option after ",$starter,"\n")}else {warn ("Unknown option: ",$opt,"\n")}$error++;return (1,undef)}$opt=$tryopt;print STDERR ("=> found ",OptCtl($ctl)," for \"",$opt,"\"\n")if$debug;my$type=$ctl->[CTL_TYPE];my$arg;if ($type eq '' || $type eq '!' || $type eq '+'){if (defined$optarg){return (0)if$passthrough;warn ("Option ",$opt," does not take an argument\n");$error++;undef$opt}elsif ($type eq '' || $type eq '+'){$arg=1}else {$opt =~ s/^no-?//i;$arg=0}unshift (@$argv,$starter.$rest)if defined$rest;return (1,$opt,$ctl,$arg)}my$mand=$ctl->[CTL_AMIN];if ($gnu_compat && defined$optarg && $optarg eq ''){return (1,$opt,$ctl,$type eq 's' ? '' : 0);$optarg=0 unless$type eq 's'}if (defined$optarg ? ($optarg eq ''):!(defined$rest || @$argv > 0)){if ($mand){return (0)if$passthrough;warn ("Option ",$opt," requires an argument\n");$error++;return (1,undef)}if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}return (1,$opt,$ctl,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0)}$arg=(defined$rest ? $rest : (defined$optarg ? $optarg : shift (@$argv)));my$key;if ($ctl->[CTL_DEST]==CTL_DEST_HASH && defined$arg){($key,$arg)=($arg =~ /^([^=]*)=(.*)$/s)? ($1,$2): ($arg,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: ($mand ? undef : ($type eq 's' ? "" : 1)));if (!defined$arg){warn ("Option $opt, key \"$key\", requires a value\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}}my$key_valid=$ctl->[CTL_DEST]==CTL_DEST_HASH ? "[^=]+=" : "";if ($type eq 's'){return (1,$opt,$ctl,$arg,$key)if$mand;return (1,$opt,$ctl,$arg,$key)if$ctl->[CTL_DEST]==CTL_DEST_HASH;return (1,$opt,$ctl,$arg,$key)if defined$optarg || defined$rest;return (1,$opt,$ctl,$arg,$key)if$arg eq "-";if ($arg eq $argend || $arg =~ /^$prefix.+/){unshift (@$argv,$arg);$arg=''}}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/si){($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/si){$arg =~ tr/_//d;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (",$type eq 'o' ? "extended " : '',"number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}$arg=defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: 0}}}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/s){$arg =~ tr/_//d;($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/){$arg =~ tr/_//d}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (real number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);$arg=0.0}}}else {die("Getopt::Long internal error (Can't happen)\n")}return (1,$opt,$ctl,$arg,$key)}sub ValidValue ($$$$$) {my ($ctl,$arg,$mand,$argend,$prefix)=@_;if ($ctl->[CTL_DEST]==CTL_DEST_HASH){return 0 unless$arg =~ /[^=]+=(.*)/;$arg=$1}my$type=$ctl->[CTL_TYPE];if ($type eq 's'){return (1)if$mand;return (1)if$arg eq "-";return 0 if$arg eq $argend || $arg =~ /^$prefix.+/;return 1}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;return$arg =~ /^$o_valid$/si}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;return$arg =~ /^$o_valid$/}die("ValidValue: Cannot happen\n")}sub Configure (@) {my (@options)=@_;my$prevconfig=[$error,$debug,$major_version,$minor_version,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix ];if (ref($options[0])eq 'ARRAY'){($error,$debug,$major_version,$minor_version,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix)=@{shift(@options)}}my$opt;for$opt (@options){my$try=lc ($opt);my$action=1;if ($try =~ /^no_?(.*)$/s){$action=0;$try=$+}if (($try eq 'default' or $try eq 'defaults')&& $action){ConfigDefaults ()}elsif (($try eq 'posix_default' or $try eq 'posix_defaults')){local$ENV{POSIXLY_CORRECT};$ENV{POSIXLY_CORRECT}=1 if$action;ConfigDefaults ()}elsif ($try eq 'auto_abbrev' or $try eq 'autoabbrev'){$autoabbrev=$action}elsif ($try eq 'getopt_compat'){$getopt_compat=$action;$genprefix=$action ? "(--|-|\\+)" : "(--|-)"}elsif ($try eq 'gnu_getopt'){if ($action){$gnu_compat=1;$bundling=1;$getopt_compat=0;$genprefix="(--|-)";$order=$PERMUTE}}elsif ($try eq 'gnu_compat'){$gnu_compat=$action}elsif ($try =~ /^(auto_?)?version$/){$auto_version=$action}elsif ($try =~ /^(auto_?)?help$/){$auto_help=$action}elsif ($try eq 'ignorecase' or $try eq 'ignore_case'){$ignorecase=$action}elsif ($try eq 'ignorecase_always' or $try eq 'ignore_case_always'){$ignorecase=$action ? 2 : 0}elsif ($try eq 'bundling'){$bundling=$action}elsif ($try eq 'bundling_override'){$bundling=$action ? 2 : 0}elsif ($try eq 'require_order'){$order=$action ? $REQUIRE_ORDER : $PERMUTE}elsif ($try eq 'permute'){$order=$action ? $PERMUTE : $REQUIRE_ORDER}elsif ($try eq 'pass_through' or $try eq 'passthrough'){$passthrough=$action}elsif ($try =~ /^prefix=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .quotemeta($genprefix).")";eval {'' =~ /$genprefix/};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^prefix_pattern=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .$genprefix .")" unless$genprefix =~ /^\(.*\)$/;eval {'' =~ m"$genprefix"};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^long_prefix_pattern=(.+)$/ && $action){$longprefix=$1;$longprefix="(" .$longprefix .")" unless$longprefix =~ /^\(.*\)$/;eval {'' =~ m"$longprefix"};die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n")if $@}elsif ($try eq 'debug'){$debug=$action}else {die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")}}$prevconfig}sub config (@) {Configure (@_)}sub VersionMessage(@) {my$pa=setup_pa_args("version",@_);my$v=$main::VERSION;my$fh=$pa->{-output}|| ($pa->{-exitval}eq "NOEXIT" || $pa->{-exitval}< 2)? \*STDOUT : \*STDERR;print$fh (defined($pa->{-message})? $pa->{-message}: (),$0,defined$v ? " version $v" : (),"\n","(",__PACKAGE__,"::","GetOptions"," version ",defined($Getopt::Long::VERSION_STRING)? $Getopt::Long::VERSION_STRING : $VERSION,";"," Perl version ",$] >= 5.006 ? sprintf("%vd",$^V): $],")\n");exit($pa->{-exitval})unless$pa->{-exitval}eq "NOEXIT"}sub HelpMessage(@) {eval {require Pod::Usage;import Pod::Usage;1}|| die("Cannot provide help: cannot load Pod::Usage\n");pod2usage(setup_pa_args("help",@_))}sub setup_pa_args($@) {my$tag=shift;@_=()if @_==2 && $_[0]eq $tag;my$pa;if (@_ > 1){$pa={@_ }}else {$pa=shift || {}}if (UNIVERSAL::isa($pa,'HASH')){$pa->{-message}=$pa->{-msg};delete($pa->{-msg})}elsif ($pa =~ /^-?\d+$/){$pa={-exitval=>$pa }}else {$pa={-message=>$pa }}$pa->{-verbose}=0 unless exists($pa->{-verbose});$pa->{-exitval}=0 unless exists($pa->{-exitval});$pa}sub VERSION {$requested_version=$_[1];shift->SUPER::VERSION(@_)}package Getopt::Long::CallBack;sub new {my ($pkg,%atts)=@_;bless {%atts },$pkg}sub name {my$self=shift;''.$self->{name}}use overload '""'=>\&name,fallback=>1;1;
GETOPT_LONG

$fatpacked{"IO/CaptureOutput.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_CAPTUREOUTPUT';
  package IO::CaptureOutput;use strict;use vars qw/$VERSION @ISA @EXPORT_OK %EXPORT_TAGS $CarpLevel/;use Exporter;use Carp qw/croak/;@ISA='Exporter';@EXPORT_OK=qw/capture capture_exec qxx capture_exec_combined qxy/;%EXPORT_TAGS=(all=>\@EXPORT_OK);$VERSION='1.1102';$VERSION=eval$VERSION;$CarpLevel=0;sub _capture (&@) {my ($code,$output,$error,$output_file,$error_file)=@_;{local$Carp::CarpLevel=1;my$error=_validate($output,$error,$output_file,$error_file);croak$error if$error}if (defined$output || defined$error){for ($output,$error){$_=\do {my$s;$s=''}unless ref $_;$$_='' if $_!=\undef &&!defined($$_)}}my$should_merge=(defined$error && defined$output && $output==$error)|| (!defined$output &&!defined$error)|| 0;my ($capture_out,$capture_err);if (!defined$output || $output!=\undef){$capture_out=IO::CaptureOutput::_proxy->new('STDOUT',$output,undef,$output_file)}if (!defined$error || $error!=\undef){$capture_err=IO::CaptureOutput::_proxy->new('STDERR',$error,($should_merge ? 'STDOUT' : undef),$error_file)}&$code()}sub capture (&@) {return&_capture}sub capture_exec {my@args=@_;my ($output,$error);my$exit=_capture sub {system _shell_quote(@args)},\$output,\$error;my$success=($exit==0)? 1 : 0 ;$?=$exit;return wantarray ? ($output,$error,$success,$exit): $output}*qxx=\&capture_exec;sub capture_exec_combined {my@args=@_;my$output;my$exit=_capture sub {system _shell_quote(@args)},\$output,\$output;my$success=($exit==0)? 1 : 0 ;$?=$exit;return wantarray ? ($output,$success,$exit): $output}*qxy=\&capture_exec_combined;*_shell_quote=($^O =~ /MSWin32/)? \&_shell_quote_win32 : sub {@_};sub _shell_quote_win32 {my@args;for (@_){if (/[ \"]/){(my$escaped=$_)=~ s/([\"])/\\$1/g;push@args,'"' .$escaped .'"';next}push@args,$_}return@args}sub _validate {my ($output,$error,$output_file,$error_file)=@_;my$msg=q{};if (defined$output && defined$error && defined$output_file && defined$error_file && $output==$error && $output!=\undef && $output_file ne $error_file){$msg="Merged STDOUT and STDERR, but specified different output and error files"}elsif (!defined$output &&!defined$error && defined$output_file && defined$error_file && $output_file ne $error_file){$msg="Merged STDOUT and STDERR, but specified different output and error files"}return$msg}package IO::CaptureOutput::_proxy;use File::Temp 'tempfile';use File::Basename qw/basename/;use Symbol qw/gensym qualify qualify_to_ref/;use Carp;sub _is_wperl {$^O eq 'MSWin32' && basename($^X)eq 'wperl.exe'}sub new {my$class=shift;my ($orig_fh,$capture_var,$merge_fh,$capture_file)=@_;$orig_fh=qualify($orig_fh);my$fhref=qualify_to_ref($orig_fh);my$saved_fh;{no strict 'refs';if (defined fileno($orig_fh)&&!_is_wperl()){$saved_fh=gensym;open$saved_fh,">&$orig_fh" or croak "Can't redirect <$orig_fh> - $!"}}my ($newio_fh,$newio_file);if (!$merge_fh){$newio_fh=gensym;if ($capture_file){$newio_file=$capture_file}else {(undef,$newio_file)=tempfile}open$newio_fh,"+>$newio_file" or croak "Can't write temp file for $orig_fh - $!"}else {$newio_fh=qualify($merge_fh)}{no strict 'refs';open$fhref,">&".fileno($newio_fh)or croak "Can't redirect $orig_fh - $!"}bless [$$,$orig_fh,$saved_fh,$capture_var,$newio_fh,$newio_file,$capture_file],$class}sub DESTROY {my$self=shift;my ($pid,$orig_fh,$saved_fh,$capture_var,$newio_fh,$newio_file,$capture_file)=@$self;return unless$pid eq $$;my$fh_ref=Symbol::qualify_to_ref($orig_fh);select((select ($fh_ref),$|=1)[0]);if (defined$saved_fh){open$fh_ref,">&".fileno($saved_fh)or croak "Can't restore $orig_fh - $!"}else {close$fh_ref}if (ref$capture_var && $newio_file){local $^W;seek$newio_fh,0,0;$$capture_var=do {local $/;<$newio_fh>}}close$newio_fh if$newio_file;return unless defined$newio_file && -e $newio_file;return if$capture_file;unlink$newio_file or carp "Couldn't remove temp file '$newio_file' - $!"}1;
IO_CAPTUREOUTPUT

$fatpacked{"IO/Interactive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_INTERACTIVE';
  package IO::Interactive;use version;$VERSION=qv('0.0.6');use warnings;use strict;use Carp;use Scalar::Util qw(openhandle);sub is_interactive {my ($out_handle)=(@_,select);return 0 if not -t $out_handle;if (openhandle*ARGV){return -t *STDIN if defined$ARGV && $ARGV eq '-';return@ARGV>0 && $ARGV[0]eq '-' && -t *STDIN if eof*ARGV;return -t *ARGV}else {return -t *STDIN}}local (*DEV_NULL,*DEV_NULL2);my$dev_null;BEGIN {pipe*DEV_NULL,*DEV_NULL2 or die "Internal error: can't create null filehandle";$dev_null=\*DEV_NULL}sub interactive {my ($out_handle)=(@_,\*STDOUT);return&is_interactive ? $out_handle : $dev_null}sub _input_pending_on {my ($fh)=@_;my$read_bits="";my$bit=fileno($fh);return if$bit < 0;vec($read_bits,fileno($fh),1)=1;select$read_bits,undef,undef,0.1;return$read_bits}sub busy (&) {my ($block_ref)=@_;if (!is_interactive()){$block_ref->();open my$fh,'<',\"";return$fh}my ($read,$write);pipe$read,$write;my$child=fork;if (!$child){use IO::Handle;close$read;$write->autoflush(1);while (1){if (_input_pending_on(\*ARGV)){my$res=<ARGV>;print {$write}$res;print {*STDERR}"That input was ignored. ","Please don't press any keys yet.\n"}}exit}close$write;local*ARGV;open*ARGV,'<',\"";$block_ref->();kill 9,$child;wait;return$read}use Carp;sub import {my ($package)=shift;my$caller=caller;for my$request (@_){no strict 'refs';my$impl=*{$package.'::'.$request}{CODE};croak "Unknown subroutine ($request()) requested" if!$impl || $request =~ m/\A _/xms;*{$caller.'::'.$request}=$impl}}1;
IO_INTERACTIVE

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;use strictures 1;use Moo::_Utils;use base qw(Moo::Object);use Sub::Quote;use B 'perlstring';use Scalar::Util 'blessed';use overload ();use Module::Runtime qw(use_module);BEGIN {our$CAN_HAZ_XS=!$ENV{MOO_XS_DISABLE}&& _maybe_load_module('Class::XSAccessor')&& (eval {Class::XSAccessor->VERSION('1.07')})}sub _SIGDIE {our ($CurrentAttribute,$OrigSigDie);my$sigdie=$OrigSigDie && $OrigSigDie!=\&_SIGDIE ? $OrigSigDie : sub {die $_[0]};return$sigdie->(@_)if ref($_[0]);my$attr_desc=_attr_desc(@$CurrentAttribute{qw(name init_arg)});$sigdie->("$CurrentAttribute->{step} for $attr_desc failed: $_[0]")}sub _die_overwrite {my ($pkg,$method,$type)=@_;die "You cannot overwrite a locally defined method ($method) with @{[ $type || 'an accessor' ]}"}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$spec->{allow_overwrite}++ if$name =~ s/^\+//;die "Must have an is" unless my$is=$spec->{is};if ($is eq 'ro'){$spec->{reader}=$name unless exists$spec->{reader}}elsif ($is eq 'rw'){$spec->{accessor}=$name unless exists$spec->{accessor}or ($spec->{reader}and $spec->{writer})}elsif ($is eq 'lazy'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{lazy}=1;$spec->{builder}||='_build_'.$name unless$spec->{default}}elsif ($is eq 'rwp'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{writer}="_set_${name}" unless exists$spec->{writer}}elsif ($is ne 'bare'){die "Unknown is ${is}"}if (exists$spec->{builder}){if(ref$spec->{builder}){$self->_validate_codulatable('builder',$spec->{builder},"$into->$name",'or a method name');$spec->{builder_sub}=$spec->{builder};$spec->{builder}=1}$spec->{builder}='_build_'.$name if ($spec->{builder}||0)eq 1;die "Invalid builder for $into->$name - not a valid method name" if$spec->{builder}!~ /\A[A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)*\z/}if (($spec->{predicate}||0)eq 1){$spec->{predicate}=$name =~ /^_/ ? "_has${name}" : "has_${name}"}if (($spec->{clearer}||0)eq 1){$spec->{clearer}=$name =~ /^_/ ? "_clear${name}" : "clear_${name}"}if (($spec->{trigger}||0)eq 1){$spec->{trigger}=quote_sub('shift->_trigger_'.$name.'(@_)')}for my$setting (qw(isa coerce)){next if!exists$spec->{$setting};$self->_validate_codulatable($setting,$spec->{$setting},"$into->$name")}if (exists$spec->{default}){if (!defined$spec->{default}|| ref$spec->{default}){$self->_validate_codulatable('default',$spec->{default},"$into->$name",'or a non-ref')}}if (exists$spec->{moosify}){if (ref$spec->{moosify}ne 'ARRAY'){$spec->{moosify}=[$spec->{moosify}]}for my$spec (@{$spec->{moosify}}){$self->_validate_codulatable('moosify',$spec,"$into->$name")}}my%methods;if (my$reader=$spec->{reader}){_die_overwrite($into,$reader,'a reader')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${reader}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)){$methods{$reader}=$self->_generate_xs(getters=>$into,$reader,$name,$spec)}else {$self->{captures}={};$methods{$reader}=quote_sub "${into}::${reader}" =>'    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n" .$self->_generate_get($name,$spec)=>delete$self->{captures}}}if (my$accessor=$spec->{accessor}){_die_overwrite($into,$accessor,'an accessor')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${accessor}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)&& $self->is_simple_set($name,$spec)){$methods{$accessor}=$self->_generate_xs(accessors=>$into,$accessor,$name,$spec)}else {$self->{captures}={};$methods{$accessor}=quote_sub "${into}::${accessor}" =>$self->_generate_getset($name,$spec)=>delete$self->{captures}}}if (my$writer=$spec->{writer}){_die_overwrite($into,$writer,'a writer')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${writer}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_set($name,$spec)){$methods{$writer}=$self->_generate_xs(setters=>$into,$writer,$name,$spec)}else {$self->{captures}={};$methods{$writer}=quote_sub "${into}::${writer}" =>$self->_generate_set($name,$spec)=>delete$self->{captures}}}if (my$pred=$spec->{predicate}){_die_overwrite($into,$pred,'a predicate')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${pred}")}{CODE};$methods{$pred}=quote_sub "${into}::${pred}"=>'    '.$self->_generate_simple_has('$_[0]',$name,$spec)."\n" }if (my$pred=$spec->{builder_sub}){_install_coderef("${into}::$spec->{builder}"=>$spec->{builder_sub})}if (my$cl=$spec->{clearer}){_die_overwrite($into,$cl,'a clearer')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${cl}")}{CODE};$methods{$cl}=quote_sub "${into}::${cl}"=>$self->_generate_simple_clear('$_[0]',$name,$spec)."\n" }if (my$hspec=$spec->{handles}){my$asserter=$spec->{asserter}||='_assert_'.$name;my@specs=do {if (ref($hspec)eq 'ARRAY'){map [$_=>$_ ],@$hspec}elsif (ref($hspec)eq 'HASH'){map [$_=>ref($hspec->{$_})? @{$hspec->{$_}}: $hspec->{$_}],keys %$hspec}elsif (!ref($hspec)){map [$_=>$_ ],use_module('Role::Tiny')->methods_provided_by(use_module($hspec))}else {die "You gave me a handles of ${hspec} and I have no idea why"}};for my$delegation_spec (@specs){my ($proxy,$target,@args)=@$delegation_spec;_die_overwrite($into,$proxy,'a delegation')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${proxy}")}{CODE};$self->{captures}={};$methods{$proxy}=quote_sub "${into}::${proxy}"=>$self->_generate_delegation($asserter,$target,\@args),delete$self->{captures}}}if (my$asserter=$spec->{asserter}){$self->{captures}={};$methods{$asserter}=quote_sub "${into}::${asserter}"=>$self->_generate_asserter($name,$spec),delete$self->{captures}}\%methods}sub is_simple_attribute {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(lazy default builder coerce isa trigger predicate weak_ref)}sub is_simple_get {my ($self,$name,$spec)=@_;!($spec->{lazy}and ($spec->{default}or $spec->{builder}))}sub is_simple_set {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(coerce isa trigger weak_ref)}sub has_eager_default {my ($self,$name,$spec)=@_;(!$spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub _generate_get {my ($self,$name,$spec)=@_;my$simple=$self->_generate_simple_get('$_[0]',$name,$spec);if ($self->is_simple_get($name,$spec)){$simple}else {$self->_generate_use_default('$_[0]',$name,$spec,$self->_generate_simple_has('$_[0]',$name,$spec),)}}sub generate_simple_has {my$self=shift;$self->{captures}={};my$code=$self->_generate_simple_has(@_);($code,delete$self->{captures})}sub _generate_simple_has {my ($self,$me,$name)=@_;"exists ${me}->{${\perlstring $name}}"}sub _generate_simple_clear {my ($self,$me,$name)=@_;"    delete ${me}->{${\perlstring $name}}\n"}sub generate_get_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_get_default(@_);($code,delete$self->{captures})}sub generate_use_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_use_default(@_);($code,delete$self->{captures})}sub _generate_use_default {my ($self,$me,$name,$spec,$test)=@_;my$get_value=$self->_generate_get_default($me,$name,$spec);if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce})}$test." ? \n" .$self->_generate_simple_get($me,$name,$spec)."\n:" .($spec->{isa}? "    do {\n      my \$value = ".$get_value.";\n" ."      ".$self->_generate_isa_check($name,'$value',$spec->{isa}).";\n" ."      ".$self->_generate_simple_set($me,$name,$spec,'$value')."\n" ."    }\n" : '    ('.$self->_generate_simple_set($me,$name,$spec,$get_value).")\n")}sub _generate_get_default {my ($self,$me,$name,$spec)=@_;if (exists$spec->{default}){ref$spec->{default}? $self->_generate_call_code($name,'default',$me,$spec->{default}): perlstring$spec->{default}}else {"${me}->${\$spec->{builder}}"}}sub generate_simple_get {my ($self,@args)=@_;$self->_generate_simple_get(@args)}sub _generate_simple_get {my ($self,$me,$name)=@_;my$name_str=perlstring$name;"${me}->{${name_str}}"}sub _generate_set {my ($self,$name,$spec)=@_;if ($self->is_simple_set($name,$spec)){$self->_generate_simple_set('$_[0]',$name,$spec,'$_[1]')}else {my ($coerce,$trigger,$isa_check)=@{$spec}{qw(coerce trigger isa)};my$value_store='$_[0]';my$code;if ($coerce){$value_store='$value';$code="do { my (\$self, \$value) = \@_;\n" ."        \$value = " .$self->_generate_coerce($name,$value_store,$coerce).";\n"}else {$code="do { my \$self = shift;\n"}if ($isa_check){$code .= "        ".$self->_generate_isa_check($name,$value_store,$isa_check).";\n"}my$simple=$self->_generate_simple_set('$self',$name,$spec,$value_store);if ($trigger){my$fire=$self->_generate_trigger($name,'$self',$value_store,$trigger);$code .= "        ".$simple.";\n        ".$fire.";\n" ."        $value_store;\n"}else {$code .= "        ".$simple.";\n"}$code .= "      }";$code}}sub generate_coerce {my$self=shift;$self->{captures}={};my$code=$self->_generate_coerce(@_);($code,delete$self->{captures})}sub _attr_desc {my ($name,$init_arg)=@_;return perlstring($name)if!defined($init_arg)or $init_arg eq $name;return perlstring($name).' (constructor argument: '.perlstring($init_arg).')'}sub _generate_coerce {my ($self,$name,$value,$coerce,$init_arg)=@_;$self->_generate_die_prefix($name,"coercion",$init_arg,$self->_generate_call_code($name,'coerce',"${value}",$coerce))}sub generate_trigger {my$self=shift;$self->{captures}={};my$code=$self->_generate_trigger(@_);($code,delete$self->{captures})}sub _generate_trigger {my ($self,$name,$obj,$value,$trigger)=@_;$self->_generate_call_code($name,'trigger',"${obj}, ${value}",$trigger)}sub generate_isa_check {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_isa_check(@args);($code,delete$self->{captures})}sub _generate_die_prefix {my ($self,$name,$prefix,$arg,$inside)=@_;"do {\n" .'  local $Method::Generate::Accessor::CurrentAttribute = {' .'    init_arg => '.(defined$arg ? B::perlstring($arg): 'undef').",\n" .'    name     => '.B::perlstring($name).",\n" .'    step     => '.B::perlstring($prefix).",\n" ."  };\n" .'  local $Method::Generate::Accessor::OrigSigDie = $SIG{__DIE__};'."\n" .'  local $SIG{__DIE__} = \&Method::Generate::Accessor::_SIGDIE;'."\n" .$inside ."}\n"}sub _generate_isa_check {my ($self,$name,$value,$check,$init_arg)=@_;$self->_generate_die_prefix($name,"isa check",$init_arg,$self->_generate_call_code($name,'isa_check',$value,$check))}sub _generate_call_code {my ($self,$name,$type,$values,$sub)=@_;$sub=\&{$sub}if blessed($sub);if (my$quoted=quoted_from_sub($sub)){my$local=1;if ($values eq '@_' || $values eq '$_[0]'){$local=0;$values='@_'}my$code=$quoted->[1];if (my$captures=$quoted->[2]){my$cap_name=qq{\$${type}_captures_for_${name}};$self->{captures}->{$cap_name}=\$captures;Sub::Quote::inlinify($code,$values,Sub::Quote::capture_unroll($cap_name,$captures,6),$local)}else {Sub::Quote::inlinify($code,$values,undef,$local)}}else {my$cap_name=qq{\$${type}_for_${name}};$self->{captures}->{$cap_name}=\$sub;"${cap_name}->(${values})"}}sub generate_populate_set {my$self=shift;$self->{captures}={};my$code=$self->_generate_populate_set(@_);($code,delete$self->{captures})}sub _generate_populate_set {my ($self,$me,$name,$spec,$source,$test,$init_arg)=@_;if ($self->has_eager_default($name,$spec)){my$get_indent=' ' x ($spec->{isa}? 6 : 4);my$get_default=$self->_generate_get_default('$new',$name,$spec);my$get_value=defined($spec->{init_arg})? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : " .$get_default ."\n${get_indent})" : $get_default;if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce},$init_arg)}($spec->{isa}? "    {\n      my \$value = ".$get_value.";\n      " .$self->_generate_isa_check($name,'$value',$spec->{isa},$init_arg).";\n" .'      '.$self->_generate_simple_set($me,$name,$spec,'$value').";\n" ."    }\n" : '    '.$self->_generate_simple_set($me,$name,$spec,$get_value).";\n").($spec->{trigger}? '    ' .$self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger})." if ${test};\n" : '')}else {"    if (${test}) {\n" .($spec->{coerce}? "      $source = " .$self->_generate_coerce($name,$source,$spec->{coerce},$init_arg).";\n" : "").($spec->{isa}? "      " .$self->_generate_isa_check($name,$source,$spec->{isa},$init_arg).";\n" : "")."      ".$self->_generate_simple_set($me,$name,$spec,$source).";\n" .($spec->{trigger}? "      " .$self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger}).";\n" : "")."    }\n"}}sub _generate_core_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=perlstring$name;"${me}->{${name_str}} = ${value}"}sub _generate_simple_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=perlstring$name;my$simple=$self->_generate_core_set($me,$name,$spec,$value);if ($spec->{weak_ref}){require Scalar::Util;my$get=$self->_generate_simple_get($me,$name,$spec);my$weak_simple="do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";Moo::_Utils::lt_5_8_3()? <<"EOC" : $weak_simple}else {$simple}}sub _generate_getset {my ($self,$name,$spec)=@_;q{(@_ > 1}."\n      ? ".$self->_generate_set($name,$spec)."\n      : ".$self->_generate_get($name,$spec)."\n    )"}sub _generate_asserter {my ($self,$name,$spec)=@_;"do {\n" ."  my \$val = ".$self->_generate_get($name,$spec).";\n" ."  unless (".$self->_generate_simple_has('$_[0]',$name,$spec).") {\n" .qq!    die "Attempted to access '${name}' but it is not set";\n! ."  }\n" ."  \$val;\n" ."}\n"}sub _generate_delegation {my ($self,$asserter,$target,$args)=@_;my$arg_string=do {if (@$args){$self->{captures}{'@curries'}=$args;'@curries, @_'}else {'@_'}};"shift->${asserter}->${target}(${arg_string});"}sub _generate_xs {my ($self,$type,$into,$name,$slot)=@_;Class::XSAccessor->import(class=>$into,$type=>{$name=>$slot },replace=>1,);$into->can($name)}sub default_construction_string {'{}'}sub _validate_codulatable {my ($self,$setting,$value,$into,$appended)=@_;my$invalid="Invalid $setting '" .overload::StrVal($value)."' for $into not a coderef";$invalid .= " $appended" if$appended;unless (ref$value and (ref$value eq 'CODE' or blessed($value))){die "$invalid or code-convertible object"}unless (eval {\&$value}){die "$invalid and could not be converted to a coderef: $@"}1}1;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;use strictures 1;use base qw(Moo::Object);use Sub::Quote;use Moo::_Utils;use B 'perlstring';sub generate_method {my ($self,$into)=@_;quote_sub "${into}::BUILDALL",join '',$self->_handle_subbuild($into),qq{    my \$self = shift;\n},$self->buildall_body_for($into,'$self','@_'),qq{    return \$self\n}}sub _handle_subbuild {my ($self,$into)=@_;'    if (ref($_[0]) ne '.perlstring($into).') {'."\n".'      return shift->Moo::Object::BUILDALL(@_)'.";\n".'    }'."\n"}sub buildall_body_for {my ($self,$into,$me,$args)=@_;my@builds=grep *{_getglob($_)}{CODE},map "${_}::BUILD",reverse @{Moo::_Utils::_get_linear_isa($into)};join '',map qq{    ${me}->${_}(${args});\n},@builds}1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;use strictures 1;use Sub::Quote;use base qw(Moo::Object);use Sub::Defer;use B 'perlstring';use Moo::_Utils qw(_getstash);sub register_attribute_specs {my ($self,@new_specs)=@_;my$specs=$self->{attribute_specs}||={};while (my ($name,$new_spec)=splice@new_specs,0,2){if ($name =~ s/^\+//){die "has '+${name}' given but no ${name} attribute already exists" unless my$old_spec=$specs->{$name};for my$key (keys %$old_spec){if (!exists$new_spec->{$key}){$new_spec->{$key}=$old_spec->{$key}unless$key eq 'handles'}elsif ($key eq 'moosify'){$new_spec->{$key}=[map {ref $_ eq 'ARRAY' ? @$_ : $_}($old_spec->{$key},$new_spec->{$key})]}}}$new_spec->{index}=scalar keys %$specs unless defined$new_spec->{index};$specs->{$name}=$new_spec}$self}sub all_attribute_specs {$_[0]->{attribute_specs}}sub accessor_generator {$_[0]->{accessor_generator}}sub construction_string {my ($self)=@_;$self->{construction_string}||=$self->_build_construction_string}sub _build_construction_string {'bless(' .$_[0]->accessor_generator->default_construction_string .', $class);'}sub install_delayed {my ($self)=@_;my$package=$self->{package};defer_sub "${package}::new"=>sub {unquote_sub$self->generate_method($package,'new',$self->{attribute_specs},{no_install=>1 })};$self}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;for my$no_init (grep!exists($spec->{$_}{init_arg}),keys %$spec){$spec->{$no_init}{init_arg}=$no_init}local$self->{captures}={};my$body='    my $class = shift;'."\n" .'    $class = ref($class) if ref($class);'."\n";$body .= $self->_handle_subconstructor($into,$name);my$into_buildargs=$into->can('BUILDARGS');if ($into_buildargs && $into_buildargs!=\&Moo::Object::BUILDARGS){$body .= $self->_generate_args_via_buildargs}else {$body .= $self->_generate_args}$body .= $self->_check_required($spec);$body .= '    my $new = '.$self->construction_string.";\n";$body .= $self->_assign_new($spec);if ($into->can('BUILD')){require Method::Generate::BuildAll;$body .= Method::Generate::BuildAll->new->buildall_body_for($into,'$new','$args')}$body .= '    return $new;'."\n";if ($into->can('DEMOLISH')){require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new->generate_method($into)}quote_sub "${into}::${name}"=>$body,$self->{captures},$quote_opts||{}}sub _handle_subconstructor {my ($self,$into,$name)=@_;if (my$gen=$self->{subconstructor_handler}){'    if ($class ne '.perlstring($into).') {'."\n".$gen.'    }'."\n"}else {''}}sub _cap_call {my ($self,$code,$captures)=@_;@{$self->{captures}}{keys %$captures}=values %$captures if$captures;$code}sub _generate_args_via_buildargs {my ($self)=@_;q{    my $args = $class->BUILDARGS(@_);}."\n" .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';} ."\n"}sub _generate_args {my ($self)=@_;return <<'_EOA'}sub _assign_new {my ($self,$spec)=@_;my$ag=$self->accessor_generator;my%test;NAME: foreach my$name (sort keys %$spec){my$attr_spec=$spec->{$name};next NAME unless defined($attr_spec->{init_arg})or $ag->has_eager_default($name,$attr_spec);$test{$name}=$attr_spec->{init_arg}}join '',map {my$arg_key=perlstring($test{$_});my$test="exists \$args->{$arg_key}";my$source="\$args->{$arg_key}";my$attr_spec=$spec->{$_};$self->_cap_call($ag->generate_populate_set('$new',$_,$attr_spec,$source,$test,$test{$_},))}sort keys%test}sub _check_required {my ($self,$spec)=@_;my@required_init=map$spec->{$_}{init_arg},grep {my%s=%{$spec->{$_}};$s{required}and not($s{builder}or $s{default})}sort keys %$spec;return '' unless@required_init;'    if (my @missing = grep !exists $args->{$_}, qw(' .join(' ',@required_init).')) {'."\n" .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n" ."    }\n"}use Moo;Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(attribute_specs=>{is=>'ro',reader=>'all_attribute_specs',},accessor_generator=>{is=>'ro' },construction_string=>{is=>'lazy' },subconstructor_handler=>{is=>'ro' },package=>{is=>'ro' },);1;
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;use strictures 1;use base qw(Moo::Object);use Sub::Quote;use Moo::_Utils;use B qw(perlstring);sub generate_method {my ($self,$into)=@_;quote_sub "${into}::DEMOLISHALL",join '',$self->_handle_subdemolish($into),qq{    my \$self = shift;\n},$self->demolishall_body_for($into,'$self','@_'),qq{    return \$self\n};quote_sub "${into}::DESTROY",join '',q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL(Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !}sub demolishall_body_for {my ($self,$into,$me,$args)=@_;my@demolishers=grep *{_getglob($_)}{CODE},map "${_}::DEMOLISH",@{Moo::_Utils::_get_linear_isa($into)};join '',map qq{    ${me}->${_}(${args});\n},@demolishers}sub _handle_subdemolish {my ($self,$into)=@_;'    if (ref($_[0]) ne '.perlstring($into).') {'."\n".'      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".'    }'."\n"}1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;use strictures 1;use Text::Balanced qw(extract_bracketed);use Sub::Quote ();sub slurp {do {local (@ARGV,$/)=$_[0];<>}}sub splat {open my$out,'>',$_[1]or die "can't open $_[1]: $!";print$out $_[0]or die "couldn't write to $_[1]: $!"}sub inlinify {my$file=$_[0];my@chunks=split /(^sub.*?^}$)/sm,slurp$file;warn join "\n--\n",@chunks;my%code;for my$chunk (@chunks){if (my ($name,$body)=$chunk =~ /^sub (\S+) {\n(.*)\n}$/s){$code{$name}=$body}}for my$chunk (@chunks){my ($me)=$chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;my$meq=quotemeta$me;my$copy=$chunk;my ($fixed,$rest);while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s){my ($front,$name)=($1,$2);((my$body),$rest)=extract_bracketed($copy,'()');warn "spotted ${name} - ${body}";if ($code{$name}){warn "replacing";s/^\(//,s/\)$// for$body;$body="${me}, ".$body;$fixed .= $front.Sub::Quote::inlinify($code{$name},$body)}else {$fixed .= $front.$me.'->'.$name.$body}$copy=$rest}$fixed .= $rest if$fixed;warn$fixed if$fixed;$chunk=$fixed if$fixed}print join '',@chunks}1;
METHOD_INLINER

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  package Module::Runtime;BEGIN {require 5.006}BEGIN {${^WARNING_BITS}=""}our$VERSION="0.013";our@EXPORT_OK=qw($module_name_rx is_module_name is_valid_module_name check_module_name module_notional_filename require_module use_module use_package_optimistically $top_module_spec_rx $sub_module_spec_rx is_module_spec is_valid_module_spec check_module_spec compose_module_name);my%export_ok=map {($_=>undef)}@EXPORT_OK;sub import {my$me=shift;my$callpkg=caller(0);my$errs="";for(@_){if(exists$export_ok{$_}){if(/\A\$(.*)\z/s){*{$callpkg."::".$1}=\$$1}else {*{$callpkg."::".$_}=\&$_}}else {$errs .= "\"$_\" is not exported by the $me module\n"}}if($errs ne ""){die "${errs}Can't continue after import errors "."at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n"}}sub _is_string($) {my($arg)=@_;return defined($arg)&& ref(\$arg)eq "SCALAR"}our$module_name_rx=qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;my$qual_module_spec_rx=qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;my$unqual_top_module_spec_rx=qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$top_module_spec_rx=qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;my$unqual_sub_module_spec_rx=qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$sub_module_spec_rx=qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;sub is_module_name($) {_is_string($_[0])&& $_[0]=~ /\A$module_name_rx\z/o}*is_valid_module_name=\&is_module_name;sub check_module_name($) {unless(&is_module_name){die +(_is_string($_[0])? "`$_[0]'" : "argument")." is not a module name\n"}}sub module_notional_filename($) {&check_module_name;my($name)=@_;$name =~ s!::!/!g;return$name.".pm"}BEGIN {*_WORK_AROUND_HINT_LEAKAGE="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}BEGIN {if(_WORK_AROUND_BROKEN_MODULE_STATE){eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  };die $@ if $@ ne ""}}sub require_module($) {local %^H if _WORK_AROUND_HINT_LEAKAGE;if(_WORK_AROUND_BROKEN_MODULE_STATE){my$notional_filename=&module_notional_filename;my$guard=bless([$notional_filename ],"Module::Runtime::__GUARD__");my$result=require($notional_filename);pop @$guard;return$result}else {return scalar(require(&module_notional_filename))}}sub use_module($;$) {my($name,$version)=@_;require_module($name);if(defined$version){$name->VERSION($version)}return$name}sub use_package_optimistically($;$) {my($name,$version)=@_;check_module_name($name);eval {local$SIG{__DIE__};require_module($name)};die $@ if $@ ne "" && $@ !~ /\ACan't locate .+ at \Q@{[__FILE__]}\E line/s;$name->VERSION($version)if defined$version;return$name}sub is_module_spec($$) {my($prefix,$spec)=@_;return _is_string($spec)&& $spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o : qr/\A$top_module_spec_rx\z/o)}*is_valid_module_spec=\&is_module_spec;sub check_module_spec($$) {unless(&is_module_spec){die +(_is_string($_[1])? "`$_[1]'" : "argument")." is not a module specification\n"}}sub compose_module_name($$) {my($prefix,$spec)=@_;check_module_name($prefix)if defined$prefix;&check_module_spec;if($spec =~ s#\A(?:/|::)##){}else {$spec=$prefix."::".$spec if defined$prefix}$spec =~ s#/#::#g;return$spec}1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;use strictures 1;use Moo::_Utils;use B 'perlstring';use Sub::Defer ();our$VERSION='1.003001';$VERSION=eval$VERSION;require Moo::sification;our%MAKERS;sub _install_tracked {my ($target,$name,$code)=@_;$MAKERS{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::${name}"=>$code}sub import {my$target=caller;my$class=shift;strictures->import;if ($Role::Tiny::INFO{$target}and $Role::Tiny::INFO{$target}{is_role}){die "Cannot import Moo into a role"}$MAKERS{$target}||={};_install_tracked$target=>extends=>sub {$class->_set_superclasses($target,@_);$class->_maybe_reset_handlemoose($target);return};_install_tracked$target=>with=>sub {require Moo::Role;Moo::Role->apply_roles_to_package($target,@_);$class->_maybe_reset_handlemoose($target)};_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){require Carp;Carp::croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$class->_constructor_maker_for($target)->register_attribute_specs($name,$spec_ref);$class->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);$class->_maybe_reset_handlemoose($target)}return};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {require Class::Method::Modifiers;_install_modifier($target,$type,@_);return}}return if$MAKERS{$target}{is_class};$MAKERS{$target}{is_class}=1;{no strict 'refs';@{"${target}::ISA"}=do {require Moo::Object;('Moo::Object')}unless @{"${target}::ISA"}}if ($INC{'Moo/HandleMoose.pm'}){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub unimport {my$target=caller;_unimport_coderefs($target,$MAKERS{$target})}sub _set_superclasses {my$class=shift;my$target=shift;for my$superclass (@_){_load_module($superclass);if ($INC{"Role/Tiny.pm"}&& $Role::Tiny::INFO{$superclass}){require Carp;Carp::croak("Can't extend role '$superclass'")}}@{*{_getglob("${target}::ISA")}{ARRAY}}=@_;if (my$old=delete$Moo::MAKERS{$target}{constructor}){delete _getstash($target)->{new};Moo->_constructor_maker_for($target)->register_attribute_specs(%{$old->all_attribute_specs})}elsif (!$target->isa('Moo::Object')){Moo->_constructor_maker_for($target)}no warnings 'once';$Moo::HandleMoose::MOUSE{$target}=[grep defined,map Mouse::Util::find_meta($_),@_ ]if Mouse::Util->can('find_meta')}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{"Moo/HandleMoose.pm"}){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _accessor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{accessor}||=do {my$maker_class=do {if (my$m=do {if (my$defer_target=(Sub::Defer::defer_info($target->can('new'))||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);$MAKERS{$pkg}&& $MAKERS{$pkg}{accessor}}else {undef}}){ref($m)}else {require Method::Generate::Accessor;'Method::Generate::Accessor'}};$maker_class->new}}sub _constructor_maker_for {my ($class,$target,$select_super)=@_;return unless$MAKERS{$target};$MAKERS{$target}{constructor}||=do {require Method::Generate::Constructor;require Sub::Defer;my ($moo_constructor,$con);if ($select_super && $MAKERS{$select_super}){$moo_constructor=1;$con=$MAKERS{$select_super}{constructor}}else {my$t_new=$target->can('new');if ($t_new){if ($t_new==Moo::Object->can('new')){$moo_constructor=1}elsif (my$defer_target=(Sub::Defer::defer_info($t_new)||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);if ($MAKERS{$pkg}){$moo_constructor=1;$con=$MAKERS{$pkg}{constructor}}}}else {$moo_constructor=1}};($con ? ref($con): 'Method::Generate::Constructor')->new(package=>$target,accessor_generator=>$class->_accessor_maker_for($target),construction_string=>($moo_constructor ? ($con ? $con->construction_string : undef): ('$class->'.$target.'::SUPER::new($class->can(q[FOREIGNBUILDARGS]) ? $class->FOREIGNBUILDARGS(@_) : @_)')),subconstructor_handler=>('      if ($Moo::MAKERS{$class}) {'."\n" .'        '.$class.'->_constructor_maker_for($class,'.perlstring($target).');'."\n" .'        return $class->new(@_)'.";\n" .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n" .'        return $meta->new_object($class->BUILDARGS(@_));'."\n" .'      }'."\n"),)->install_delayed ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})}}1;
MOO

$fatpacked{"Moo/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_CONFLICTS';
  package Moo::Conflicts;use strict;use warnings;use Dist::CheckConflicts -dist=>'Moo',-conflicts=>{'HTML::Restrict'=>'2.1.5',},-also=>[qw(Carp Class::Method::Modifiers strictures Module::Runtime Role::Tiny Devel::GlobalDestruction) ],;1;
MOO_CONFLICTS

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;use strictures 1;use Moo::_Utils;use B qw(perlstring);our%TYPE_MAP;our$SETUP_DONE;sub import {return if$SETUP_DONE;inject_all();$SETUP_DONE=1}sub inject_all {require Class::MOP;inject_fake_metaclass_for($_)for grep $_ ne 'Moo::Object',do {no warnings 'once';keys%Moo::MAKERS};inject_fake_metaclass_for($_)for keys%Moo::Role::INFO;require Moose::Meta::Method::Constructor;@Moo::HandleMoose::FakeConstructor::ISA='Moose::Meta::Method::Constructor'}sub maybe_reinject_fake_metaclass_for {my ($name)=@_;our%DID_INJECT;if (delete$DID_INJECT{$name}){unless ($Moo::Role::INFO{$name}){Moo->_constructor_maker_for($name)->install_delayed}inject_fake_metaclass_for($name)}}sub inject_fake_metaclass_for {my ($name)=@_;require Class::MOP;require Moo::HandleMoose::FakeMetaClass;Class::MOP::store_metaclass_by_name($name,bless({name=>$name },'Moo::HandleMoose::FakeMetaClass'));require Moose::Util::TypeConstraints;if ($Moo::Role::INFO{$name}){Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name)}else {Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name)}}{package Moo::HandleMoose::FakeConstructor;sub _uninlined_body {\&Moose::Object::new}}sub inject_real_metaclass_for {my ($name)=@_;our%DID_INJECT;return Class::MOP::get_metaclass_by_name($name)if$DID_INJECT{$name};require Moose;require Moo;require Moo::Role;require Scalar::Util;Class::MOP::remove_metaclass_by_name($name);my ($am_role,$meta,$attr_specs,$attr_order)=do {if (my$info=$Moo::Role::INFO{$name}){my@attr_info=@{$info->{attributes}||[]};(1,Moose::Meta::Role->initialize($name),{@attr_info },[@attr_info[grep!($_ % 2),0..$#attr_info]])}elsif (my$cmaker=Moo->_constructor_maker_for($name)){my$specs=$cmaker->all_attribute_specs;(0,Moose::Meta::Class->initialize($name),$specs,[sort {$specs->{$a}{index}<=> $specs->{$b}{index}}keys %$specs ])}else {(0,Moose::Meta::Class->initialize($name),{},[])}};for my$spec (values %$attr_specs){if (my$inflators=delete$spec->{moosify}){$_->($spec)for @$inflators}}my%methods=%{Role::Tiny->_concrete_methods_of($name)};if (my$info=$Role::Tiny::INFO{$name}){delete$info->{methods}}Sub::Defer::undefer_sub($_)for grep defined,values%methods;my@attrs;{local @{_getstash($name)}{keys%methods};my%seen_name;for my$name (@$attr_order){$seen_name{$name}=1;my%spec=%{$attr_specs->{$name}};my%spec_map=(map {$_->name=>$_->init_arg||$_->name}((grep {$_->has_init_arg}$meta->attribute_metaclass->meta->get_all_attributes),grep {exists($_->{init_arg})? defined($_->init_arg): 1}map {my$meta=Moose::Util::resolve_metatrait_alias('Attribute',$_)->meta;map$meta->get_attribute($_),$meta->get_attribute_list}@{$spec{traits}||[]}));$spec_map{traits}||='traits';$spec{is}='ro' if$spec{is}eq 'lazy' or $spec{is}eq 'rwp';my$coerce=$spec{coerce};if (my$isa=$spec{isa}){my$tc=$spec{isa}=do {if (my$mapped=$TYPE_MAP{$isa}){my$type=$mapped->();Scalar::Util::blessed($type)&& $type->isa("Moose::Meta::TypeConstraint")or die "error inflating attribute '$name' for package '$_[0]': \$TYPE_MAP{$isa} did not return a valid type constraint'";$coerce ? $type->create_child_type(name=>$type->name): $type}else {Moose::Meta::TypeConstraint->new(constraint=>sub {eval {&$isa;1}})}};if ($coerce){$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{coerce}=1}}elsif ($coerce){my$attr=perlstring($name);my$tc=Moose::Meta::TypeConstraint->new(constraint=>sub {die "This is not going to work"},inlined=>sub {'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'},);$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{isa}=$tc;$spec{coerce}=1}%spec=map {$spec_map{$_}=>$spec{$_}}grep {exists$spec_map{$_}}keys%spec;push@attrs,$meta->add_attribute($name=>%spec)}for my$mouse (do {our%MOUSE;@{$MOUSE{$name}||[]}}){for my$attr ($mouse->get_all_attributes){my%spec=%{$attr};delete@spec{qw(associated_class associated_methods __METACLASS__ provides curries)};my$name=delete$spec{name};next if$seen_name{$name}++;push@attrs,$meta->add_attribute($name=>%spec)}}}for my$meth_name (keys%methods){my$meth_code=$methods{$meth_name};$meta->add_method($meth_name,$meth_code)if$meth_code}if ($am_role){my$info=$Moo::Role::INFO{$name};$meta->add_required_methods(@{$info->{requires}});for my$modifier (@{$info->{modifiers}}){my ($type,@args)=@$modifier;my$code=pop@args;$meta->${\"add_${type}_method_modifier"}($_,$code)for@args}}else {for my$attr (@attrs){for my$method (@{$attr->associated_methods}){$method->{body}=$name->can($method->name)}}bless($meta->find_method_by_name('new'),'Moo::HandleMoose::FakeConstructor',);require Method::Generate::DemolishAll}$meta->add_role(Class::MOP::class_of($_))for grep!/\|/ && $_ ne $name,do {no warnings 'once';keys %{$Role::Tiny::APPLIED_TO{$name}}};$DID_INJECT{$name}=1;$meta}1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;sub DESTROY {}sub AUTOLOAD {my ($meth)=(our$AUTOLOAD =~ /([^:]+)$/);require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->$meth(@_)}sub can {require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->can(@_)}sub isa {require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->isa(@_)}sub make_immutable {$_[0]}1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;use strictures 1;our%NO_BUILD;our%NO_DEMOLISH;our$BUILD_MAKER;our$DEMOLISH_MAKER;sub new {my$class=shift;unless (exists$NO_DEMOLISH{$class}){unless ($NO_DEMOLISH{$class}=!$class->can('DEMOLISH')){($DEMOLISH_MAKER ||=do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method($class)}}$NO_BUILD{$class}and return bless({ref($_[0])eq 'HASH' ? %{$_[0]}: @_},$class);$NO_BUILD{$class}=!$class->can('BUILD')unless exists$NO_BUILD{$class};$NO_BUILD{$class}? bless({ref($_[0])eq 'HASH' ? %{$_[0]}: @_},$class): do {my$proto=ref($_[0])eq 'HASH' ? $_[0]: {@_};bless({%$proto},$class)->BUILDALL($proto)}}sub BUILDARGS {my$class=shift;if (scalar @_==1){unless (defined $_[0]&& ref $_[0]eq 'HASH'){die "Single parameters to new() must be a HASH ref" ." data => ".$_[0]."\n"}return {%{$_[0]}}}elsif (@_ % 2){die "The new() method for $class expects a hash reference or a key/value list." ." You passed an odd number of arguments\n"}else {return {@_}}}sub BUILDALL {my$self=shift;$self->${\(($BUILD_MAKER ||=do {require Method::Generate::BuildAll;Method::Generate::BuildAll->new})->generate_method(ref($self)))}(@_)}sub DEMOLISHALL {my$self=shift;$self->${\(($DEMOLISH_MAKER ||=do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method(ref($self)))}(@_)}sub does {require Role::Tiny;{no warnings 'redefine';*does=\&Role::Tiny::does_role}goto&Role::Tiny::does_role}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;use strictures 1;use Moo::_Utils;use Role::Tiny ();use base qw(Role::Tiny);our$VERSION='1.003001';$VERSION=eval$VERSION;require Moo::sification;BEGIN {*INFO=\%Role::Tiny::INFO}our%INFO;our%APPLY_DEFAULTS;sub _install_tracked {my ($target,$name,$code)=@_;$INFO{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::Role::${name}"=>$code}sub import {my$target=caller;my ($me)=@_;strictures->import;if ($Moo::MAKERS{$target}and $Moo::MAKERS{$target}{is_class}){die "Cannot import Moo::Role into a Moo class"}$INFO{$target}||={};my$stash=_getstash($target);_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){require Carp;Carp::croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;($INFO{$target}{accessor_maker}||=do {require Method::Generate::Accessor;Method::Generate::Accessor->new})->generate_method($target,$name,$spec_ref);push @{$INFO{$target}{attributes}||=[]},$name,$spec_ref;$me->_maybe_reset_handlemoose($target)}};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {require Class::Method::Modifiers;push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];$me->_maybe_reset_handlemoose($target)}}_install_tracked$target=>requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;$me->_maybe_reset_handlemoose($target)};_install_tracked$target=>with=>sub {$me->apply_roles_to_package($target,@_);$me->_maybe_reset_handlemoose($target)};return if$INFO{$target}{is_role};$INFO{$target}{is_role}=1;*{_getglob("${target}::meta")}=$me->can('meta');my@not_methods=('',map {*$_{CODE}||()}grep!ref($_),values %$stash);@{$INFO{$target}{not_methods}={}}{@not_methods}=@not_methods;$Role::Tiny::APPLIED_TO{$target}={$target=>undef };if ($INC{'Moo/HandleMoose.pm'}){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}sub unimport {my$target=caller;_unimport_coderefs($target,$INFO{$target})}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{"Moo/HandleMoose.pm"}){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _inhale_if_moose {my ($self,$role)=@_;_load_module($role);my$meta;if (!$INFO{$role}and ($INC{"Moose.pm"}and $meta=Class::MOP::class_of($role)and $meta->isa('Moose::Meta::Role'))or (Mouse::Util->can('find_meta')and $meta=Mouse::Util::find_meta($role)and $meta->isa('Mouse::Meta::Role'))){$INFO{$role}{methods}={map +($_=>$role->can($_)),grep!$meta->get_method($_)->isa('Class::MOP::Method::Meta'),$meta->get_method_list };$Role::Tiny::APPLIED_TO{$role}={map +($_->name=>1),$meta->calculate_all_roles };$INFO{$role}{requires}=[$meta->get_required_method_list ];$INFO{$role}{attributes}=[map +($_=>do {my$attr=$meta->get_attribute($_);my$is_mouse=$meta->isa('Mouse::Meta::Role');my$spec={%{$is_mouse ? $attr : $attr->original_options}};if ($spec->{isa}){my$get_constraint=do {my$pkg=$is_mouse ? 'Mouse::Util::TypeConstraints' : 'Moose::Util::TypeConstraints';_load_module($pkg);$pkg->can('find_or_create_isa_type_constraint')};my$tc=$get_constraint->($spec->{isa});my$check=$tc->_compiled_type_constraint;$spec->{isa}=sub {&$check or die "Type constraint failed for $_[0]"};if ($spec->{coerce}){$spec->{coerce}=$tc->${\($tc->can('coercion')||sub {$_[0]})}->_compiled_type_coercion}}$spec}),$meta->get_attribute_list ];my$mods=$INFO{$role}{modifiers}=[];for my$type (qw(before after around)){my$map=$meta->${\($meta->can("get_${type}_method_modifiers_map")or sub {shift->{"${type}_method_modifiers"}})};for my$method (keys %$map){for my$mod (@{$map->{$method}}){push @$mods,[$type=>$method=>$mod ]}}}require Class::Method::Modifiers if @$mods;$INFO{$role}{inhaled_from_moose}=1;$INFO{$role}{is_role}=1}}sub _maybe_make_accessors {my ($self,$target,$role)=@_;my$m;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}or $INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($target)and ref($m)ne 'Method::Generate::Accessor'){$self->_make_accessors($target,$role)}}sub _make_accessors_if_moose {my ($self,$target,$role)=@_;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}){$self->_make_accessors($target,$role)}}sub _make_accessors {my ($self,$target,$role)=@_;my$acc_gen=($Moo::MAKERS{$target}{accessor}||=do {require Method::Generate::Accessor;Method::Generate::Accessor->new});my$con_gen=$Moo::MAKERS{$target}{constructor};my@attrs=@{$INFO{$role}{attributes}||[]};while (my ($name,$spec)=splice@attrs,0,2){if ($con_gen){$spec=$con_gen->all_attribute_specs->{$name}}$acc_gen->generate_method($target,$name,$spec)}}sub role_application_steps {qw(_handle_constructor _maybe_make_accessors),$_[0]->SUPER::role_application_steps}sub apply_roles_to_package {my ($me,$to,@roles)=@_;for my$role (@roles){$me->_inhale_if_moose($role);die "${role} is not a Moo::Role" unless$INFO{$role}}$me->SUPER::apply_roles_to_package($to,@roles)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;$me->_inhale_if_moose($role);die "${role} is not a Moo::Role" unless$INFO{$role};$me->SUPER::apply_single_role_to_package($to,$role)}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$Role::Tiny::COMPOSED{class}{$new_name};for my$role (@roles){$me->_inhale_if_moose($role)}my$m;if ($INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($superclass)and ref($m)ne 'Method::Generate::Accessor'){*{_getglob("${new_name}::ISA")}=[$superclass ];$me->apply_roles_to_package($new_name,@roles);return$new_name}require Sub::Quote;$me->SUPER::create_class_with_roles($superclass,@roles);for my$role (@roles){die "${role} is not a Role::Tiny" unless$INFO{$role}}$Moo::MAKERS{$new_name}={is_class=>1};$me->_handle_constructor($new_name,$_)for@roles;return$new_name}sub apply_roles_to_object {my ($me,$object,@roles)=@_;my$new=$me->SUPER::apply_roles_to_object($object,@roles);my$apply_defaults=$APPLY_DEFAULTS{ref$new}||=do {my%attrs=map {@{$INFO{$_}{attributes}||[]}}@roles;if ($INC{'Moo.pm'}and keys%attrs and my$con_gen=Moo->_constructor_maker_for(ref$new)and my$m=Moo->_accessor_maker_for(ref$new)){require Sub::Quote;my$specs=$con_gen->all_attribute_specs;my$assign='';my%captures;for my$name (keys%attrs){my$spec=$specs->{$name};if ($m->has_eager_default($name,$spec)){my ($has,$has_cap)=$m->generate_simple_has('$_[0]',$name,$spec);my ($code,$pop_cap)=$m->generate_use_default('$_[0]',$name,$spec,$has);$assign .= $code;@captures{keys %$has_cap,keys %$pop_cap}=(values %$has_cap,values %$pop_cap)}}Sub::Quote::quote_sub($assign,\%captures)}else {sub {}}};$new->$apply_defaults;return$new}sub _composable_package_for {my ($self,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$Role::Tiny::COMPOSED{role}{$composed_name};$self->_make_accessors_if_moose($composed_name,$role);$self->SUPER::_composable_package_for($role)}sub _install_single_modifier {my ($me,@args)=@_;_install_modifier(@args)}sub _handle_constructor {my ($me,$to,$role)=@_;my$attr_info=$INFO{$role}&& $INFO{$role}{attributes};return unless$attr_info && @$attr_info;if ($INFO{$to}){push @{$INFO{$to}{attributes}||=[]},@$attr_info}else {if ($INC{"Moo.pm"}and my$con=Moo->_constructor_maker_for($to)){$con->register_attribute_specs(map ref()? {%$_}: $_,@$attr_info)}}}1;
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;no warnings 'once';sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}use constant lt_5_8_3=>($] < 5.008003 or $ENV{MOO_TEST_PRE_583})? 1 : 0;use constant can_haz_subname=>eval {require Sub::Name};use strictures 1;use Module::Runtime qw(require_module);use Devel::GlobalDestruction ();use base qw(Exporter);use Moo::_mro;our@EXPORT=qw(_getglob _install_modifier _load_module _maybe_load_module _get_linear_isa _getstash _install_coderef _name_coderef _unimport_coderefs _in_global_destruction);sub _in_global_destruction ();*_in_global_destruction=\&Devel::GlobalDestruction::in_global_destruction;sub _install_modifier {my ($into,$type,$name,$code)=@_;if (my$to_modify=$into->can($name)){require Sub::Defer;Sub::Defer::undefer_sub($to_modify)}Class::Method::Modifiers::install_modifier(@_)}our%MAYBE_LOADED;sub _load_module {(my$proto=$_[0])=~ s/::/\//g;return 1 if$INC{"${proto}.pm"};my$stash=_getstash($_[0])||{};return 1 if grep +(!ref($_)and *$_{CODE}),values %$stash;require_module($_[0]);return 1}sub _maybe_load_module {return$MAYBE_LOADED{$_[0]}if exists$MAYBE_LOADED{$_[0]};(my$proto=$_[0])=~ s/::/\//g;local $@;if (eval {require "${proto}.pm";1}){$MAYBE_LOADED{$_[0]}=1}else {if (exists$INC{"${proto}.pm"}){warn "$_[0] exists but failed to load with error: $@"}$MAYBE_LOADED{$_[0]}=0}return$MAYBE_LOADED{$_[0]}}sub _get_linear_isa {return mro::get_linear_isa($_[0])}sub _install_coderef {no warnings 'redefine';*{_getglob($_[0])}=_name_coderef(@_)}sub _name_coderef {shift if @_ > 2;can_haz_subname ? Sub::Name::subname(@_): $_[1]}sub _unimport_coderefs {my ($target,$info)=@_;return unless$info and my$exports=$info->{exports};my%rev=reverse %$exports;my$stash=_getstash($target);for my$name (keys %$exports){if ($stash->{$name}and defined(&{$stash->{$name}})){if ($rev{$target->can($name)}){my$old=delete$stash->{$name};my$full_name=join('::',$target,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});no strict 'refs';*$full_name=*{$old}{$type}}}}}}sub STANDARD_DESTROY {my$self=shift;my$e=do {local $?;local $@;eval {$self->DEMOLISHALL(_in_global_destruction)};$@};no warnings 'misc';die$e if$e}1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;if ($] >= 5.010){require mro}else {require MRO::Compat}1;
MOO__MRO

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;use strictures 1;use Moo::_Utils ();sub unimport {our$disarmed=1}sub Moo::HandleMoose::AuthorityHack::DESTROY {unless (our$disarmed or Moo::_Utils::_in_global_destruction){require Moo::HandleMoose;Moo::HandleMoose->import}}if ($INC{"Moose.pm"}){require Moo::HandleMoose;Moo::HandleMoose->import}else {$Moose::AUTHORITY=bless({},'Moo::HandleMoose::AuthorityHack')}1;
MOO_SIFICATION

$fatpacked{"Reply/Plugin/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REPLY_PLUGIN_TYPETINY';
  package Reply::Plugin::TypeTiny;use strict;use warnings;BEGIN {$Reply::Plugin::TypeTiny::AUTHORITY='cpan:TOBYINK';$Reply::Plugin::TypeTiny::VERSION='0.034'};require Reply::Plugin;our@ISA='Reply::Plugin';use Scalar::Util qw(blessed);use Term::ANSIColor;sub mangle_error {my$self=shift;my ($err)=@_;if (blessed$err and $err->isa("Error::TypeTiny::Assertion")){my$explain=$err->explain;if ($explain){print color("cyan");print "Error::TypeTiny::Assertion explain:\n";$self->_explanation($explain,"");local $|=1;print "\n";print color("reset")}}return @_}sub _explanation {my$self=shift;my ($ex,$indent)=@_;for my$line (@$ex){if (ref($line)eq q(ARRAY)){print "$indent * Explain:\n";$self->_explanation($line,"$indent   ")}else {print "$indent * $line\n"}}}1;
REPLY_PLUGIN_TYPETINY

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}use strict;use warnings FATAL=>'all';our$VERSION='1.003002';$VERSION=eval$VERSION;our%INFO;our%APPLIED_TO;our%COMPOSED;our%COMPOSITE_INFO;BEGIN {*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}sub Role::Tiny::__GUARD__::DESTROY {delete$INC{$_[0]->[0]}if @{$_[0]}}sub _load_module {(my$proto=$_[0])=~ s/::/\//g;$proto .= '.pm';return 1 if$INC{$proto};return 1 if grep!/::$/,keys %{_getstash($_[0])||{}};my$guard=_WORK_AROUND_BROKEN_MODULE_STATE && bless([$proto ],'Role::Tiny::__GUARD__');require$proto;pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;return 1}sub import {my$target=caller;my$me=shift;strict->import;warnings->import(FATAL=>'all');return if$INFO{$target};$INFO{$target}{is_role}=1;my$stash=_getstash($target);for my$type (qw(before after around)){*{_getglob "${target}::${type}"}=sub {require Class::Method::Modifiers;push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];return}}*{_getglob "${target}::requires"}=sub {push @{$INFO{$target}{requires}||=[]},@_;return};*{_getglob "${target}::with"}=sub {$me->apply_roles_to_package($target,@_);return};my@not_methods=(map {*$_{CODE}||()}grep!ref($_),values %$stash);@{$INFO{$target}{not_methods}={}}{@not_methods}=@not_methods;$APPLIED_TO{$target}={$target=>undef }}sub role_application_steps {qw(_install_methods _check_requires _install_modifiers _copy_applied_list)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);die "This is apply_role_to_package" if ref($to);die "${role} is not a Role::Tiny" unless$INFO{$role};for my$step ($me->role_application_steps){$me->$step($to,$role)}}sub _copy_applied_list {my ($me,$to,$role)=@_;@{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}}=()}sub apply_roles_to_object {my ($me,$object,@roles)=@_;die "No roles supplied!" unless@roles;my$class=ref($object);bless($object,$me->create_class_with_roles($class,@roles));$object}my$role_suffix='A000';sub _composite_name {my ($me,$superclass,@roles)=@_;my$new_name=join('__WITH__',$superclass,my$compose_name=join '__AND__',@roles);if (length($new_name)> 252){$new_name=$COMPOSED{abbrev}{$new_name}||=substr($new_name,0,250 - length$role_suffix).'__'.$role_suffix++}return wantarray ? ($new_name,$compose_name): $new_name}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;die "No roles supplied!" unless@roles;_load_module($superclass);{my%seen;$seen{$_}++ for@roles;if (my@dupes=grep$seen{$_}> 1,@roles){die "Duplicated roles: ".join(', ',@dupes)}}my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);die "${role} is not a Role::Tiny" unless$INFO{$role}}if ($] >= 5.010){require mro}else {require MRO::Compat}my$composite_info=$me->_composite_info_for(@roles);my%conflicts=%{$composite_info->{conflicts}};if (keys%conflicts){my$fail=join "\n",map {"Method name conflict for '$_' between roles " ."'".join(' and ',sort values %{$conflicts{$_}})."'" .", cannot apply these simultaneously to an object."}keys%conflicts;die$fail}my@composable=map$me->_composable_package_for($_),reverse@roles;my@requires=grep {my$method=$_;!grep $_->can($method)&&!$COMPOSED{role}{$_}{modifiers_only}{$method},@composable}@{$composite_info->{requires}};$me->_check_requires($superclass,$compose_name,\@requires);*{_getglob("${new_name}::ISA")}=[@composable,$superclass ];@{$APPLIED_TO{$new_name}||={}}{map keys %{$APPLIED_TO{$_}},@roles }=();$COMPOSED{class}{$new_name}=1;return$new_name}sub apply_role_to_package {shift->apply_single_role_to_package(@_)}sub apply_roles_to_package {my ($me,$to,@roles)=@_;return$me->apply_role_to_package($to,$roles[0])if@roles==1;my%conflicts=%{$me->_composite_info_for(@roles)->{conflicts}};delete$conflicts{$_}for keys %{$me->_concrete_methods_of($to)};if (keys%conflicts){my$fail=join "\n",map {"Due to a method name conflict between roles " ."'".join(' and ',sort values %{$conflicts{$_}})."'" .", the method '$_' must be implemented by '${to}'"}keys%conflicts;die$fail}if ($INFO{$to}){delete$INFO{$to}{methods}}our%BACKCOMPAT_HACK;if($me ne __PACKAGE__ and exists$BACKCOMPAT_HACK{$me}? $BACKCOMPAT_HACK{$me}: $BACKCOMPAT_HACK{$me}=$me->can('role_application_steps')==\&role_application_steps && $me->can('apply_single_role_to_package')!=\&apply_single_role_to_package){for my$role (@roles){$me->apply_single_role_to_package($to,$role)}}else {for my$step ($me->role_application_steps){for my$role (@roles){$me->$step($to,$role)}}}$APPLIED_TO{$to}{join('|',@roles)}=1}sub _composite_info_for {my ($me,@roles)=@_;$COMPOSITE_INFO{join('|',sort@roles)}||=do {for my$role (@roles){_load_module($role)}my%methods;for my$role (@roles){my$this_methods=$me->_concrete_methods_of($role);$methods{$_}{$this_methods->{$_}}=$role for keys %$this_methods}my%requires;@requires{map @{$INFO{$_}{requires}||[]},@roles}=();delete$requires{$_}for keys%methods;delete$methods{$_}for grep keys(%{$methods{$_}})==1,keys%methods;+{conflicts=>\%methods,requires=>[keys%requires]}}}sub _composable_package_for {my ($me,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$COMPOSED{role}{$composed_name};$me->_install_methods($composed_name,$role);my$base_name=$composed_name.'::_BASE';_getstash($base_name);{no strict 'refs';@{"${composed_name}::ISA"}=($base_name)}my$modifiers=$INFO{$role}{modifiers}||[];my@mod_base;my@modifiers=grep!$composed_name->can($_),do {my%h;@h{map @{$_}[1..$#$_-1],@$modifiers}=();keys%h};for my$modified (@modifiers){push@mod_base,"sub ${modified} { shift->next::method(\@_) }"}my$e;{local $@;eval(my$code=join "\n","package ${base_name};",@mod_base);$e="Evaling failed: $@\nTrying to eval:\n${code}" if $@}die$e if$e;$me->_install_modifiers($composed_name,$role);$COMPOSED{role}{$composed_name}={modifiers_only=>{map {$_=>1}@modifiers },};return$composed_name}sub _check_requires {my ($me,$to,$name,$requires)=@_;return unless my@requires=@{$requires||$INFO{$name}{requires}||[]};if (my@requires_fail=grep!$to->can($_),@requires){if (my$to_info=$INFO{$to}){push @{$to_info->{requires}||=[]},@requires_fail}else {die "Can't apply ${name} to ${to} - missing ".join(', ',@requires_fail)}}}sub _concrete_methods_of {my ($me,$role)=@_;my$info=$INFO{$role};my$stash=_getstash($role);my$not_methods={reverse %{$info->{not_methods}||{}}};$info->{methods}||=+{map {my$code=*{$stash->{$_}}{CODE};(!$code or exists$not_methods->{$code})? (): ($_=>$code)}grep!ref($stash->{$_}),keys %$stash }}sub methods_provided_by {my ($me,$role)=@_;die "${role} is not a Role::Tiny" unless my$info=$INFO{$role};(keys %{$me->_concrete_methods_of($role)},@{$info->{requires}||[]})}sub _install_methods {my ($me,$to,$role)=@_;my$info=$INFO{$role};my$methods=$me->_concrete_methods_of($role);my$stash=_getstash($to);my%has_methods;@has_methods{grep +(ref($stash->{$_})|| *{$stash->{$_}}{CODE}),keys %$stash }=();for my$i (grep!exists$has_methods{$_},keys %$methods){no warnings 'once';*{_getglob "${to}::${i}"}=$methods->{$i}}$me->_install_does($to)}sub _install_modifiers {my ($me,$to,$name)=@_;return unless my$modifiers=$INFO{$name}{modifiers};if (my$info=$INFO{$to}){push @{$info->{modifiers}},@{$modifiers||[]}}else {for my$modifier (@{$modifiers||[]}){$me->_install_single_modifier($to,@$modifier)}}}my$vcheck_error;sub _install_single_modifier {my ($me,@args)=@_;defined($vcheck_error)or $vcheck_error=do {local $@;eval {Class::Method::Modifiers->VERSION(1.05);1}? 0 : $@};$vcheck_error and die$vcheck_error;Class::Method::Modifiers::install_modifier(@args)}my$FALLBACK=sub {0};sub _install_does {my ($me,$to)=@_;return if$INFO{$to};*{_getglob "${to}::does"}=\&does_role unless$to->can('does');return if ($to->can('DOES')and $to->can('DOES')!=(UNIVERSAL->can('DOES')|| 0));my$existing=$to->can('DOES')|| $to->can('isa')|| $FALLBACK;my$new_sub=sub {my ($proto,$role)=@_;Role::Tiny::does_role($proto,$role)or $proto->$existing($role)};no warnings 'redefine';*{_getglob "${to}::DOES"}=$new_sub}sub does_role {my ($proto,$role)=@_;if ($] >= 5.010){require mro}else {require MRO::Compat}for my$class (@{mro::get_linear_isa(ref($proto)||$proto)}){return 1 if exists$APPLIED_TO{$class}{$role}}return 0}sub is_role {my ($me,$role)=@_;return!!$INFO{$role}}1;
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;use strict;use warnings FATAL=>'all';use Role::Tiny ();use Exporter 'import';our@EXPORT=qw(with);sub with {my$target=caller;Role::Tiny->apply_roles_to_package($target,@_)}1;
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;use strictures 1;use base qw(Exporter);use Moo::_Utils;use Scalar::Util qw(weaken);our$VERSION='1.003001';$VERSION=eval$VERSION;our@EXPORT=qw(defer_sub undefer_sub);our%DEFERRED;sub undefer_sub {my ($deferred)=@_;my ($target,$maker,$undeferred_ref)=@{$DEFERRED{$deferred}||return$deferred};return ${$undeferred_ref}if ${$undeferred_ref};${$undeferred_ref}=my$made=$maker->();if (defined($target)&& $deferred eq *{_getglob($target)}{CODE}||''){no warnings 'redefine';*{_getglob($target)}=$made}weaken($DEFERRED{$made}=$DEFERRED{$deferred});return$made}sub defer_info {my ($deferred)=@_;$DEFERRED{$deferred||''}}sub defer_sub {my ($target,$maker)=@_;my$undeferred;my$deferred_info;my$deferred=sub {$undeferred ||=undefer_sub($deferred_info->[3]);goto &$undeferred};$deferred_info=[$target,$maker,\$undeferred,$deferred ];weaken($DEFERRED{$deferred}=$deferred_info);_install_coderef($target=>$deferred)if defined$target;return$deferred}sub CLONE {%DEFERRED=map {defined $_ ? ($_->[3]=>$_): ()}values%DEFERRED;weaken($_)for values%DEFERRED}1;
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;use strict;use warnings;our$VERSION='0.001011';use Carp ();use List::Util ();sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (List::Util::first {ref ||!m/ \A [:-]? \w+ \z /xm}@args){Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||=Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined(my$num=List::Util::first {!ref and m/^\d/}@args)){die "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if ($setup eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){Carp::croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};Carp::croak$too_complicated if List::Util::first {ref}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){Carp::croak$too_complicated if List::Util::first {/ \A - (?! all \b ) /x || ref}@{$tagset}}@defaults=@{$tags{default}|| []}}else {Carp::croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||=[@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;Carp::croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;use strictures 1;sub _clean_eval {eval $_[0]}use Sub::Defer;use B 'perlstring';use Scalar::Util qw(weaken);use base qw(Exporter);our$VERSION='1.003001';$VERSION=eval$VERSION;our@EXPORT=qw(quote_sub unquote_sub quoted_from_sub);our%QUOTED;our%WEAK_REFS;sub capture_unroll {my ($from,$captures,$indent)=@_;join('',map {/^([\@\%\$])/ or die "capture key should start with \@, \% or \$: $_";(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n}}keys %$captures)}sub inlinify {my ($code,$args,$extra,$local)=@_;my$do='do { '.($extra||'');if (my ($code_args,$body)=$code =~ / +my \(([^)]+)\) = \@_;(.*)$/s){if ($code_args eq $args){$do.$body.' }'}else {$do.'my ('.$code_args.') = ('.$args.'); '.$body.' }'}}else {my$assign='';if ($local || $args ne '@_'){$assign=($local ? 'local ' : '').'@_ = ('.$args.'); '}$do.$assign.$code.' }'}}sub quote_sub {my$options=(ref($_[-1])eq 'HASH' and ref($_[-2])eq 'HASH')? pop : {};my$captures=pop if ref($_[-1])eq 'HASH';undef($captures)if$captures &&!keys %$captures;my$code=pop;my$name=$_[0];my$quoted_info;my$deferred=defer_sub +($options->{no_install}? undef : $name)=>sub {unquote_sub($quoted_info->[4])};$quoted_info=[$name,$code,$captures,undef,$deferred ];weaken($QUOTED{$deferred}=$quoted_info);return$deferred}sub quoted_from_sub {my ($sub)=@_;$QUOTED{$sub||''}}sub unquote_sub {my ($sub)=@_;unless ($QUOTED{$sub}[3]){my ($name,$code,$captures)=@{$QUOTED{$sub}};my$make_sub="{\n";my%captures=$captures ? %$captures : ();$captures{'$_QUOTED'}=\$QUOTED{$sub};$make_sub .= capture_unroll("\$_[1]",\%captures,2);$make_sub .= ($name ? "  no warnings 'closure';\n  sub ${name} {\n" : "  \$_QUOTED->[3] = sub {\n");$make_sub .= $code;$make_sub .= "  }".($name ? '' : ';')."\n";if ($name){$make_sub .= "  \$_QUOTED->[3] = \\&${name}\n"}$make_sub .= "}\n1;\n";$ENV{SUB_QUOTE_DEBUG}&& warn$make_sub;{local $@;no strict 'refs';local *{$name}if$name;unless (_clean_eval$make_sub,\%captures){die "Eval went very, very wrong:\n\n${make_sub}\n\n$@"}}}$QUOTED{$sub}[3]}sub CLONE {%QUOTED=map {defined $_ ? ($_->[4]=>$_): ()}values%QUOTED;weaken($_)for values%QUOTED}1;
SUB_QUOTE

$fatpacked{"Term/ANSIColor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_ANSICOLOR';
  package Term::ANSIColor;use 5.006;use strict;use warnings;use Carp qw(croak);use Exporter ();our (@EXPORT,@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION);our$AUTOLOAD;BEGIN {$VERSION='4.02';my@colorlist=qw(CLEAR RESET BOLD DARK FAINT ITALIC UNDERLINE UNDERSCORE BLINK REVERSE CONCEALED BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE ON_BLACK ON_RED ON_GREEN ON_YELLOW ON_BLUE ON_MAGENTA ON_CYAN ON_WHITE BRIGHT_BLACK BRIGHT_RED BRIGHT_GREEN BRIGHT_YELLOW BRIGHT_BLUE BRIGHT_MAGENTA BRIGHT_CYAN BRIGHT_WHITE ON_BRIGHT_BLACK ON_BRIGHT_RED ON_BRIGHT_GREEN ON_BRIGHT_YELLOW ON_BRIGHT_BLUE ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN ON_BRIGHT_WHITE);my@colorlist256=((map {("ANSI$_","ON_ANSI$_")}0 .. 15),(map {("GREY$_","ON_GREY$_")}0 .. 23),);for my$r (0 .. 5){for my$g (0 .. 5){push@colorlist256,map {("RGB$r$g$_","ON_RGB$r$g$_")}0 .. 5}}@ISA=qw(Exporter);@EXPORT=qw(color colored);@EXPORT_OK=qw(uncolor colorstrip colorvalid coloralias);%EXPORT_TAGS=(constants=>\@colorlist,constants256=>\@colorlist256,pushpop=>[@colorlist,qw(PUSHCOLOR POPCOLOR LOCALCOLOR)],);Exporter::export_ok_tags('pushpop','constants256')}our$AUTOLOCAL;our$AUTORESET;our$EACHLINE;our%ATTRIBUTES=('clear'=>0,'reset'=>0,'bold'=>1,'dark'=>2,'faint'=>2,'italic'=>3,'underline'=>4,'underscore'=>4,'blink'=>5,'reverse'=>7,'concealed'=>8,'black'=>30,'on_black'=>40,'red'=>31,'on_red'=>41,'green'=>32,'on_green'=>42,'yellow'=>33,'on_yellow'=>43,'blue'=>34,'on_blue'=>44,'magenta'=>35,'on_magenta'=>45,'cyan'=>36,'on_cyan'=>46,'white'=>37,'on_white'=>47,'bright_black'=>90,'on_bright_black'=>100,'bright_red'=>91,'on_bright_red'=>101,'bright_green'=>92,'on_bright_green'=>102,'bright_yellow'=>93,'on_bright_yellow'=>103,'bright_blue'=>94,'on_bright_blue'=>104,'bright_magenta'=>95,'on_bright_magenta'=>105,'bright_cyan'=>96,'on_bright_cyan'=>106,'bright_white'=>97,'on_bright_white'=>107,);for my$code (0 .. 15){$ATTRIBUTES{"ansi$code"}="38;5;$code";$ATTRIBUTES{"on_ansi$code"}="48;5;$code"}for my$r (0 .. 5){for my$g (0 .. 5){for my$b (0 .. 5){my$code=16 + (6 * 6 * $r)+ (6 * $g)+ $b;$ATTRIBUTES{"rgb$r$g$b"}="38;5;$code";$ATTRIBUTES{"on_rgb$r$g$b"}="48;5;$code"}}}for my$n (0 .. 23){my$code=$n + 232;$ATTRIBUTES{"grey$n"}="38;5;$code";$ATTRIBUTES{"on_grey$n"}="48;5;$code"}our%ATTRIBUTES_R;for my$attr (reverse sort keys%ATTRIBUTES){$ATTRIBUTES_R{$ATTRIBUTES{$attr}}=$attr}our%ALIASES;if (exists$ENV{ANSI_COLORS_ALIASES}){my$spec=$ENV{ANSI_COLORS_ALIASES};$spec =~ s{\s+}{}xmsg;for my$definition (split m{,}xms,$spec){my ($new,$old)=split m{=}xms,$definition,2;if (!$new ||!$old){warn qq{Bad color mapping "$definition"}}else {my$result=eval {coloralias($new,$old)};if (!$result){my$error=$@;$error =~ s{ [ ] at [ ] .* }{}xms;warn qq{$error in "$definition"}}}}}our@COLORSTACK;sub AUTOLOAD {my ($sub,$attr)=$AUTOLOAD =~ m{ \A ([\w:]*::([[:upper:]\d_]+)) \z }xms;if (!$attr ||!defined$ATTRIBUTES{lc$attr }){croak("undefined subroutine &$AUTOLOAD called")}if ($ENV{ANSI_COLORS_DISABLED}){return join q{},@_}$AUTOLOAD=$sub;my$escape="\e[" .$ATTRIBUTES{lc$attr }.'m';my$eval_err=$@;my$eval_result=eval qq{
          sub $AUTOLOAD {
              if (\$ENV{ANSI_COLORS_DISABLED}) {
                  return join q{}, \@_;
              } elsif (\$AUTOLOCAL && \@_) {
                  return PUSHCOLOR('$escape') . join(q{}, \@_) . POPCOLOR;
              } elsif (\$AUTORESET && \@_) {
                  return '$escape' . join(q{}, \@_) . "\e[0m";
              } else {
                  return '$escape' . join q{}, \@_;
              }
          }
          1;
      };if (!$eval_result){die "failed to generate constant $attr: $@"}$@=$eval_err;goto &$AUTOLOAD}sub PUSHCOLOR {my (@text)=@_;my$text=join q{},@text;my ($color)=$text =~ m{ \A ( (?:\e\[ [\d;]+ m)+ ) }xms;if (@COLORSTACK){$color=$COLORSTACK[-1].$color}push@COLORSTACK,$color;return$text}sub POPCOLOR {my (@text)=@_;pop@COLORSTACK;if (@COLORSTACK){return$COLORSTACK[-1].join q{},@text}else {return RESET(@text)}}sub LOCALCOLOR {my (@text)=@_;return PUSHCOLOR(join q{},@text).POPCOLOR()}sub color {my (@codes)=@_;@codes=map {split}@codes;if ($ENV{ANSI_COLORS_DISABLED}){return q{}}my$attribute=q{};for my$code (@codes){$code=lc$code;if (defined$ATTRIBUTES{$code}){$attribute .= $ATTRIBUTES{$code}.q{;}}elsif (defined$ALIASES{$code}){$attribute .= $ALIASES{$code}.q{;}}else {croak("Invalid attribute name $code")}}chop$attribute;return ($attribute ne q{})? "\e[${attribute}m" : undef}sub uncolor {my (@escapes)=@_;my (@nums,@result);for my$escape (@escapes){$escape =~ s{ \A \e\[ }{}xms;$escape =~ s{ m \z }   {}xms;my ($attrs)=$escape =~ m{ \A ((?:\d+;)* \d*) \z }xms;if (!defined$attrs){croak("Bad escape sequence $escape")}push@nums,$attrs =~ m{ ( 0*[34]8;0*5;\d+ | \d+ ) (?: ; | \z ) }xmsg}for my$num (@nums){$num =~ s{ ( \A | ; ) 0+ (\d) }{$1$2}xmsg;my$name=$ATTRIBUTES_R{$num};if (!defined$name){croak("No name for escape sequence $num")}push@result,$name}return@result}sub colored {my ($first,@rest)=@_;my ($string,@codes);if (ref($first)&& ref($first)eq 'ARRAY'){@codes=@{$first};$string=join q{},@rest}else {$string=$first;@codes=@rest}if ($ENV{ANSI_COLORS_DISABLED}){return$string}my$attr=color(@codes);if (defined$EACHLINE){my@text=map {($_ ne $EACHLINE)? $attr .$_ ."\e[0m" : $_}grep {length($_)> 0}split m{ (\Q$EACHLINE\E) }xms,$string;return join q{},@text}else {return$attr .$string ."\e[0m"}}sub coloralias {my ($alias,$color)=@_;if (!defined$color){if (!exists$ALIASES{$alias}){return}else {return$ATTRIBUTES_R{$ALIASES{$alias}}}}if ($alias !~ m{ \A [\w._-]+ \z }xms){croak(qq{Invalid alias name "$alias"})}elsif ($ATTRIBUTES{$alias}){croak(qq{Cannot alias standard color "$alias"})}elsif (!exists$ATTRIBUTES{$color}){croak(qq{Invalid attribute name "$color"})}$ALIASES{$alias}=$ATTRIBUTES{$color};return$color}sub colorstrip {my (@string)=@_;for my$string (@string){$string =~ s{ \e\[ [\d;]* m }{}xmsg}return wantarray ? @string : join q{},@string}sub colorvalid {my (@codes)=@_;@codes=map {split q{ },lc $_}@codes;for my$code (@codes){if (!defined$ATTRIBUTES{$code}&&!defined$ALIASES{$code}){return}}return 1}1;
TERM_ANSICOLOR

$fatpacked{"Test/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TYPETINY';
  package Test::TypeTiny;use strict;use warnings;use Test::More qw();use Scalar::Util qw(blessed);use Types::TypeTiny qw(to_TypeTiny);require Exporter::Tiny;our@ISA='Exporter::Tiny';BEGIN {*EXTENDED_TESTING=$ENV{EXTENDED_TESTING}? sub(){!!1}: sub(){!!0}};our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.034';our@EXPORT=qw(should_pass should_fail ok_subtype);our@EXPORT_OK=qw(EXTENDED_TESTING matchfor);sub matchfor {my@matchers=@_;bless \@matchers,do {package Test::TypeTiny::Internal::MATCHFOR;use overload q[==]=>'match',q[eq]=>'match',q[""]=>'to_string',fallback=>1;sub to_string {$_[0][0]}sub match {my ($self,$e)=@_;my$does=Scalar::Util::blessed($e)? ($e->can('DOES')|| $e->can('isa')): undef;for my$s (@$self){return 1 if ref($s)&& $e =~ $s;return 1 if!ref($s)&& $does && $e->$does($s)}return}__PACKAGE__}}sub _mk_message {require Type::Tiny;my ($template,$value)=@_;sprintf($template,Type::Tiny::_dd($value))}sub ok_subtype {my ($type,@s)=@_;@_=(not(scalar grep!$_->is_subtype_of($type),@s),sprintf("%s subtype: %s",$type,join q[, ],@s),);goto \&Test::More::ok}eval(EXTENDED_TESTING ? <<'SLOW' : <<'FAST');1;
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!!$type->check($value), '->check');
  	$test->ok(!!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!$type->check($value), '->check');
  	$test->ok(!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  SLOW
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!!$type->check($value),
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!$type->check($value),
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  FAST
TEST_TYPETINY

$fatpacked{"Test/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_YAML';
  package Test::YAML;use Test::Base 0.47 -Base;use lib 'lib';our$VERSION='0.84';our$YAML='YAML';our@EXPORT=qw(no_diff run_yaml_tests run_roundtrip_nyn roundtrip_nyn run_load_passes load_passes dumper Load Dump LoadFile DumpFile XXX);delimiters('===','+++');sub Dump () {YAML(Dump=>@_)}sub Load () {YAML(Load=>@_)}sub DumpFile () {YAML(DumpFile=>@_)}sub LoadFile () {YAML(LoadFile=>@_)}sub YAML () {load_yaml_pm();my$meth=shift;my$code=$YAML->can($meth)or die "$YAML cannot do $meth";goto &$code}sub load_yaml_pm {my$file="$YAML.pm";$file =~ s{::}{/}g;require$file}sub run_yaml_tests() {run {my$block=shift;&{_get_function($block)}($block)unless _skip_tests_for_now($block)or _skip_yaml_tests($block)}}sub run_roundtrip_nyn() {my@options=@_;run {my$block=shift;roundtrip_nyn($block,@options)}}sub roundtrip_nyn() {my$block=shift;my$option=shift || '';die "'perl' data section required" unless exists$block->{perl};my@values=eval$block->perl;die "roundtrip_nyn eval perl error: $@" if $@;my$config=$block->config || '';my$result=eval "$config; Dump(\@values)";die "roundtrip_nyn YAML::Dump error: $@" if $@;if (exists$block->{yaml}){is$result,$block->yaml,$block->description .' (n->y)'}else {pass$block->description .' (n->y)'}return if exists$block->{no_round_trip}or not exists$block->{yaml};if ($option eq 'dumper'){is dumper(Load($block->yaml)),dumper(@values),$block->description .' (y->n)'}else {is_deeply [Load($block->yaml)],[@values],$block->description .' (y->n)'}}sub count_roundtrip_nyn() {my$block=shift or die "Bad call to count_roundtrip_nyn";return 1 if exists$block->{skip_this_for_now};my$count=0;$count++ if exists$block->{perl};$count++ unless exists$block->{no_round_trip}or not exists$block->{yaml};die "Invalid test definition" unless$count;return$count}sub run_load_passes() {run {my$block=shift;my$yaml=$block->yaml;eval {YAML(Load=>$yaml)};is("$@","")}}sub load_passes() {my$block=shift;my$yaml=$block->yaml;eval {YAML(Load=>$yaml)};is "$@","",$block->description}sub count_load_passes() {1}sub dumper() {require Data::Dumper;$Data::Dumper::Sortkeys=1;$Data::Dumper::Terse=1;$Data::Dumper::Indent=1;return Data::Dumper::Dumper(@_)}sub _count_tests() {my$block=shift or die "Bad call to _count_tests";no strict 'refs';&{'count_' ._get_function_name($block)}($block)}sub _get_function_name() {my$block=shift;return$block->function || 'roundtrip_nyn'}sub _get_function() {my$block=shift;no strict 'refs';\ &{_get_function_name($block)}}sub _skip_tests_for_now() {my$block=shift;if (exists$block->{skip_this_for_now}){_skip_test($block->description,_count_tests($block),);return 1}return 0}sub _skip_yaml_tests() {my$block=shift;if ($block->skip_unless_modules){my@modules=split /[\s\,]+/,$block->skip_unless_modules;for my$module (@modules){eval "require $module";if ($@){_skip_test("This test requires the '$module' module",_count_tests($block),);return 1}}}return 0}sub _skip_test() {my ($message,$count)=@_;SKIP: {skip($message,$count)}}package Test::YAML::Filter;use Test::Base::Filter ();our@ISA='Test::Base::Filter';sub yaml_dump {Test::YAML::Dump(@_)}sub yaml_load {Test::YAML::Load(@_)}sub Dump {goto&Test::YAML::Dump}sub Load {goto&Test::YAML::Load}sub DumpFile {goto&Test::YAML::DumpFile}sub LoadFile {goto&Test::YAML::LoadFile}sub yaml_load_or_fail {my ($result,$error,$warning)=$self->_yaml_load_result_error_warning(@_);return$error || $result}sub yaml_load_error_or_warning {my ($result,$error,$warning)=$self->_yaml_load_result_error_warning(@_);return$error || $warning || ''}sub perl_eval_error_or_warning {my ($result,$error,$warning)=$self->_perl_eval_result_error_warning(@_);return$error || $warning || ''}sub _yaml_load_result_error_warning {$self->assert_scalar(@_);my$yaml=shift;my$warning='';local$SIG{__WARN__}=sub {$warning=join '',@_};my$result=eval {$self->yaml_load($yaml)};return ($result,$@,$warning)}sub _perl_eval_result_error_warning {$self->assert_scalar(@_);my$perl=shift;my$warning='';local$SIG{__WARN__}=sub {$warning=join '',@_};my$result=eval$perl;return ($result,$@,$warning)}1;
TEST_YAML

$fatpacked{"Type/Coercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION';
  package Type::Coercion;use 5.006001;use strict;use warnings;BEGIN {$Type::Coercion::AUTHORITY='cpan:TOBYINK';$Type::Coercion::VERSION='0.034'}use Eval::TypeTiny qw<>;use Scalar::Util qw<blessed>;use Types::TypeTiny qw<>;sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}use overload q("")=>sub {caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]): $_[0]->display_name},q(bool)=>sub {1},q(&{})=>"_overload_coderef",q(+)=>sub {__PACKAGE__->add(@_)},fallback=>1,;BEGIN {require Type::Tiny;overload->import(q(~~)=>sub {$_[0]->has_coercion_for_value($_[1])})if Type::Tiny::SUPPORT_SMARTMATCH()}sub _overload_coderef {my$self=shift;if ("Sub::Quote"->can("quote_sub")&& $self->can_be_inlined){$self->{_overload_coderef}=Sub::Quote::quote_sub($self->inline_coercion('$_[0]'))if!$self->{_overload_coderef}||!$self->{_sub_quoted}++}else {$self->{_overload_coderef}||=sub {$self->coerce(@_)}}$self->{_overload_coderef}}sub new {my$class=shift;my%params=(@_==1)? %{$_[0]}: @_;$params{name}='__ANON__' unless exists($params{name});my$C=delete($params{type_coercion_map})|| [];my$F=delete($params{frozen});my$self=bless \%params,$class;$self->add_type_coercions(@$C)if @$C;Scalar::Util::weaken($self->{type_constraint});$self->{frozen}=$F if$F;unless ($self->is_anon){$self->name =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm or eval q( use 5.008; $self->name =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm ) or _croak '"%s" is not a valid coercion name',$self->name}return$self}sub name {$_[0]{name}}sub display_name {$_[0]{display_name}||=$_[0]->_build_display_name}sub library {$_[0]{library}}sub type_constraint {$_[0]{type_constraint}}sub type_coercion_map {$_[0]{type_coercion_map}||=[]}sub moose_coercion {$_[0]{moose_coercion}||=$_[0]->_build_moose_coercion}sub compiled_coercion {$_[0]{compiled_coercion}||=$_[0]->_build_compiled_coercion}sub frozen {$_[0]{frozen}||=0}sub coercion_generator {$_[0]{coercion_generator}}sub parameters {$_[0]{parameters}}sub has_library {exists $_[0]{library}}sub has_type_constraint {defined $_[0]{type_constraint}}sub has_coercion_generator {exists $_[0]{coercion_generator}}sub has_parameters {exists $_[0]{parameters}}sub add {my$class=shift;my ($x,$y,$swap)=@_;Types::TypeTiny::TypeTiny->check($x)and return$x->plus_fallback_coercions($y);Types::TypeTiny::TypeTiny->check($y)and return$y->plus_coercions($x);_croak "Attempt to add $class to something that is not a $class" unless blessed($x)&& blessed($y)&& $x->isa($class)&& $y->isa($class);($y,$x)=($x,$y)if$swap;my%opts;if ($x->has_type_constraint and $y->has_type_constraint and $x->type_constraint==$y->type_constraint){$opts{type_constraint}=$x->type_constraint}elsif ($x->has_type_constraint and $y->has_type_constraint){}$opts{display_name}||="$x+$y";delete$opts{display_name}if$opts{display_name}eq '__ANON__+__ANON__';my$new=$class->new(%opts);$new->add_type_coercions(@{$x->type_coercion_map});$new->add_type_coercions(@{$y->type_coercion_map});return$new}sub _build_display_name {shift->name}sub qualified_name {my$self=shift;if ($self->has_library and not $self->is_anon){return sprintf("%s::%s",$self->library,$self->name)}return$self->name}sub is_anon {my$self=shift;$self->name eq "__ANON__"}sub _clear_compiled_coercion {delete $_[0]{_overload_coderef};delete $_[0]{compiled_coercion}}sub freeze {$_[0]{frozen}=1;$_[0]}sub coerce {my$self=shift;return$self->compiled_coercion->(@_)}sub assert_coerce {my$self=shift;my$r=$self->coerce(@_);$self->type_constraint->assert_valid($r)if$self->has_type_constraint;return$r}sub has_coercion_for_type {my$self=shift;my$type=Types::TypeTiny::to_TypeTiny($_[0]);return "0 but true" if$self->has_type_constraint && $type->is_a_type_of($self->type_constraint);my$c=$self->type_coercion_map;for (my$i=0;$i <= $#$c;$i += 2){return!!1 if$type->is_a_type_of($c->[$i])}return}sub has_coercion_for_value {my$self=shift;local $_=$_[0];return "0 but true" if$self->has_type_constraint && $self->type_constraint->check(@_);my$c=$self->type_coercion_map;for (my$i=0;$i <= $#$c;$i += 2){return!!1 if$c->[$i]->check(@_)}return}sub add_type_coercions {my$self=shift;my@args=@_;_croak "Attempt to add coercion code to a Type::Coercion which has been frozen" if$self->frozen;while (@args){my$type=Types::TypeTiny::to_TypeTiny(shift@args);my$coercion=shift@args;_croak "Types must be blessed Type::Tiny objects" unless Types::TypeTiny::TypeTiny->check($type);_croak "Coercions must be code references or strings" unless Types::TypeTiny::StringLike->check($coercion)|| Types::TypeTiny::CodeLike->check($coercion);push @{$self->type_coercion_map},$type,$coercion}$self->_clear_compiled_coercion;return$self}sub _build_compiled_coercion {my$self=shift;my@mishmash=@{$self->type_coercion_map};return sub {$_[0]}unless@mishmash;if ($self->can_be_inlined){return Eval::TypeTiny::eval_closure(source=>sprintf('sub ($) { %s }',$self->inline_coercion('$_[0]')),description=>sprintf("compiled coercion '%s'",$self),)}my (@types,@codes);while (@mishmash){push@types,shift@mishmash;push@codes,shift@mishmash}if ($self->has_type_constraint){unshift@types,$self->type_constraint;unshift@codes,undef}my@sub;for my$i (0..$#types){push@sub,$types[$i]->can_be_inlined ? sprintf('if (%s)',$types[$i]->inline_check('$_[0]')): sprintf('if ($checks[%d]->(@_))',$i);push@sub,!defined($codes[$i])? sprintf('  { return $_[0] }'): Types::TypeTiny::StringLike->check($codes[$i])? sprintf('  { local $_ = $_[0]; return( %s ) }',$codes[$i]): sprintf('  { local $_ = $_[0]; return $codes[%d]->(@_) }',$i)}push@sub,'return $_[0];';return Eval::TypeTiny::eval_closure(source=>sprintf('sub ($) { %s }',join qq[\n],@sub),description=>sprintf("compiled coercion '%s'",$self),environment=>{'@checks'=>[map $_->compiled_check,@types ],'@codes'=>\@codes,},)}sub can_be_inlined {my$self=shift;return if$self->has_type_constraint &&!$self->type_constraint->can_be_inlined;my@mishmash=@{$self->type_coercion_map};while (@mishmash){my ($type,$converter)=splice(@mishmash,0,2);return unless$type->can_be_inlined;return unless Types::TypeTiny::StringLike->check($converter)}return!!1}sub _source_type_union {my$self=shift;my@r;push@r,$self->type_constraint if$self->has_type_constraint;my@mishmash=@{$self->type_coercion_map};while (@mishmash){my ($type)=splice(@mishmash,0,2);push@r,$type}require Type::Tiny::Union;return "Type::Tiny::Union"->new(type_constraints=>\@r,tmp=>1)}sub inline_coercion {my$self=shift;my$varname=$_[0];_croak "This coercion cannot be inlined" unless$self->can_be_inlined;my@mishmash=@{$self->type_coercion_map};return "($varname)" unless@mishmash;my (@types,@codes);while (@mishmash){push@types,shift@mishmash;push@codes,shift@mishmash}if ($self->has_type_constraint){unshift@types,$self->type_constraint;unshift@codes,undef}my@sub;for my$i (0..$#types){push@sub,sprintf('(%s) ?',$types[$i]->inline_check($varname));push@sub,(defined($codes[$i])&& ($varname eq '$_'))? sprintf('scalar(%s) :',$codes[$i]): defined($codes[$i])? sprintf('do { local $_ = %s; scalar(%s) } :',$varname,$codes[$i]): sprintf('%s :',$varname)}push@sub,"$varname";"@sub"}sub _build_moose_coercion {my$self=shift;my%options=();$options{type_coercion_map}=[$self->freeze->_codelike_type_coercion_map('moose_type')];$options{type_constraint}=$self->type_constraint if$self->has_type_constraint;require Moose::Meta::TypeCoercion;my$r="Moose::Meta::TypeCoercion"->new(%options);return$r}sub _codelike_type_coercion_map {my$self=shift;my$modifier=$_[0];my@orig=@{$self->type_coercion_map};my@new;while (@orig){my ($type,$converter)=splice(@orig,0,2);push@new,$modifier ? $type->$modifier : $type;if (Types::TypeTiny::CodeLike->check($converter)){push@new,$converter}else {Eval::TypeTiny::eval_closure(source=>sprintf('sub { local $_ = $_[0]; %s }',$converter),description=>sprintf("temporary compiled converter from '%s'",$type),)}}return@new}sub is_parameterizable {shift->has_coercion_generator}sub is_parameterized {shift->has_parameters}sub parameterize {my$self=shift;return$self unless @_;$self->is_parameterizable or _croak "Constraint '%s' does not accept parameters","$self";@_=map Types::TypeTiny::to_TypeTiny($_),@_;return ref($self)->new(type_constraint=>$self->type_constraint,type_coercion_map=>[$self->coercion_generator->($self,$self->type_constraint,@_)],parameters=>\@_,frozen=>1,)}sub isa {my$self=shift;if ($INC{"Moose.pm"}and blessed($self)and $_[0]eq 'Moose::Meta::TypeCoercion'){return!!1}if ($INC{"Moose.pm"}and blessed($self)and $_[0]=~ /^Moose/ and my$r=$self->moose_coercion->isa(@_)){return$r}$self->SUPER::isa(@_)}sub can {my$self=shift;my$can=$self->SUPER::can(@_);return$can if$can;if ($INC{"Moose.pm"}and blessed($self)and my$method=$self->moose_coercion->can(@_)){return sub {$method->(shift->moose_coercion,@_)}}return}sub AUTOLOAD {my$self=shift;my ($m)=(our$AUTOLOAD =~ /::(\w+)$/);return if$m eq 'DESTROY';if ($INC{"Moose.pm"}and blessed($self)and my$method=$self->moose_coercion->can($m)){return$method->($self->moose_coercion,@_)}_croak q[Can't locate object method "%s" via package "%s"],$m,ref($self)||$self}sub _compiled_type_coercion {my$self=shift;if (@_){my$thing=$_[0];if (blessed($thing)and $thing->isa("Type::Coercion")){$self->add_type_coercions(@{$thing->type_coercion_map})}elsif (Types::TypeTiny::CodeLike->check($thing)){require Types::Standard;$self->add_type_coercions(Types::Standard::Any(),$thing)}}$self->compiled_coercion}*compile_type_coercion=\&compiled_coercion;sub meta {_croak("Not really a Moose::Meta::TypeCoercion. Sorry!")}1;
TYPE_COERCION

$fatpacked{"Type/Coercion/FromMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_FROMMOOSE';
  package Type::Coercion::FromMoose;use 5.006001;use strict;use warnings;BEGIN {$Type::Coercion::FromMoose::AUTHORITY='cpan:TOBYINK';$Type::Coercion::FromMoose::VERSION='0.034'}use Scalar::Util qw<blessed>;use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}require Type::Coercion;our@ISA='Type::Coercion';sub type_coercion_map {my$self=shift;my@from=@{$self->type_constraint->moose_type->coercion->type_coercion_map};my@return;while (@from){my ($type,$code)=splice(@from,0,2);$type=Moose::Util::TypeConstraints::find_type_constraint($type)unless ref$type;push@return,Types::TypeTiny::to_TypeTiny($type),$code}return \@return}sub add_type_coercions {my$self=shift;_croak "Adding coercions to Type::Coercion::FromMoose not currently supported" if @_}1;
TYPE_COERCION_FROMMOOSE

$fatpacked{"Type/Coercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_UNION';
  package Type::Coercion::Union;use 5.006001;use strict;use warnings;BEGIN {$Type::Coercion::Union::AUTHORITY='cpan:TOBYINK';$Type::Coercion::Union::VERSION='0.034'}use Scalar::Util qw<blessed>;use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}require Type::Coercion;our@ISA='Type::Coercion';sub type_coercion_map {my$self=shift;Types::TypeTiny::TypeTiny->assert_valid(my$type=$self->type_constraint);$type->isa('Type::Tiny::Union')or _croak "Type::Coercion::Union must be used in conjunction with Type::Tiny::Union";my@c;for my$tc (@$type){next unless$tc->has_coercion;push@c,@{$tc->coercion->type_coercion_map}}return \@c}sub add_type_coercions {my$self=shift;_croak "Adding coercions to Type::Coercion::Union not currently supported" if @_}1;
TYPE_COERCION_UNION

$fatpacked{"Type/Library.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_LIBRARY';
  package Type::Library;use 5.006001;use strict;use warnings;BEGIN {$Type::Library::AUTHORITY='cpan:TOBYINK';$Type::Library::VERSION='0.034'}use Eval::TypeTiny qw<eval_closure>;use Scalar::Util qw<blessed>;use Type::Tiny;use Types::TypeTiny qw<TypeTiny to_TypeTiny>;require Exporter::Tiny;our@ISA='Exporter::Tiny';BEGIN {*NICE_PROTOTYPES=($] >= 5.014)? sub () {!!1}: sub () {!!0}};sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}{my$got_subname;sub _subname ($$) {$got_subname=1 && goto \&Sub::Name::subname if$got_subname || eval "require Sub::Name";return $_[1]}}sub _exporter_validate_opts {my$class=shift;no strict "refs";my$into=$_[0]{into};push @{"$into\::ISA"},$class if $_[0]{base};return$class->SUPER::_exporter_validate_opts(@_)}sub _exporter_expand_tag {my$class=shift;my ($name,$value,$globals)=@_;$name eq 'types' and return map ["$_"=>$value ],$class->type_names;$name eq 'is' and return map ["is_$_"=>$value ],$class->type_names;$name eq 'assert' and return map ["assert_$_"=>$value ],$class->type_names;$name eq 'to' and return map ["to_$_"=>$value ],$class->type_names;$name eq 'coercions' and return map ["$_"=>$value ],$class->coercion_names;if ($name eq 'all'){no strict "refs";return (map(["+$_"=>$value ],$class->type_names,),map([$_=>$value ],$class->coercion_names,@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"},),)}return$class->SUPER::_exporter_expand_tag(@_)}sub _mksub {my$class=shift;my ($type,$post_method)=@_;$post_method ||=q();my$source=$type->is_parameterizable ? sprintf(q{
  				sub (%s) {
  					my $params; $params = shift if ref($_[0]) eq q(ARRAY);
  					my $t = $params ? $type->parameterize(@$params) : $type;
  					@_ && wantarray ? return($t%s, @_) : return $t%s;
  				}
  			},NICE_PROTOTYPES ? q(;$) : q(;@),$post_method,$post_method,): sprintf(q{ sub () { $type%s if $] } },$post_method,);return _subname($type->qualified_name,eval_closure(source=>$source,description=>sprintf("exportable function '%s'",$type),environment=>{'$type'=>\$type},),)}sub _exporter_permitted_regexp {my$class=shift;my$inherited=$class->SUPER::_exporter_permitted_regexp(@_);my$types=join "|",map quotemeta,sort {length($b)<=> length($a)or $a cmp $b}$class->type_names;my$coercions=join "|",map quotemeta,sort {length($b)<=> length($a)or $a cmp $b}$class->coercion_names;qr{^(?:
  		$inherited
  		| (?: (?:is_|to_|assert_)? (?:$types) )
  		| (?:$coercions)
  	)$}xms}sub _exporter_expand_sub {my$class=shift;my ($name,$value,$globals)=@_;if ($name =~ /^\+(.+)/ and $class->has_type($1)){my$type=$1;my$value2=+{%{$value||{}}};return map$class->_exporter_expand_sub($_,$value2,$globals),$type,"is_$type","assert_$type","to_$type"}if (my$type=$class->get_type($name)){my$post_method=q();$post_method='->mouse_type' if$globals->{mouse};$post_method='->moose_type' if$globals->{moose};return ($name=>$class->_mksub($type,$post_method))if$post_method}return$class->SUPER::_exporter_expand_sub(@_)}sub _exporter_fail {my$class=shift;my ($name,$value,$globals)=@_;my$into=$globals->{into}or _croak("Parameter 'into' not supplied");if ($globals->{declare}){my$declared=sub (;$) {my$params;$params=shift if ref($_[0])eq "ARRAY";my$type=$into->get_type($name);unless ($type){_croak "Cannot parameterize a non-existant type" if$params;$type=$name}my$t=$params ? $type->parameterize(@$params): $type;@_ && wantarray ? return($t,@_): return$t};return($name,_subname("$class\::$name",NICE_PROTOTYPES ? sub (;$) {goto$declared}: sub (;@) {goto$declared},),)}return$class->SUPER::_exporter_fail(@_)}sub meta {no strict "refs";no warnings "once";return $_[0]if blessed $_[0];${"$_[0]\::META"}||=bless {},$_[0]}sub add_type {my$meta=shift->meta;my$class=blessed($meta);my$type=ref($_[0])=~ /^Type::Tiny\b/ ? $_[0]: blessed($_[0])? to_TypeTiny($_[0]): ref($_[0])eq q(HASH) ? "Type::Tiny"->new(library=>$class,%{$_[0]}): "Type::Tiny"->new(library=>$class,@_);my$name=$type->{name};$meta->{types}||={};_croak 'Type %s already exists in this library',$name if$meta->has_type($name);_croak 'Type %s conflicts with coercion of same name',$name if$meta->has_coercion($name);_croak 'Cannot add anonymous type to a library' if$type->is_anon;$meta->{types}{$name}=$type;no strict "refs";no warnings "redefine","prototype";*{"$class\::$name"}=$class->_mksub($type);*{"$class\::is_$name"}=_subname "is_" .$type->qualified_name,$type->compiled_check;*{"$class\::to_$name"}=_subname "to_" .$type->qualified_name,sub ($) {$type->coerce($_[0])};*{"$class\::assert_$name"}=_subname "assert_".$type->qualified_name,$type->_overload_coderef;return$type}sub get_type {my$meta=shift->meta;$meta->{types}{$_[0]}}sub has_type {my$meta=shift->meta;exists$meta->{types}{$_[0]}}sub type_names {my$meta=shift->meta;keys %{$meta->{types}}}sub add_coercion {require Type::Coercion;my$meta=shift->meta;my$c=blessed($_[0])? $_[0]: "Type::Coercion"->new(@_);my$name=$c->name;$meta->{coercions}||={};_croak 'Coercion %s already exists in this library',$name if$meta->has_coercion($name);_croak 'Coercion %s conflicts with type of same name',$name if$meta->has_type($name);_croak 'Cannot add anonymous type to a library' if$c->is_anon;$meta->{coercions}{$name}=$c;no strict "refs";no warnings "redefine","prototype";my$class=blessed($meta);*{"$class\::$name"}=$class->_mksub($c);return$c}sub get_coercion {my$meta=shift->meta;$meta->{coercions}{$_[0]}}sub has_coercion {my$meta=shift->meta;exists$meta->{coercions}{$_[0]}}sub coercion_names {my$meta=shift->meta;keys %{$meta->{coercions}}}1;
TYPE_LIBRARY

$fatpacked{"Type/Params.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARAMS';
  package Type::Params;use 5.006001;use strict;use warnings;BEGIN {if ($] < 5.008){require Devel::TypeTiny::Perl56Compat}}BEGIN {$Type::Params::AUTHORITY='cpan:TOBYINK';$Type::Params::VERSION='0.034'}use B qw(perlstring);use Eval::TypeTiny;use Scalar::Util qw(refaddr);use Error::TypeTiny;use Error::TypeTiny::Assertion;use Error::TypeTiny::WrongNumberOfParameters;use Type::Tiny::Union;use Types::Standard -types;use Types::TypeTiny qw(CodeLike ArrayLike to_TypeTiny);require Exporter::Tiny;our@ISA='Exporter::Tiny';our@EXPORT=qw(compile);our@EXPORT_OK=qw(multisig validate Invocant);BEGIN {my$Invocant='Type::Tiny::Union'->new(name=>'Invocant',type_constraints=>[Object,ClassName],);sub Invocant () {$Invocant}};sub _mkslurpy {my ($name,$type,$tc,$i)=@_;$name='local $_' if$name eq '$_';$type eq '@' ? sprintf('%s = [ @_[%d..$#_] ];',$name,$i,): sprintf('%s = (($#_-%d)%%2)==0 ? "Error::TypeTiny::WrongNumberOfParameters"->throw(message => sprintf("Odd number of elements in %%s", %s)) : +{ @_[%d..$#_] };',$name,$i,perlstring("$tc"),$i,$i,)}sub compile {my (@code,%env);@code='my (@R, %tmp, $tmp);';push@code,'#placeholder';my%options=(ref($_[0])eq "HASH" &&!$_[0]{slurpy})? %{+shift}: ();my$arg=-1;my$saw_slurpy=0;my$min_args=0;my$max_args=0;my$saw_opt=0;while (@_){++$arg;my$constraint=shift;my$is_optional;my$is_slurpy;my$varname;if (Bool->check($constraint)){$constraint=$constraint ? Any : Optional[Any]}if (HashRef->check($constraint)){$constraint=to_TypeTiny($constraint->{slurpy});push@code,$constraint->is_a_type_of(Dict)? _mkslurpy('$_','%',$constraint=>$arg): $constraint->is_a_type_of(Map)? _mkslurpy('$_','%',$constraint=>$arg): $constraint->is_a_type_of(Tuple)? _mkslurpy('$_','@',$constraint=>$arg): $constraint->is_a_type_of(HashRef)? _mkslurpy('$_','%',$constraint=>$arg): $constraint->is_a_type_of(ArrayRef)? _mkslurpy('$_','@',$constraint=>$arg): Error::TypeTiny::croak("Slurpy parameter not of type HashRef or ArrayRef");$varname='$_';$is_slurpy++;$saw_slurpy++}else {Error::TypeTiny::croak("Parameter following slurpy parameter")if$saw_slurpy;$is_optional=grep $_->{uniq}==Optional->{uniq},$constraint->parents;if ($is_optional){push@code,sprintf 'return @R if $#_ < %d;',$arg;$saw_opt++;$max_args++}else {Error::TypeTiny::croak("Non-Optional parameter following Optional parameter")if$saw_opt;$min_args++;$max_args++}$varname=sprintf '$_[%d]',$arg}if ($constraint->has_coercion and $constraint->coercion->can_be_inlined){push@code,sprintf('$tmp%s = %s;',($is_optional ? '{x}' : ''),$constraint->coercion->inline_coercion($varname));$varname='$tmp'.($is_optional ? '{x}' : '')}elsif ($constraint->has_coercion){$env{'@coerce'}[$arg]=$constraint->coercion->compiled_coercion;push@code,sprintf('$tmp%s = $coerce[%d]->(%s);',($is_optional ? '{x}' : ''),$arg,$varname,);$varname='$tmp'.($is_optional ? '{x}' : '')}if ($constraint->can_be_inlined){push@code,sprintf('(%s) or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',$constraint->inline_check($varname),$constraint->{uniq},perlstring($constraint),$varname,$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}',$arg),)}else {$env{'@check'}[$arg]=$constraint->compiled_check;push@code,sprintf('%s or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',sprintf(sprintf '$check[%d]->(%s)',$arg,$varname),$constraint->{uniq},perlstring($constraint),$varname,$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}',$arg),)}push@code,sprintf 'push @R, %s;',$varname}if ($min_args==$max_args and not $saw_slurpy){$code[1]=sprintf('"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ != %d;',$min_args,$max_args,$min_args,)}elsif ($min_args < $max_args and not $saw_slurpy){$code[1]=sprintf('"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ < %d || @_ > %d;',$min_args,$max_args,$min_args,$max_args,)}elsif ($min_args and $saw_slurpy){$code[1]=sprintf('"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d) if @_ < %d;',$min_args,$min_args,)}push@code,'@R;';my$source="sub { no warnings; ".join("\n",@code)." };";return$source if$options{want_source};my$closure=eval_closure(source=>$source,description=>sprintf("parameter validation for '%s'",[caller(1+($options{caller_level}||0))]->[3]|| '__ANON__'),environment=>\%env,);return {min_args=>$min_args,max_args=>$saw_slurpy ? undef : $max_args,closure=>$closure,}if$options{want_details};return$closure}my%compiled;sub validate {my$arr=shift;my$sub=$compiled{join ":",map($_->{uniq}||"\@$_->{slurpy}",@_)}||=compile({caller_level=>1 },@_);@_=@$arr;goto$sub}sub multisig {my%options=(ref($_[0])eq "HASH" &&!$_[0]{slurpy})? %{+shift}: ();my@multi=map {CodeLike->check($_)? {closure=>$_}: ArrayLike->check($_)? compile({want_details=>1 },@$_): $_}@_;my@code='sub { my $r; ';for my$i (0 .. $#multi){my$sig=$multi[$i];my@cond;push@cond,sprintf('@_ >= %s',$sig->{min_args})if defined$sig->{min_args};push@cond,sprintf('@_ <= %s',$sig->{max_args})if defined$sig->{max_args};push@code,sprintf('if (%s){',join(' and ',@cond))if@cond;push@code,sprintf('eval { $r = [ $multi[%d]{closure}->(@_) ] };',$i);push@code,'return(@$r) if $r;';push@code,'}' if@cond}push@code,'"Error::TypeTiny"->throw(message => "Parameter validation failed");';push@code,'}';eval_closure(source=>\@code,description=>sprintf("parameter validation for '%s'",[caller(1+($options{caller_level}||0))]->[3]|| '__ANON__'),environment=>{'@multi'=>\@multi },)}1;
TYPE_PARAMS

$fatpacked{"Type/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARSER';
  package Type::Parser;use strict;use warnings;sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.034';sub TYPE () {"TYPE"};sub QUOTELIKE () {"QUOTELIKE"};sub STRING () {"STRING"};sub CLASS () {"CLASS"};sub L_BRACKET () {"L_BRACKET"};sub R_BRACKET () {"R_BRACKET"};sub COMMA () {"COMMA"};sub SLURPY () {"SLURPY"};sub UNION () {"UNION"};sub INTERSECT () {"INTERSECT"};sub NOT () {"NOT"};sub L_PAREN () {"L_PAREN"};sub R_PAREN () {"R_PAREN"};sub MYSTERY () {"MYSTERY"};our@EXPORT_OK=qw(eval_type _std_eval parse);require Exporter::Tiny;our@ISA='Exporter::Tiny';Evaluate: {sub parse {my$str=$_[0];my$parser="Type::Parser::AstBuilder"->new(input=>$str);$parser->build;wantarray ? ($parser->ast,$parser->remainder): $parser->ast}sub extract_type {my ($str,$reg)=@_;my ($parsed,$tail)=parse($str);wantarray ? (_eval_type($parsed,$reg),$tail): _eval_type($parsed,$reg)}sub eval_type {my ($str,$reg)=@_;my ($parsed,$tail)=parse($str);_croak("Unexpected tail on type expression: $tail")if$tail =~ /\S/sm;return _eval_type($parsed,$reg)}my$std;sub _std_eval {require Type::Registry;unless ($std){$std="Type::Registry"->new;$std->add_types(-Standard)}eval_type($_[0],$std)}sub _eval_type {my ($node,$reg)=@_;$node=_simplify_expression($node);if ($node->{type}eq "list"){return map _eval_type($_,$reg),@{$node->{list}}}if ($node->{type}eq "union"){require Type::Tiny::Union;return "Type::Tiny::Union"->new(type_constraints=>[map _eval_type($_,$reg),@{$node->{union}}],)}if ($node->{type}eq "intersect"){require Type::Tiny::Intersection;return "Type::Tiny::Intersection"->new(type_constraints=>[map _eval_type($_,$reg),@{$node->{intersect}}],)}if ($node->{type}eq "slurpy"){return +{slurpy=>_eval_type($node->{of},$reg)}}if ($node->{type}eq "complement"){return _eval_type($node->{of},$reg)->complementary_type}if ($node->{type}eq "parameterized"){my$base=_eval_type($node->{base},$reg);return$base unless$base->is_parameterizable || $node->{params};return$base->parameterize($node->{params}? _eval_type($node->{params},$reg): ())}if ($node->{type}eq "primary" and $node->{token}->type eq CLASS){my$class=substr($node->{token}->spelling,0,length($node->{token}->spelling)- 2);require Type::Tiny::Class;return "Type::Tiny::Class"->new(class=>$class)}if ($node->{type}eq "primary" and $node->{token}->type eq QUOTELIKE){return eval($node->{token}->spelling)}if ($node->{type}eq "primary" and $node->{token}->type eq STRING){return$node->{token}->spelling}if ($node->{type}eq "primary" and $node->{token}->type eq TYPE){my$t=$node->{token}->spelling;my$r;if ($t =~ /^(.+)::(\w+)$/){require Types::TypeTiny;my$library=$1;$t=$2;eval "require $library;";$r=$library->isa('MooseX::Types::Base')? Types::TypeTiny::to_TypeTiny($library->has_type($t)? $library->can($t)->(): ()): $library->can("get_type")? $library->get_type($t): $reg->simple_lookup("$library\::$t",1)}else {$r=$reg->simple_lookup($t,1)}$r or _croak("%s is not a known type constraint",$node->{token}->spelling);return$r}}sub _simplify_expression {my$expr=shift;if ($expr->{type}eq "expression" and $expr->{op}[0]eq COMMA){return _simplify("list",COMMA,$expr)}if ($expr->{type}eq "expression" and $expr->{op}[0]eq UNION){return _simplify("union",UNION,$expr)}if ($expr->{type}eq "expression" and $expr->{op}[0]eq INTERSECT){return _simplify("intersect",INTERSECT,$expr)}return$expr}sub _simplify {my$type=shift;my$op=shift;my@list;for my$expr ($_[0]{lhs},$_[0]{rhs}){if ($expr->{type}eq "expression" and $expr->{op}[0]eq $op){my$simple=_simplify($type,$op,$expr);push@list,@{$simple->{$type}}}else {push@list,$expr}}return {type=>$type,$type=>\@list }}}{package Type::Parser::AstBuilder;sub new {my$class=shift;bless {@_ },$class}our%precedence=(Type::Parser::UNION(),2,Type::Parser::INTERSECT(),3,Type::Parser::NOT(),4,);sub _parse_primary {my$self=shift;my$tokens=$self->{tokens};$tokens->assert_not_empty;if ($tokens->peek(0)->type eq Type::Parser::NOT){$tokens->eat(Type::Parser::NOT);$tokens->assert_not_empty;return {type=>"complement",of=>$self->_parse_primary,}}if ($tokens->peek(0)->type eq Type::Parser::SLURPY){$tokens->eat(Type::Parser::SLURPY);$tokens->assert_not_empty;return {type=>"slurpy",of=>$self->_parse_primary,}}if ($tokens->peek(0)->type eq Type::Parser::L_PAREN){$tokens->eat(Type::Parser::L_PAREN);my$r=$self->_parse_expression;$tokens->eat(Type::Parser::R_PAREN);return$r}if ($tokens->peek(1)and $tokens->peek(0)->type eq Type::Parser::TYPE and $tokens->peek(1)->type eq Type::Parser::L_BRACKET){my$base={type=>"primary",token=>$tokens->eat(Type::Parser::TYPE)};$tokens->eat(Type::Parser::L_BRACKET);$tokens->assert_not_empty;local$precedence{Type::Parser::COMMA()}=1;my$params=undef;if ($tokens->peek(0)->type eq Type::Parser::R_BRACKET){$tokens->eat(Type::Parser::R_BRACKET)}else {$params=$self->_parse_expression;$params={type=>"list",list=>[$params]}unless$params->{type}eq "list";$tokens->eat(Type::Parser::R_BRACKET)}return {type=>"parameterized",base=>$base,params=>$params,}}my$type=$tokens->peek(0)->type;if ($type eq Type::Parser::TYPE or $type eq Type::Parser::QUOTELIKE or $type eq Type::Parser::STRING or $type eq Type::Parser::CLASS){return {type=>"primary",token=>$tokens->eat }}Type::Parser::_croak("Unexpected token in primary type expression; got '%s'",$tokens->peek(0)->spelling)}sub _parse_expression_1 {my$self=shift;my$tokens=$self->{tokens};my ($lhs,$min_p)=@_;while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type})and $precedence{$tokens->peek(0)->type}>= $min_p){my$op=$tokens->eat;my$rhs=$self->_parse_primary;while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type})and $precedence{$tokens->peek(0)->type}> $precedence{$op->type}){my$lookahead=$tokens->peek(0);$rhs=$self->_parse_expression_1($rhs,$precedence{$lookahead->type})}$lhs={type=>"expression",op=>$op,lhs=>$lhs,rhs=>$rhs,}}return$lhs}sub _parse_expression {my$self=shift;my$tokens=$self->{tokens};return$self->_parse_expression_1($self->_parse_primary,0)}sub build {my$self=shift;$self->{tokens}="Type::Parser::TokenStream"->new(remaining=>$self->{input});$self->{ast}=$self->_parse_expression}sub ast {$_[0]{ast}}sub remainder {$_[0]{tokens}->remainder}}{package Type::Parser::Token;sub type {$_[0][0]}sub spelling {$_[0][1]}}{package Type::Parser::TokenStream;use Scalar::Util qw(looks_like_number);use Text::Balanced qw(extract_quotelike);sub new {my$class=shift;bless {stack=>[],done=>[],@_ },$class}sub peek {my$self=shift;my$ahead=$_[0];while ($self->_stack_size <= $ahead and length$self->{remaining}){$self->_stack_extend}my@tokens=grep ref,@{$self->{stack}};return$tokens[$ahead]}sub empty {my$self=shift;not $self->peek(0)}sub eat {my$self=shift;$self->_stack_extend unless$self->_stack_size;my$r;while (defined(my$item=shift @{$self->{stack}})){push @{$self->{done}},$item;if (ref$item){$r=$item;last}}if (@_ and $_[0]ne $r->type){unshift @{$self->{stack}},pop @{$self->{done}};Type::Parser::_croak("Expected $_[0]; got ".$r->type)}return$r}sub assert_not_empty {my$self=shift;Type::Parser::_croak("Expected token; got empty string")if$self->empty}sub _stack_size {my$self=shift;scalar grep ref,@{$self->{stack}}}sub _stack_extend {my$self=shift;push @{$self->{stack}},$self->_read_token;my ($space)=($self->{remaining}=~ m/^([\s\n\r]*)/sm);return unless length$space;push @{$self->{stack}},$space;substr($self->{remaining},0,length$space)=""}sub remainder {my$self=shift;return join "",map {ref($_)? $_->spelling : $_}(@{$self->{stack}},$self->{remaining})}my%punctuation=('['=>bless([Type::Parser::L_BRACKET,"[" ],"Type::Parser::Token"),']'=>bless([Type::Parser::R_BRACKET,"]" ],"Type::Parser::Token"),'('=>bless([Type::Parser::L_PAREN,"[" ],"Type::Parser::Token"),')'=>bless([Type::Parser::R_PAREN,"]" ],"Type::Parser::Token"),','=>bless([Type::Parser::COMMA,"," ],"Type::Parser::Token"),'=>'=>bless([Type::Parser::COMMA,"=>" ],"Type::Parser::Token"),'slurpy'=>bless([Type::Parser::SLURPY,"slurpy" ],"Type::Parser::Token"),'|'=>bless([Type::Parser::UNION,"|" ],"Type::Parser::Token"),'&'=>bless([Type::Parser::INTERSECT,"&" ],"Type::Parser::Token"),'~'=>bless([Type::Parser::NOT,"~" ],"Type::Parser::Token"),);sub _read_token {my$self=shift;return if$self->{remaining}eq "";if ($self->{remaining}=~ /^( => | [()\]\[|&~,] )/xsm){my$spelling=$1;substr($self->{remaining},0,length$spelling)="";return$punctuation{$spelling}}if (my$quotelike=extract_quotelike$self->{remaining}){return bless([Type::Parser::QUOTELIKE,$quotelike ],"Type::Parser::Token"),}if ($self->{remaining}=~ /^([+-]?[\w:.+]+)/sm){my$spelling=$1;substr($self->{remaining},0,length$spelling)="";if ($spelling =~ /::$/sm){return bless([Type::Parser::CLASS,$spelling ],"Type::Parser::Token"),}elsif (looks_like_number($spelling)){return bless([Type::Parser::STRING,$spelling ],"Type::Parser::Token"),}elsif ($self->{remaining}=~ /^\s*=>/sm){return bless([Type::Parser::STRING,$spelling ],"Type::Parser::Token"),}elsif ($spelling eq "slurpy"){return$punctuation{$spelling}}return bless([Type::Parser::TYPE,$spelling ],"Type::Parser::Token")}my$rest=$self->{remaining};$self->{remaining}="";return bless([Type::Parser::MYSTERY,$rest ],"Type::Parser::Token")}}1;
TYPE_PARSER

$fatpacked{"Type/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_REGISTRY';
  package Type::Registry;use 5.006001;use strict;use warnings;BEGIN {$Type::Registry::AUTHORITY='cpan:TOBYINK';$Type::Registry::VERSION='0.034'}use Exporter::Tiny qw(mkopt);use Scalar::Util qw(refaddr);use Type::Parser qw(eval_type);use Types::TypeTiny qw(CodeLike ArrayLike to_TypeTiny);our@ISA='Exporter::Tiny';our@EXPORT_OK=qw(t);sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}sub _exporter_expand_sub {my$class=shift;my ($name,$value,$globals,$permitted)=@_;if ($name eq "t"){my$caller=$globals->{into};my$reg=$class->for_class(ref($caller)? sprintf('HASH(0x%08X)',refaddr($caller)): $caller);return t=>sub (;$) {@_ ? $reg->lookup(@_): $reg}}return$class->SUPER::_exporter_expand_sub(@_)}sub new {my$class=shift;ref($class)and _croak("Not an object method");bless {},$class}{my%registries;sub for_class {my$class=shift;my ($for)=@_;$registries{$for}||=$class->new}sub for_me {my$class=shift;my$for=caller;$registries{$for}||=$class->new}}sub add_types {my$self=shift;my$opts=mkopt(\@_);for my$opt (@$opts){my ($lib,$types)=@_;$lib =~ s/^-/Types::/;eval "require $lib";my%hash;if ($lib->isa("Type::Library")or $lib eq 'Types::TypeTiny'){$types ||=[qw/-types/];ArrayLike->check($types)or _croak("Expected arrayref following '%s'; got %s",$lib,$types);$lib->import({into=>\%hash},@$types);$hash{$_}=&{$hash{$_}}()for keys%hash}elsif ($lib->isa("MooseX::Types::Base")){$types ||=[];ArrayLike->check($types)&& (@$types==0)or _croak("Library '%s' is a MooseX::Types type constraint library. No import options currently supported",$lib);require Moose::Util::TypeConstraints;my$moosextypes=$lib->type_storage;for my$name (sort keys %$moosextypes){my$tt=to_TypeTiny(Moose::Util::TypeConstraints::find_type_constraint($moosextypes->{$name}));$hash{$name}=$tt}}elsif ($lib->isa("MouseX::Types::Base")){$types ||=[];ArrayLike->check($types)&& (@$types==0)or _croak("Library '%s' is a MouseX::Types type constraint library. No import options currently supported",$lib);require Mouse::Util::TypeConstraints;my$moosextypes=$lib->type_storage;for my$name (sort keys %$moosextypes){my$tt=to_TypeTiny(Mouse::Util::TypeConstraints::find_type_constraint($moosextypes->{$name}));$hash{$name}=$tt}}else {_croak("%s is not a type library",$lib)}for my$key (sort keys%hash){exists($self->{$key})and _croak("Duplicate type name: %s",$key);$self->{$key}=$hash{$key}}}$self}sub add_type {my$self=shift;my ($type,$name)=@_;$type=to_TypeTiny($type);$name ||=do {$type->is_anon and _croak("Expected named type constraint; got anonymous type constraint");$type->name};exists($self->{$name})and _croak("Duplicate type name: %s",$name);$self->{$name}=$type;$self}sub alias_type {my$self=shift;my ($old,@new)=@_;$self->{$_}=$self->{$old}for@new;$self}sub simple_lookup {my$self=shift;my ($tc)=@_;$tc =~ s/(^\s+|\s+$)//g;if (exists$self->{$tc}){return$self->{$tc}}return}sub lookup {my$self=shift;$self->simple_lookup(@_)or eval_type($_[0],$self)}sub AUTOLOAD {my$self=shift;my ($method)=(our$AUTOLOAD =~ /(\w+)$/);my$type=$self->simple_lookup($method);return$type if$type;_croak(q[Can't locate object method "%s" via package "%s"],$method,ref($self))}sub DESTROY {return}1;
TYPE_REGISTRY

$fatpacked{"Type/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY';
  package Type::Tiny;use 5.006001;use strict;use warnings;BEGIN {if ($] < 5.008){require Devel::TypeTiny::Perl56Compat}}BEGIN {$Type::Tiny::AUTHORITY='cpan:TOBYINK';$Type::Tiny::VERSION='0.034'}use Eval::TypeTiny ();use Scalar::Util qw(blessed weaken refaddr isweak);use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}sub _swap {$_[2]? @_[1,0]: @_[0,1]}BEGIN {($] > 5.010001)? eval q{ sub SUPPORT_SMARTMATCH () { !!0 } } : eval q{ sub SUPPORT_SMARTMATCH () { !!1 } }}use overload q("")=>sub {caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]): $_[0]->display_name},q(bool)=>sub {1},q(&{})=>"_overload_coderef",q(+)=>sub {$_[2]? $_[1]->plus_coercions($_[0]): $_[0]->plus_fallback_coercions($_[1])},q(|)=>sub {my@tc=_swap @_;require Type::Tiny::Union;"Type::Tiny::Union"->new(type_constraints=>\@tc)},q(&)=>sub {my@tc=_swap @_;require Type::Tiny::Intersection;"Type::Tiny::Intersection"->new(type_constraints=>\@tc)},q(~)=>sub {shift->complementary_type},q(==)=>sub {$_[0]->equals($_[1])},q(<)=>sub {my$m=$_[0]->can('is_subtype_of');$m->(_swap @_)},q(>)=>sub {my$m=$_[0]->can('is_subtype_of');$m->(reverse _swap @_)},q(<=)=>sub {my$m=$_[0]->can('is_a_type_of');$m->(_swap @_)},q(>=)=>sub {my$m=$_[0]->can('is_a_type_of');$m->(reverse _swap @_)},q(eq)=>sub {"$_[0]" eq "$_[1]"},q(cmp)=>sub {$_[2]? ("$_[1]" cmp "$_[0]"): ("$_[0]" cmp "$_[1]")},fallback=>1,;BEGIN {overload->import(q(~~)=>sub {$_[0]->check($_[1])})if Type::Tiny::SUPPORT_SMARTMATCH}sub _overload_coderef {my$self=shift;$self->message unless exists$self->{message};if (!exists($self->{message})&& exists(&Sub::Quote::quote_sub)&& $self->can_be_inlined){$self->{_overload_coderef}=Sub::Quote::quote_sub($self->inline_assert('$_[0]'))if!$self->{_overload_coderef}||!$self->{_sub_quoted}++}else {$self->{_overload_coderef}||=sub {$self->assert_return(@_)}}$self->{_overload_coderef}}our%ALL_TYPES;my$QFS;my$uniq=1;sub new {my$class=shift;my%params=(@_==1)? %{$_[0]}: @_;if (exists$params{parent}){$params{parent}=ref($params{parent})=~ /^Type::Tiny\b/ ? $params{parent}: Types::TypeTiny::to_TypeTiny($params{parent});_croak "Parent must be an instance of %s",__PACKAGE__ unless blessed($params{parent})&& $params{parent}->isa(__PACKAGE__)}$params{name}="__ANON__" unless exists$params{name};$params{uniq}=$uniq++;if ($params{name}ne "__ANON__"){$params{name}=~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm or eval q( use 5.008; $params{name} =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm ) or _croak '"%s" is not a valid type name',$params{name}}if (exists$params{coercion}and!ref$params{coercion}and $params{coercion}){$params{parent}->has_coercion or _croak "coercion => 1 requires type to have a direct parent with a coercion";$params{coercion}=$params{parent}->coercion}if (!exists$params{inlined}and exists$params{constraint}and (!exists$params{parent}or $params{parent}->can_be_inlined)and $QFS ||="Sub::Quote"->can("quoted_from_sub")){my (undef,$perlstring,$captures)=@{$QFS->($params{constraint})|| []};$params{inlined}=sub {my ($self,$var)=@_;my$code=Sub::Quote::inlinify($var eq q($_) ? $perlstring : "local \$_ = $var; $perlstring",$var,);$code=sprintf('%s and %s',$self->parent->inline_check($var),$code)if$self->has_parent;return$code}if$perlstring &&!$captures}my$self=bless \%params,$class;unless ($params{tmp}){my$uniq=$self->{uniq};$ALL_TYPES{$uniq}=$self;weaken($ALL_TYPES{$uniq});$Moo::HandleMoose::TYPE_MAP{overload::StrVal($self)}=sub {$ALL_TYPES{$uniq}}}if (ref($params{coercion})eq q(CODE)){require Types::Standard;my$code=delete($params{coercion});$self->{coercion}=$self->_build_coercion;$self->coercion->add_type_coercions(Types::Standard::Any(),$code)}elsif (ref($params{coercion})eq q(ARRAY)){my$arr=delete($params{coercion});$self->{coercion}=$self->_build_coercion;$self->coercion->add_type_coercions(@$arr)}$self->{type_constraints}||=undef;return$self}sub DESTROY {my$self=shift;delete($ALL_TYPES{$self->{uniq}});delete($Moo::HandleMoose::TYPE_MAP{overload::StrVal($self)});return}sub _clone {my$self=shift;my%opts;$opts{$_}=$self->{$_}for qw<name display_name message>;$self->create_child_type(%opts)}our$DD;sub _dd {@_=$_ unless @_;my ($value)=@_;goto$DD if ref($DD)eq q(CODE);require B;!defined$value ? 'Undef' : !ref$value ? sprintf('Value %s',B::perlstring($value)): do {my$N=0 + (defined($DD)? $DD : 72);require Data::Dumper;local$Data::Dumper::Indent=0;local$Data::Dumper::Useqq=1;local$Data::Dumper::Terse=1;local$Data::Dumper::Sortkeys=1;local$Data::Dumper::Maxdepth=2;my$str=Data::Dumper::Dumper($value);$str=substr($str,0,$N - 12).'...'.substr($str,-1,1)if length($str)>= $N;"Reference $str"}}sub _loose_to_TypeTiny {map +(ref($_)? Types::TypeTiny::to_TypeTiny($_): do {require Type::Utils;Type::Utils::dwim_type($_)}),@_}sub name {$_[0]{name}}sub display_name {$_[0]{display_name}||=$_[0]->_build_display_name}sub parent {$_[0]{parent}}sub constraint {$_[0]{constraint}||=$_[0]->_build_constraint}sub compiled_check {$_[0]{compiled_type_constraint}||=$_[0]->_build_compiled_check}sub coercion {$_[0]{coercion}||=$_[0]->_build_coercion}sub message {$_[0]{message}}sub library {$_[0]{library}}sub inlined {$_[0]{inlined}}sub constraint_generator {$_[0]{constraint_generator}}sub inline_generator {$_[0]{inline_generator}}sub name_generator {$_[0]{name_generator}||=$_[0]->_build_name_generator}sub coercion_generator {$_[0]{coercion_generator}}sub parameters {$_[0]{parameters}}sub moose_type {$_[0]{moose_type}||=$_[0]->_build_moose_type}sub mouse_type {$_[0]{mouse_type}||=$_[0]->_build_mouse_type}sub deep_explanation {$_[0]{deep_explanation}}sub has_parent {exists $_[0]{parent}}sub has_library {exists $_[0]{library}}sub has_coercion {$_[0]{coercion}and!!@{$_[0]{coercion}->type_coercion_map}}sub has_inlined {exists $_[0]{inlined}}sub has_constraint_generator {exists $_[0]{constraint_generator}}sub has_inline_generator {exists $_[0]{inline_generator}}sub has_coercion_generator {exists $_[0]{coercion_generator}}sub has_parameters {exists $_[0]{parameters}}sub has_message {defined $_[0]{message}}sub has_deep_explanation {exists $_[0]{deep_explanation}}sub _default_message {$_[0]{_default_message}||=$_[0]->_build_default_message}sub _assert_coercion {my$self=shift;_croak "No coercion for this type constraint" unless$self->has_coercion && @{$self->coercion->type_coercion_map};return$self->coercion}my$null_constraint=sub {!!1};sub _build_display_name {shift->name}sub _build_constraint {return$null_constraint}sub _is_null_constraint {shift->constraint==$null_constraint}sub _build_coercion {require Type::Coercion;my$self=shift;my%opts=(type_constraint=>$self);$opts{display_name}="to_$self" unless$self->is_anon;return "Type::Coercion"->new(%opts)}sub _build_default_message {my$self=shift;return sub {sprintf '%s did not pass type constraint',_dd($_[0])}if "$self" eq "__ANON__";my$name="$self";return sub {sprintf '%s did not pass type constraint "%s"',_dd($_[0]),$name}}sub _build_name_generator {my$self=shift;return sub {my ($s,@a)=@_;sprintf('%s[%s]',$s,join q[,],@a)}}sub _build_compiled_check {my$self=shift;if ($self->_is_null_constraint and $self->has_parent){return$self->parent->compiled_check}if ($INC{'Mouse/Util.pm'}and Mouse::Util::MOUSE_XS()){require Mouse::Util::TypeConstraints;if ($self->{_is_core}){my$xs="Mouse::Util::TypeConstraints"->can($self->name);return$xs if$xs}elsif ($self->is_parameterized and $self->has_parent and $self->parent->{_is_core}and $self->parent->name =~ /^(ArrayRef|HashRef|Maybe)$/){my$xs="Mouse::Util::TypeConstraints"->can("_parameterize_".$self->parent->name."_for");return$xs->($self->parameters->[0])if$xs}}return Eval::TypeTiny::eval_closure(source=>sprintf('sub ($) { %s }',$self->inline_check('$_[0]')),description=>sprintf("compiled check '%s'",$self),)if$self->can_be_inlined;my@constraints;push@constraints,$self->parent->compiled_check if$self->has_parent;push@constraints,$self->constraint if!$self->_is_null_constraint;return$null_constraint unless@constraints;return sub ($) {local $_=$_[0];for my$c (@constraints){return unless$c->(@_)}return!!1}}sub equals {my ($self,$other)=_loose_to_TypeTiny(@_);return unless blessed($self)&& $self->isa("Type::Tiny");return unless blessed($other)&& $other->isa("Type::Tiny");return!!1 if refaddr($self)==refaddr($other);return!!1 if$self->has_parent && $self->_is_null_constraint && $self->parent==$other;return!!1 if$other->has_parent && $other->_is_null_constraint && $other->parent==$self;return!!1 if refaddr($self->compiled_check)==refaddr($other->compiled_check);return$self->qualified_name eq $other->qualified_name if$self->has_library &&!$self->is_anon && $other->has_library &&!$other->is_anon;return$self->inline_check('$x')eq $other->inline_check('$x')if$self->can_be_inlined && $other->can_be_inlined;return}sub is_subtype_of {my ($self,$other)=_loose_to_TypeTiny(@_);return unless blessed($self)&& $self->isa("Type::Tiny");return unless blessed($other)&& $other->isa("Type::Tiny");return unless$self->has_parent;$self->parent->equals($other)or $self->parent->is_subtype_of($other)}sub is_supertype_of {my ($self,$other)=_loose_to_TypeTiny(@_);return unless blessed($self)&& $self->isa("Type::Tiny");return unless blessed($other)&& $other->isa("Type::Tiny");$other->is_subtype_of($self)}sub is_a_type_of {my ($self,$other)=_loose_to_TypeTiny(@_);return unless blessed($self)&& $self->isa("Type::Tiny");return unless blessed($other)&& $other->isa("Type::Tiny");$self->equals($other)or $self->is_subtype_of($other)}sub strictly_equals {my ($self,$other)=_loose_to_TypeTiny(@_);return unless blessed($self)&& $self->isa("Type::Tiny");return unless blessed($other)&& $other->isa("Type::Tiny");$self->{uniq}==$other->{uniq}}sub is_strictly_subtype_of {my ($self,$other)=_loose_to_TypeTiny(@_);return unless blessed($self)&& $self->isa("Type::Tiny");return unless blessed($other)&& $other->isa("Type::Tiny");return unless$self->has_parent;$self->parent->strictly_equals($other)or $self->parent->is_strictly_subtype_of($other)}sub is_strictly_supertype_of {my ($self,$other)=_loose_to_TypeTiny(@_);return unless blessed($self)&& $self->isa("Type::Tiny");return unless blessed($other)&& $other->isa("Type::Tiny");$other->is_strictly_subtype_of($self)}sub is_strictly_a_type_of {my ($self,$other)=_loose_to_TypeTiny(@_);return unless blessed($self)&& $self->isa("Type::Tiny");return unless blessed($other)&& $other->isa("Type::Tiny");$self->strictly_equals($other)or $self->is_strictly_subtype_of($other)}sub qualified_name {my$self=shift;(exists$self->{library}and $self->name ne "__ANON__")? "$self->{library}::$self->{name}" : $self->{name}}sub is_anon {my$self=shift;$self->name eq "__ANON__"}sub parents {my$self=shift;return unless$self->has_parent;return ($self->parent,$self->parent->parents)}sub check {my$self=shift;($self->{compiled_type_constraint}||=$self->_build_compiled_check)->(@_)}sub _strict_check {my$self=shift;local $_=$_[0];my@constraints=reverse map {$_->constraint}grep {not $_->_is_null_constraint}($self,$self->parents);for my$c (@constraints){return unless$c->(@_)}return!!1}sub get_message {my$self=shift;local $_=$_[0];$self->has_message ? $self->message->(@_): $self->_default_message->(@_)}sub validate {my$self=shift;return undef if ($self->{compiled_type_constraint}||=$self->_build_compiled_check)->(@_);local $_=$_[0];return$self->get_message(@_)}sub validate_explain {my$self=shift;my ($value,$varname)=@_;$varname='$_' unless defined$varname;return undef if$self->check($value);if ($self->has_parent){my$parent=$self->parent->validate_explain($value,$varname);return [sprintf('"%s" is a subtype of "%s"',$self,$self->parent),@$parent ]if$parent}my$message=sprintf('%s%s',$self->get_message($value),$varname eq q{$_} ? '' : sprintf(' (in %s)',$varname),);if ($self->is_parameterized and $self->parent->has_deep_explanation){my$deep=$self->parent->deep_explanation->($self,$value,$varname);return [$message,@$deep ]if$deep}return [$message,sprintf('"%s" is defined as: %s',$self,$self->_perlcode)]}my$b;sub _perlcode {my$self=shift;return$self->inline_check('$_')if$self->can_be_inlined;$b ||=do {require B::Deparse;my$tmp="B::Deparse"->new;$tmp->ambient_pragmas(strict=>"all",warnings=>"all")if$tmp->can('ambient_pragmas');$tmp};my$code=$b->coderef2text($self->constraint);$code =~ s/\s+/ /g;return "sub $code"}sub assert_valid {my$self=shift;return!!1 if ($self->{compiled_type_constraint}||=$self->_build_compiled_check)->(@_);local $_=$_[0];$self->_failed_check("$self",$_)}sub assert_return {my$self=shift;return $_[0]if ($self->{compiled_type_constraint}||=$self->_build_compiled_check)->(@_);local $_=$_[0];$self->_failed_check("$self",$_)}sub can_be_inlined {my$self=shift;return$self->parent->can_be_inlined if$self->has_parent && $self->_is_null_constraint;return!!1 if!$self->has_parent && $self->_is_null_constraint;return$self->has_inlined}sub inline_check {my$self=shift;_croak 'Cannot inline type constraint check for "%s"',$self unless$self->can_be_inlined;return$self->parent->inline_check(@_)if$self->has_parent && $self->_is_null_constraint;return '(!!1)' if!$self->has_parent && $self->_is_null_constraint;local $_=$_[0];my@r=$self->inlined->($self,@_);if (@r and not defined$r[0]){_croak 'Inlining type constraint check for "%s" returned undef!',$self unless$self->has_parent;$r[0]=$self->parent->inline_check(@_)}my$r=join " && "=>map {/[;{}]/ ? "do { $_ }" : "($_)"}@r;return@r==1 ? $r : "($r)"}sub inline_assert {require B;my$self=shift;my$varname=$_[0];my$code=sprintf(q[do { no warnings "void"; %s ? %s : Type::Tiny::_failed_check(%d, %s, %s) };],$self->inline_check(@_),$varname,$self->{uniq},B::perlstring("$self"),$varname,);return$code}sub _failed_check {require Error::TypeTiny::Assertion;my ($self,$name,$value,%attrs)=@_;$self=$ALL_TYPES{$self}unless ref$self;my$exception_class=delete($attrs{exception_class})|| "Error::TypeTiny::Assertion";if ($self){$exception_class->throw(message=>$self->get_message($value),type=>$self,value=>$value,%attrs,)}else {$exception_class->throw(message=>sprintf('%s did not pass type constraint "%s"',_dd($value),$name),value=>$value,%attrs,)}}sub coerce {my$self=shift;$self->_assert_coercion->coerce(@_)}sub assert_coerce {my$self=shift;$self->_assert_coercion->assert_coerce(@_)}sub is_parameterizable {shift->has_constraint_generator}sub is_parameterized {shift->has_parameters}my%param_cache;sub parameterize {my$self=shift;$self->is_parameterizable or @_ ? _croak("Type '%s' does not accept parameters","$self"): return($self);@_=map Types::TypeTiny::to_TypeTiny($_),@_;my$key;if (not grep(ref($_)&&!Types::TypeTiny::TypeTiny->check($_),@_)){require B;$key=join ":",map(Types::TypeTiny::TypeTiny->check($_)? $_->{uniq}: B::perlstring($_),$self,@_)}return$param_cache{$key}if defined$key && defined$param_cache{$key};local$Type::Tiny::parameterize_type=$self;local $_=$_[0];my$P;my$constraint=$self->constraint_generator->(@_);if (Types::TypeTiny::TypeTiny->check($constraint)){$P=$constraint}else {my%options=(constraint=>$constraint,display_name=>$self->name_generator->($self,@_),parameters=>[@_],);$options{inlined}=$self->inline_generator->(@_)if$self->has_inline_generator;exists$options{$_}&&!defined$options{$_}&& delete$options{$_}for keys%options;$P=$self->create_child_type(%options);my$coercion;$coercion=$self->coercion_generator->($self,$P,@_)if$self->has_coercion_generator;$P->coercion->add_type_coercions(@{$coercion->type_coercion_map})if$coercion}if (defined$key){$param_cache{$key}=$P;weaken($param_cache{$key})}return$P}sub child_type_class {__PACKAGE__}sub create_child_type {my$self=shift;return$self->child_type_class->new(parent=>$self,@_)}sub complementary_type {my$self=shift;my$r=($self->{complementary_type}||=$self->_build_complementary_type);weaken($self->{complementary_type})unless isweak($self->{complementary_type});return$r}sub _build_complementary_type {my$self=shift;my%opts=(constraint=>sub {not $self->check($_)},display_name=>sprintf("~%s",$self),);$opts{display_name}=~ s/^\~{2}//;$opts{inlined}=sub {shift;"not(".$self->inline_check(@_).")"}if$self->can_be_inlined;return "Type::Tiny"->new(%opts)}sub _instantiate_moose_type {my$self=shift;my%opts=@_;require Moose::Meta::TypeConstraint;return "Moose::Meta::TypeConstraint"->new(%opts)}sub _build_moose_type {my$self=shift;my$r;if ($self->{_is_core}){require Moose::Util::TypeConstraints;$r=Moose::Util::TypeConstraints::find_type_constraint($self->name);$r->{"Types::TypeTiny::to_TypeTiny"}=$self;Scalar::Util::weaken($r->{"Types::TypeTiny::to_TypeTiny"})}else {my%opts;$opts{name}=$self->qualified_name if$self->has_library &&!$self->is_anon;$opts{parent}=$self->parent->moose_type if$self->has_parent;$opts{constraint}=$self->constraint unless$self->_is_null_constraint;$opts{message}=$self->message if$self->has_message;$opts{inlined}=$self->inlined if$self->has_inlined;$r=$self->_instantiate_moose_type(%opts);$r->{"Types::TypeTiny::to_TypeTiny"}=$self;$self->{moose_type}=$r;$r->coercion($self->coercion->moose_coercion)if$self->has_coercion}return$r}sub _build_mouse_type {my$self=shift;my%options;$options{name}=$self->qualified_name if$self->has_library &&!$self->is_anon;$options{parent}=$self->parent->mouse_type if$self->has_parent;$options{constraint}=$self->constraint unless$self->_is_null_constraint;$options{message}=$self->message if$self->has_message;require Mouse::Meta::TypeConstraint;my$r="Mouse::Meta::TypeConstraint"->new(%options);$self->{mouse_type}=$r;$r->_add_type_coercions($self->coercion->freeze->_codelike_type_coercion_map('mouse_type'))if$self->has_coercion;return$r}sub plus_coercions {my$self=shift;my@more=(@_==1 && blessed($_[0])&& $_[0]->can('type_coercion_map'))? @{$_[0]->type_coercion_map}: (@_==1 && ref $_[0])? @{$_[0]}: @_;my$new=$self->_clone;$new->coercion->add_type_coercions(@more,@{$self->coercion->type_coercion_map},);return$new}sub plus_fallback_coercions {my$self=shift;my@more=(@_==1 && blessed($_[0])&& $_[0]->can('type_coercion_map'))? @{$_[0]->type_coercion_map}: (@_==1 && ref $_[0])? @{$_[0]}: @_;my$new=$self->_clone;$new->coercion->add_type_coercions(@{$self->coercion->type_coercion_map},@more,);return$new}sub minus_coercions {my$self=shift;my@not=(@_==1 && blessed($_[0])&& $_[0]->can('type_coercion_map'))? grep(blessed($_)&&$_->isa("Type::Tiny"),@{$_[0]->type_coercion_map}): (@_==1 && ref $_[0])? @{$_[0]}: @_;my@keep;my$c=$self->coercion->type_coercion_map;for (my$i=0;$i <= $#$c;$i += 2){my$keep_this=1;NOT: for my$n (@not){if ($c->[$i]==$n){$keep_this=0;last NOT}}push@keep,$c->[$i],$c->[$i+1]if$keep_this}my$new=$self->_clone;$new->coercion->add_type_coercions(@keep);return$new}sub no_coercions {shift->_clone}sub coercibles {my$self=shift;$self->has_coercion ? $self->coercion->_source_type_union : $self}sub isa {my$self=shift;if ($INC{"Moose.pm"}and ref($self)){return!!1 if $_[0]eq 'Moose::Meta::TypeConstraint';return$self->is_parameterized if $_[0]eq 'Moose::Meta::TypeConstraint::Parameterized';return$self->is_parameterizable if $_[0]eq 'Moose::Meta::TypeConstraint::Parameterizable'}if ($INC{"Moose.pm"}and ref($self)and $_[0]=~ /^Moose/ and my$r=$self->moose_type->isa(@_)){return$r}if ($INC{"Mouse.pm"}and ref($self)and $_[0]eq 'Mouse::Meta::TypeConstraint'){return!!1}$self->SUPER::isa(@_)}sub can {my$self=shift;return!!0 if $_[0]eq 'type_parameter' && blessed($_[0])&& $_[0]->has_parameters;my$can=$self->SUPER::can(@_);return$can if$can;if ($INC{"Moose.pm"}and ref($self)and my$method=$self->moose_type->can(@_)){return sub {$method->(shift->moose_type,@_)}}return}sub AUTOLOAD {my$self=shift;my ($m)=(our$AUTOLOAD =~ /::(\w+)$/);return if$m eq 'DESTROY';if ($INC{"Moose.pm"}and ref($self)and my$method=$self->moose_type->can($m)){return$method->($self->moose_type,@_)}_croak q[Can't locate object method "%s" via package "%s"],$m,ref($self)||$self}sub DOES {my$self=shift;return!!1 if ref($self)&& $_[0]=~ m{^ Type::API::Constraint (?: ::Coercible | ::Inlinable )? $}x;return!!1 if!ref($self)&& $_[0]eq 'Type::API::Constraint::Constructor';"UNIVERSAL"->can("DOES")? $self->SUPER::DOES(@_): $self->isa(@_)}sub inline_environment {+{}}sub _inline_check {shift->inline_check(@_)}sub _compiled_type_constraint {shift->compiled_check(@_)}sub meta {_croak("Not really a Moose::Meta::TypeConstraint. Sorry!")}sub compile_type_constraint {shift->compiled_check}sub _actually_compile_type_constraint {shift->_build_compiled_check}sub hand_optimized_type_constraint {shift->{hand_optimized_type_constraint}}sub has_hand_optimized_type_constraint {exists(shift->{hand_optimized_type_constraint})}sub type_parameter {my@p=@{shift->parameters || []};@p==1 ? $p[0]: @p}sub __is_parameterized {shift->is_parameterized(@_)}sub _add_type_coercions {shift->coercion->add_type_coercions(@_)};sub _as_string {shift->qualified_name(@_)}sub _compiled_type_coercion {shift->coercion->compiled_coercion(@_)};sub _identity {refaddr(shift)};sub _unite {require Type::Tiny::Union;"Type::Tiny::Union"->new(type_constraints=>\@_)};sub TIESCALAR {require Type::Tie;unshift @_,'Type::Tie::SCALAR';goto \&Type::Tie::SCALAR::TIESCALAR};sub TIEARRAY {require Type::Tie;unshift @_,'Type::Tie::ARRAY';goto \&Type::Tie::SCALAR::TIEARRAY};sub TIEHASH {require Type::Tie;unshift @_,'Type::Tie::HASH';goto \&Type::Tie::SCALAR::TIEHASH};1;
TYPE_TINY

$fatpacked{"Type/Tiny/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_CLASS';
  package Type::Tiny::Class;use 5.006001;use strict;use warnings;BEGIN {if ($] < 5.008){require Devel::TypeTiny::Perl56Compat}}BEGIN {$Type::Tiny::Class::AUTHORITY='cpan:TOBYINK';$Type::Tiny::Class::VERSION='0.034'}use Scalar::Util qw<blessed>;sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}require Type::Tiny;our@ISA='Type::Tiny';sub new {my$proto=shift;return$proto->class->new(@_)if blessed$proto;my%opts=(@_==1)? %{$_[0]}: @_;_croak "Class type constraints cannot have a parent constraint passed to the constructor" if exists$opts{parent};_croak "Class type constraints cannot have a constraint coderef passed to the constructor" if exists$opts{constraint};_croak "Class type constraints cannot have a inlining coderef passed to the constructor" if exists$opts{inlined};_croak "Need to supply class name" unless exists$opts{class};return$proto->SUPER::new(%opts)}sub class {$_[0]{class}}sub inlined {$_[0]{inlined}||=$_[0]->_build_inlined}sub has_inlined {!!1}sub _build_constraint {my$self=shift;my$class=$self->class;return sub {blessed($_)and $_->isa($class)}}sub _build_inlined {my$self=shift;my$class=$self->class;sub {my$var=$_[1];qq{Scalar::Util::blessed($var) and $var->isa(q[$class])}}}sub _build_default_message {no warnings 'uninitialized';my$self=shift;my$c=$self->class;return sub {sprintf '%s did not pass type constraint (not isa %s)',Type::Tiny::_dd($_[0]),$c}if$self->is_anon;my$name="$self";return sub {sprintf '%s did not pass type constraint "%s" (not isa %s)',Type::Tiny::_dd($_[0]),$name,$c}}sub _instantiate_moose_type {my$self=shift;my%opts=@_;delete$opts{parent};delete$opts{constraint};delete$opts{inlined};require Moose::Meta::TypeConstraint::Class;return "Moose::Meta::TypeConstraint::Class"->new(%opts,class=>$self->class)}sub plus_constructors {my$self=shift;unless (@_){require Types::Standard;push @_,Types::Standard::HashRef(),"new"}require B;require Types::TypeTiny;my$class=B::perlstring($self->class);my@r;while (@_){my$source=shift;Types::TypeTiny::TypeTiny->check($source)or _croak "Expected type constraint; got $source";my$constructor=shift;Types::TypeTiny::StringLike->check($constructor)or _croak "Expected string; got $constructor";push@r,$source,sprintf('%s->%s($_)',$class,$constructor)}return$self->plus_coercions(\@r)}sub has_parent {!!1}sub parent {$_[0]{parent}||=$_[0]->_build_parent}sub _build_parent {my$self=shift;my$class=$self->class;my@isa=grep$class->isa($_),do {no strict "refs";no warnings;@{"$class\::ISA"}};if (@isa==0){require Types::Standard;return Types::Standard::Object()}if (@isa==1){return ref($self)->new(class=>$isa[0])}require Type::Tiny::Intersection;"Type::Tiny::Intersection"->new(type_constraints=>[map ref($self)->new(class=>$_),@isa ],)}sub validate_explain {my$self=shift;my ($value,$varname)=@_;$varname='$_' unless defined$varname;return undef if$self->check($value);return ["Not a blessed reference"]unless blessed($value);my@isa;if (eval {require mro}){@isa=@{mro::get_linear_isa(ref$value)}}else {require Class::ISA;@isa=Class::ISA::super_path(ref$value)}my$display_var=$varname eq q{$_} ? '' : sprintf(' (in %s)',$varname);require Type::Utils;return [sprintf('"%s" requires that the reference isa %s',$self,$self->class),sprintf('The reference%s isa %s',$display_var,Type::Utils::english_list(@isa)),]}1;
TYPE_TINY_CLASS

$fatpacked{"Type/Tiny/Duck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_DUCK';
  package Type::Tiny::Duck;use 5.006001;use strict;use warnings;BEGIN {$Type::Tiny::Duck::AUTHORITY='cpan:TOBYINK';$Type::Tiny::Duck::VERSION='0.034'}use Scalar::Util qw<blessed>;sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}require Type::Tiny;our@ISA='Type::Tiny';sub new {my$proto=shift;my%opts=(@_==1)? %{$_[0]}: @_;_croak "Duck type constraints cannot have a parent constraint passed to the constructor" if exists$opts{parent};_croak "Duck type constraints cannot have a constraint coderef passed to the constructor" if exists$opts{constraint};_croak "Duck type constraints cannot have a inlining coderef passed to the constructor" if exists$opts{inlined};_croak "Need to supply list of methods" unless exists$opts{methods};$opts{methods}=[$opts{methods}]unless ref$opts{methods};return$proto->SUPER::new(%opts)}sub methods {$_[0]{methods}}sub inlined {$_[0]{inlined}||=$_[0]->_build_inlined}sub has_inlined {!!1}sub _build_constraint {my$self=shift;my@methods=@{$self->methods};return sub {blessed($_[0])and not grep(!$_[0]->can($_),@methods)}}sub _build_inlined {my$self=shift;my@methods=@{$self->methods};sub {my$var=$_[1];local $"=q{ };qq{ Scalar::Util::blessed($var) and not grep(!$var->can(\$_), qw/@methods/) }}}sub _instantiate_moose_type {my$self=shift;my%opts=@_;delete$opts{parent};delete$opts{constraint};delete$opts{inlined};require Moose::Meta::TypeConstraint::DuckType;return "Moose::Meta::TypeConstraint::DuckType"->new(%opts,methods=>$self->methods)}sub has_parent {!!1}sub parent {require Types::Standard;Types::Standard::Object()}sub validate_explain {my$self=shift;my ($value,$varname)=@_;$varname='$_' unless defined$varname;return undef if$self->check($value);return ["Not a blessed reference"]unless blessed($value);require Type::Utils;return [sprintf('"%s" requires that the reference can %s',$self,Type::Utils::english_list(map qq["$_"],@{$self->methods}),),map sprintf('The reference cannot "%s"',$_),grep!$value->can($_),@{$self->methods}]}1;
TYPE_TINY_DUCK

$fatpacked{"Type/Tiny/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ENUM';
  package Type::Tiny::Enum;use 5.006001;use strict;use warnings;BEGIN {$Type::Tiny::Enum::AUTHORITY='cpan:TOBYINK';$Type::Tiny::Enum::VERSION='0.034'}sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}use overload q[@{}]=>'values';require Type::Tiny;our@ISA='Type::Tiny';sub new {my$proto=shift;my%opts=(@_==1)? %{$_[0]}: @_;_croak "Enum type constraints cannot have a parent constraint passed to the constructor" if exists$opts{parent};_croak "Enum type constraints cannot have a constraint coderef passed to the constructor" if exists$opts{constraint};_croak "Enum type constraints cannot have a inlining coderef passed to the constructor" if exists$opts{inlined};_croak "Need to supply list of values" unless exists$opts{values};my%tmp=map {$_=>1}@{ref$opts{values}eq "ARRAY" ? $opts{values}: [$opts{values}]};$opts{values}=[sort keys%tmp];return$proto->SUPER::new(%opts)}sub values {$_[0]{values}}sub constraint {$_[0]{constraint}||=$_[0]->_build_constraint}sub _build_display_name {my$self=shift;sprintf("Enum[%s]",join q[,],@$self)}sub _build_constraint {my$self=shift;my$regexp=join "|",map quotemeta,@$self;return sub {defined and m{\A(?:$regexp)\z}}}sub can_be_inlined {!!1}sub inline_check {my$self=shift;my$regexp=join "|",map quotemeta,@$self;$_[0]eq '$_' ? "(defined and !ref and m{\\A(?:$regexp)\\z})" : "(defined($_[0]) and !ref($_[0]) and $_[0] =~ m{\\A(?:$regexp)\\z})"}sub _instantiate_moose_type {my$self=shift;my%opts=@_;delete$opts{parent};delete$opts{constraint};delete$opts{inlined};require Moose::Meta::TypeConstraint::Enum;return "Moose::Meta::TypeConstraint::Enum"->new(%opts,values=>$self->values)}sub has_parent {!!1}sub parent {require Types::Standard;Types::Standard::Str()}sub validate_explain {my$self=shift;my ($value,$varname)=@_;$varname='$_' unless defined$varname;return undef if$self->check($value);require Type::Utils;!defined($value)? [sprintf('"%s" requires that the value is defined',$self,),]: @$self < 13 ? [sprintf('"%s" requires that the value is equal to %s',$self,Type::Utils::english_list(\"or",map B::perlstring($_),@$self),),]: [sprintf('"%s" requires that the value is one of an enumerated list of strings',$self,),]}1;
TYPE_TINY_ENUM

$fatpacked{"Type/Tiny/Intersection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_INTERSECTION';
  package Type::Tiny::Intersection;use 5.006001;use strict;use warnings;BEGIN {$Type::Tiny::Intersection::AUTHORITY='cpan:TOBYINK';$Type::Tiny::Intersection::VERSION='0.034'}use Scalar::Util qw<blessed>;use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}use overload q[@{}]=>sub {$_[0]{type_constraints}||=[]};require Type::Tiny;our@ISA='Type::Tiny';sub new {my$proto=shift;my%opts=(@_==1)? %{$_[0]}: @_;_croak "Intersection type constraints cannot have a parent constraint" if exists$opts{parent};_croak "Intersection type constraints cannot have a constraint coderef passed to the constructor" if exists$opts{constraint};_croak "Intersection type constraints cannot have a inlining coderef passed to the constructor" if exists$opts{inlined};_croak "Need to supply list of type constraints" unless exists$opts{type_constraints};$opts{type_constraints}=[map {$_->isa(__PACKAGE__)? @$_ : $_}map Types::TypeTiny::to_TypeTiny($_),@{ref$opts{type_constraints}eq "ARRAY" ? $opts{type_constraints}: [$opts{type_constraints}]}];return$proto->SUPER::new(%opts)}sub type_constraints {$_[0]{type_constraints}}sub constraint {$_[0]{constraint}||=$_[0]->_build_constraint}sub _build_display_name {my$self=shift;join q[&],@$self}sub _build_constraint {my@checks=map $_->compiled_check,@{+shift};return sub {my$val=$_;$_->($val)|| return for@checks;return!!1}}sub can_be_inlined {my$self=shift;not grep!$_->can_be_inlined,@$self}sub inline_check {my$self=shift;sprintf '(%s)',join " and ",map $_->inline_check($_[0]),@$self}sub has_parent {!!@{$_[0]{type_constraints}}}sub parent {$_[0]{type_constraints}[0]}sub validate_explain {my$self=shift;my ($value,$varname)=@_;$varname='$_' unless defined$varname;return undef if$self->check($value);require Type::Utils;for my$type (@$self){my$deep=$type->validate_explain($value,$varname);return [sprintf('"%s" requires that the value pass %s',$self,Type::Utils::english_list(map qq["$_"],@$self),),@$deep,]if$deep}return ["Mysterious!"]}1;
TYPE_TINY_INTERSECTION

$fatpacked{"Type/Tiny/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ROLE';
  package Type::Tiny::Role;use 5.006001;use strict;use warnings;BEGIN {$Type::Tiny::Role::AUTHORITY='cpan:TOBYINK';$Type::Tiny::Role::VERSION='0.034'}use Scalar::Util qw<blessed weaken>;sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}require Type::Tiny;our@ISA='Type::Tiny';my%cache;sub new {my$proto=shift;my%opts=(@_==1)? %{$_[0]}: @_;_croak "Role type constraints cannot have a parent constraint passed to the constructor" if exists$opts{parent};_croak "Role type constraints cannot have a constraint coderef passed to the constructor" if exists$opts{constraint};_croak "Role type constraints cannot have a inlining coderef passed to the constructor" if exists$opts{inlined};_croak "Need to supply role name" unless exists$opts{role};return$proto->SUPER::new(%opts)}sub role {$_[0]{role}}sub inlined {$_[0]{inlined}||=$_[0]->_build_inlined}sub has_inlined {!!1}sub _build_constraint {my$self=shift;my$role=$self->role;return sub {blessed($_)and do {my$method=$_->can('DOES')||$_->can('isa');$_->$method($role)}}}sub _build_inlined {my$self=shift;my$role=$self->role;sub {my$var=$_[1];qq{Scalar::Util::blessed($var) and do { my \$method = $var->can('DOES')||$var->can('isa'); $var->\$method(q[$role]) }}}}sub _build_default_message {my$self=shift;my$c=$self->role;return sub {sprintf '%s did not pass type constraint (not DOES %s)',Type::Tiny::_dd($_[0]),$c}if$self->is_anon;my$name="$self";return sub {sprintf '%s did not pass type constraint "%s" (not DOES %s)',Type::Tiny::_dd($_[0]),$name,$c}}sub has_parent {!!1}sub parent {require Types::Standard;Types::Standard::Object()}sub validate_explain {my$self=shift;my ($value,$varname)=@_;$varname='$_' unless defined$varname;return undef if$self->check($value);return ["Not a blessed reference"]unless blessed($value);return ["Reference provides no DOES method to check roles"]unless$value->can('DOES');my$display_var=$varname eq q{$_} ? '' : sprintf(' (in %s)',$varname);return [sprintf('"%s" requires that the reference does %s',$self,$self->role),sprintf("The reference%s doesn't %s",$display_var,$self->role),]}1;
TYPE_TINY_ROLE

$fatpacked{"Type/Tiny/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_UNION';
  package Type::Tiny::Union;use 5.006001;use strict;use warnings;BEGIN {$Type::Tiny::Union::AUTHORITY='cpan:TOBYINK';$Type::Tiny::Union::VERSION='0.034'}use Scalar::Util qw<blessed>;use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}use overload q[@{}]=>sub {$_[0]{type_constraints}||=[]};require Type::Tiny;our@ISA='Type::Tiny';sub new {my$proto=shift;my%opts=(@_==1)? %{$_[0]}: @_;_croak "Union type constraints cannot have a parent constraint passed to the constructor" if exists$opts{parent};_croak "Union type constraints cannot have a constraint coderef passed to the constructor" if exists$opts{constraint};_croak "Union type constraints cannot have a inlining coderef passed to the constructor" if exists$opts{inlined};_croak "Need to supply list of type constraints" unless exists$opts{type_constraints};$opts{type_constraints}=[map {$_->isa(__PACKAGE__)? @$_ : $_}map Types::TypeTiny::to_TypeTiny($_),@{ref$opts{type_constraints}eq "ARRAY" ? $opts{type_constraints}: [$opts{type_constraints}]}];my$self=$proto->SUPER::new(%opts);$self->coercion if grep $_->has_coercion,@$self;return$self}sub type_constraints {$_[0]{type_constraints}}sub constraint {$_[0]{constraint}||=$_[0]->_build_constraint}sub _build_display_name {my$self=shift;join q[|],@$self}sub _build_coercion {require Type::Coercion::Union;my$self=shift;return "Type::Coercion::Union"->new(type_constraint=>$self)}sub _build_constraint {my@checks=map $_->compiled_check,@{+shift};return sub {my$val=$_;$_->($val)&& return!!1 for@checks;return}}sub can_be_inlined {my$self=shift;not grep!$_->can_be_inlined,@$self}sub inline_check {my$self=shift;sprintf '(%s)',join " or ",map $_->inline_check($_[0]),@$self}sub _instantiate_moose_type {my$self=shift;my%opts=@_;delete$opts{parent};delete$opts{constraint};delete$opts{inlined};my@tc=map $_->moose_type,@{$self->type_constraints};require Moose::Meta::TypeConstraint::Union;return "Moose::Meta::TypeConstraint::Union"->new(%opts,type_constraints=>\@tc)}sub has_parent {defined(shift->parent)}sub parent {$_[0]{parent}||=$_[0]->_build_parent}sub _build_parent {my$self=shift;my ($first,@rest)=@$self;for my$parent ($first,$first->parents){return$parent unless grep!$_->is_a_type_of($parent),@rest}return}sub find_type_for {my@types=@{+shift};for my$type (@types){return$type if$type->check(@_)}return}sub validate_explain {my$self=shift;my ($value,$varname)=@_;$varname='$_' unless defined$varname;return undef if$self->check($value);require Type::Utils;return [sprintf('"%s" requires that the value pass %s',$self,Type::Utils::english_list(\"or",map qq["$_"],@$self),),map {$_->get_message($value),map("    $_",@{$_->validate_explain($value)|| []}),}@$self ]}1;
TYPE_TINY_UNION

$fatpacked{"Type/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_UTILS';
  package Type::Utils;use 5.006001;use strict;use warnings;BEGIN {$Type::Utils::AUTHORITY='cpan:TOBYINK';$Type::Utils::VERSION='0.034'}sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}use Scalar::Util qw<blessed>;use Type::Library;use Type::Tiny;use Types::TypeTiny qw<TypeTiny to_TypeTiny HashLike StringLike CodeLike>;our@EXPORT=qw<declare as where message inline_as class_type role_type duck_type union intersection enum coerce from via declare_coercion to_type>;our@EXPORT_OK=(@EXPORT,qw<extends type subtype match_on_type compile_match_on_type dwim_type english_list>,);require Exporter::Tiny;our@ISA='Exporter::Tiny';sub extends {_croak "Not a type library" unless caller->isa("Type::Library");my$caller=caller->meta;for my$lib (@_){eval "use $lib; 1" or _croak "Could not load library '$lib': $@";if ($lib->isa("Type::Library")or $lib eq 'Types::TypeTiny'){$caller->add_type($lib->get_type($_))for sort$lib->meta->type_names;$caller->add_coercion($lib->get_coercion($_))for sort$lib->meta->coercion_names}elsif ($lib->isa('MooseX::Types::Base')){require Moose::Util::TypeConstraints;my$types=$lib->type_storage;for my$name (sort keys %$types){my$moose=Moose::Util::TypeConstraints::find_type_constraint($types->{$name});my$tt=Types::TypeTiny::to_TypeTiny($moose);$caller->add_type($tt->create_child_type(library=>$caller,name=>$name,coercion=>$moose->has_coercion ? 1 : 0))}}elsif ($lib->isa('MouseX::Types::Base')){require Mouse::Util::TypeConstraints;my$types=$lib->type_storage;for my$name (sort keys %$types){my$mouse=Mouse::Util::TypeConstraints::find_type_constraint($types->{$name});my$tt=Types::TypeTiny::to_TypeTiny($mouse);$caller->add_type($tt->create_child_type(library=>$caller,name=>$name,coercion=>$mouse->has_coercion ? 1 : 0))}}else {_croak("'$lib' is not a type constraint library")}}}sub declare {my%opts;if (@_ % 2==0){%opts=@_}else {(my($name),%opts)=@_;_croak "Cannot provide two names for type" if exists$opts{name};$opts{name}=$name}my$caller=caller($opts{_caller_level}|| 0);$opts{library}=$caller;if (defined$opts{parent}){$opts{parent}=to_TypeTiny($opts{parent});unless (TypeTiny->check($opts{parent})){$caller->isa("Type::Library")or _croak("Parent type cannot be a %s",ref($opts{parent})||'non-reference scalar');$opts{parent}=$caller->meta->get_type($opts{parent})or _croak("Could not find parent type")}}my$type;if (defined$opts{parent}){$type=delete($opts{parent})->create_child_type(%opts)}else {my$bless=delete($opts{bless})|| "Type::Tiny";eval "require $bless";$type=$bless->new(%opts)}if ($caller->isa("Type::Library")){$caller->meta->add_type($type)unless$type->is_anon}return$type}*subtype=\&declare;*type=\&declare;sub as (@) {parent=>@_}sub where (&;@) {constraint=>@_}sub message (&;@) {message=>@_}sub inline_as (&;@) {inlined=>@_}sub class_type {my$name=ref($_[0])? undef : shift;my%opts=%{+shift};if (defined$name){$opts{name}=$name unless exists$opts{name};$opts{class}=$name unless exists$opts{class}}$opts{bless}="Type::Tiny::Class";{no warnings "numeric";$opts{_caller_level}++}declare(%opts)}sub role_type {my$name=ref($_[0])? undef : shift;my%opts=%{+shift};if (defined$name){$opts{name}=$name unless exists$opts{name};$opts{role}=$name unless exists$opts{role}}$opts{bless}="Type::Tiny::Role";{no warnings "numeric";$opts{_caller_level}++}declare(%opts)}sub duck_type {my$name=ref($_[0])? undef : shift;my@methods=@{+shift};my%opts;$opts{name}=$name if defined$name;$opts{methods}=\@methods;$opts{bless}="Type::Tiny::Duck";{no warnings "numeric";$opts{_caller_level}++}declare(%opts)}sub enum {my$name=ref($_[0])? undef : shift;my@values=@{+shift};my%opts;$opts{name}=$name if defined$name;$opts{values}=\@values;$opts{bless}="Type::Tiny::Enum";{no warnings "numeric";$opts{_caller_level}++}declare(%opts)}sub union {my$name=ref($_[0])? undef : shift;my@tcs=@{+shift};my%opts;$opts{name}=$name if defined$name;$opts{type_constraints}=\@tcs;$opts{bless}="Type::Tiny::Union";{no warnings "numeric";$opts{_caller_level}++}declare(%opts)}sub intersection {my$name=ref($_[0])? undef : shift;my@tcs=@{+shift};my%opts;$opts{name}=$name if defined$name;$opts{type_constraints}=\@tcs;$opts{bless}="Type::Tiny::Intersection";{no warnings "numeric";$opts{_caller_level}++}declare(%opts)}sub declare_coercion {my%opts;$opts{name}=shift if!ref($_[0]);while (HashLike->check($_[0])and not TypeTiny->check($_[0])){%opts=(%opts,%{+shift})}my$caller=caller($opts{_caller_level}|| 0);$opts{library}=$caller;my$bless=delete($opts{bless})|| "Type::Coercion";eval "require $bless";my$c=$bless->new(%opts);my@C;if ($caller->isa("Type::Library")){my$meta=$caller->meta;$meta->add_coercion($c)unless$c->is_anon;while (@_){push@C,map {ref($_)? to_TypeTiny($_): $meta->get_type($_)||$_}shift;push@C,shift}}$c->add_type_coercions(@C);return$c->freeze}sub coerce {if ((scalar caller)->isa("Type::Library")){my$meta=(scalar caller)->meta;my ($type)=map {ref($_)? to_TypeTiny($_): $meta->get_type($_)||$_}shift;my@opts;while (@_){push@opts,map {ref($_)? to_TypeTiny($_): $meta->get_type($_)||$_}shift;push@opts,shift}return$type->coercion->add_type_coercions(@opts)}my ($type,@opts)=@_;$type=to_TypeTiny($type);return$type->coercion->add_type_coercions(@opts)}sub from (@) {return @_}sub to_type (@) {my$type=shift;unless (TypeTiny->check($type)){caller->isa("Type::Library")or _croak "Target type cannot be a string";$type=caller->meta->get_type($type)or _croak "Could not find target type"}return +{type_constraint=>$type },@_}sub via (&;@) {return @_}sub match_on_type {my$value=shift;while (@_){my ($type,$code);if (@_==1){require Types::Standard;($type,$code)=(Types::Standard::Any(),shift)}else {($type,$code)=splice(@_,0,2);TypeTiny->($type)}$type->check($value)or next;if (StringLike->check($code)){local $_=$value;if (wantarray){my@r=eval "$code";die $@ if $@;return@r}if (defined wantarray){my$r=eval "$code";die $@ if $@;return$r}eval "$code";die $@ if $@;return}else {CodeLike->($code);local $_=$value;return$code->($value)}}_croak("No cases matched for %s",Type::Tiny::_dd($value))}sub compile_match_on_type {my@code='sub { local $_ = $_[0]; ';my@checks;my@actions;my$els='';while (@_){my ($type,$code);if (@_==1){require Types::Standard;($type,$code)=(Types::Standard::Any(),shift)}else {($type,$code)=splice(@_,0,2);TypeTiny->($type)}if ($type->can_be_inlined){push@code,sprintf('%sif (%s)',$els,$type->inline_check('$_'))}else {push@checks,$type;push@code,sprintf('%sif ($checks[%d]->check($_))',$els,$#checks)}$els='els';if (StringLike->check($code)){push@code,sprintf('  { %s }',$code)}else {CodeLike->($code);push@actions,$code;push@code,sprintf('  { $actions[%d]->(@_) }',$#actions)}}push@code,'else','  { Type::Util::_croak("No cases matched for %s", Type::Tiny::_dd($_[0])) }';push@code,'}';require Eval::TypeTiny;return Eval::TypeTiny::eval_closure(source=>\@code,environment=>{'@actions'=>\@actions,'@checks'=>\@checks,},)}{package Type::Registry::DWIM;our@ISA=qw(Type::Registry);sub simple_lookup {my$self=shift;my$r;if (defined$self->{"~~chained"}){my$chained="Type::Registry"->for_class($self->{"~~chained"});$r=eval {$chained->simple_lookup(@_)}unless$self==$chained;return$r if defined$r}require Types::Standard;return 'Types::Standard'->get_type($_[0])if 'Types::Standard'->has_type($_[0]);return unless $_[1];if ($INC{'Moose.pm'}){require Moose::Util::TypeConstraints;require Types::TypeTiny;$r=Moose::Util::TypeConstraints::find_type_constraint($_[0]);return Types::TypeTiny::to_TypeTiny($r)if defined$r}if ($INC{'Mouse.pm'}){require Mouse::Util::TypeConstraints;require Types::TypeTiny;$r=Mouse::Util::TypeConstraints::find_type_constraint($_[0]);return Types::TypeTiny::to_TypeTiny($r)if defined$r}return unless $_[0]=~ /^\s*(\w+(::\w+)*)\s*$/sm;return unless defined$self->{"~~assume"};if ($self->{"~~assume"}eq "Type::Tiny::Class"){require Type::Tiny::Class;return "Type::Tiny::Class"->new(class=>$_[0])}if ($self->{"~~assume"}eq "Type::Tiny::Role"){require Type::Tiny::Role;return "Type::Tiny::Role"->new(role=>$_[0])}die}}our$dwimmer;sub dwim_type {my ($string,%opts)=@_;$opts{for}=caller unless defined$opts{for};$dwimmer ||=do {require Type::Registry;'Type::Registry::DWIM'->new};local$dwimmer->{'~~chained'}=$opts{for};local$dwimmer->{'~~assume'}=$opts{does}? 'Type::Tiny::Role' : 'Type::Tiny::Class';$dwimmer->lookup($string)}sub english_list {my$conjunction=ref($_[0])eq 'SCALAR' ? ${+shift}: 'and';my@items=sort @_;return$items[0]if@items==1;return "$items[0] $conjunction $items[1]" if@items==2;my$tail=pop@items;join(', ',@items,"$conjunction $tail")}1;
TYPE_UTILS

$fatpacked{"Types/Common/Numeric.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_NUMERIC';
  package Types::Common::Numeric;use 5.006001;use strict;use warnings;BEGIN {if ($] < 5.008){require Devel::TypeTiny::Perl56Compat}}BEGIN {$Types::Common::Numeric::AUTHORITY='cpan:TOBYINK';$Types::Common::Numeric::VERSION='0.034'}use Type::Library -base,-declare=>qw(PositiveNum PositiveOrZeroNum PositiveInt PositiveOrZeroInt NegativeNum NegativeOrZeroNum NegativeInt NegativeOrZeroInt SingleDigit);use Types::Standard qw(Num Int);my$meta=__PACKAGE__->meta;$meta->add_type(name=>'PositiveNum',parent=>Num,constraint=>sub {$_ > 0},inlined=>sub {undef,qq($_ > 0)},message=>sub {"Must be a positive number"},);$meta->add_type(name=>'PositiveOrZeroNum',parent=>Num,constraint=>sub {$_ >= 0},inlined=>sub {undef,qq($_ >= 0)},message=>sub {"Must be a number greater than or equal to zero"},);$meta->add_type(name=>'PositiveInt',parent=>Int,constraint=>sub {$_ > 0},inlined=>sub {undef,qq($_ > 0)},message=>sub {"Must be a positive integer"},);$meta->add_type(name=>'PositiveOrZeroInt',parent=>Int,constraint=>sub {$_ >= 0},inlined=>sub {undef,qq($_ >= 0)},message=>sub {"Must be an integer greater than or equal to zero"},);$meta->add_type(name=>'NegativeNum',parent=>Num,constraint=>sub {$_ < 0},inlined=>sub {undef,qq($_ < 0)},message=>sub {"Must be a negative number"},);$meta->add_type(name=>'NegativeOrZeroNum',parent=>Num,constraint=>sub {$_ <= 0},inlined=>sub {undef,qq($_ <= 0)},message=>sub {"Must be a number less than or equal to zero"},);$meta->add_type(name=>'NegativeInt',parent=>Int,constraint=>sub {$_ < 0},inlined=>sub {undef,qq($_ < 0)},message=>sub {"Must be a negative integer"},);$meta->add_type(name=>'NegativeOrZeroInt',parent=>Int,constraint=>sub {$_ >= 0},inlined=>sub {undef,qq($_ <= 0)},message=>sub {"Must be an integer less than or equal to zero"},);$meta->add_type(name=>'SingleDigit',parent=>Int,constraint=>sub {$_ >= -9 and $_ <= 9},inlined=>sub {undef,qq($_ >= -9),qq($_ <= 9)},message=>sub {"Must be a single digit"},);1;
TYPES_COMMON_NUMERIC

$fatpacked{"Types/Common/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_STRING';
  package Types::Common::String;use 5.006001;use strict;use warnings;use utf8;BEGIN {if ($] < 5.008){require Devel::TypeTiny::Perl56Compat}}BEGIN {$Types::Common::String::AUTHORITY='cpan:TOBYINK';$Types::Common::String::VERSION='0.034'}use Type::Library -base,-declare=>qw(SimpleStr NonEmptySimpleStr NumericCode LowerCaseSimpleStr UpperCaseSimpleStr Password StrongPassword NonEmptyStr LowerCaseStr UpperCaseStr);use Types::Standard qw(Str);my$meta=__PACKAGE__->meta;$meta->add_type(name=>SimpleStr,parent=>Str,constraint=>sub {length($_)<= 255 and not /\n/},inlined=>sub {undef,qq(length($_) <= 255),qq($_ !~ /\\n/)},message=>sub {"Must be a single line of no more than 255 chars"},);$meta->add_type(name=>NonEmptySimpleStr,parent=>SimpleStr,constraint=>sub {length($_)> 0},inlined=>sub {undef,qq(length($_) > 0)},message=>sub {"Must be a non-empty single line of no more than 255 chars"},);$meta->add_type(name=>NumericCode,parent=>NonEmptySimpleStr,constraint=>sub {/^[0-9]+$/},inlined=>sub {SimpleStr->inline_check($_),qq($_ =~ m/^[0-9]+\$/)},message=>sub {'Must be a non-empty single line of no more than 255 chars that consists ' .'of numeric characters only'},);NumericCode->coercion->add_type_coercions(NonEmptySimpleStr,q[ do { (my $code = $_) =~ s/[[:punct:]]//g; $code } ],);$meta->add_type(name=>Password,parent=>NonEmptySimpleStr,constraint=>sub {length($_)> 3},inlined=>sub {SimpleStr->inline_check($_),qq(length($_) > 3)},message=>sub {"Must be between 4 and 255 chars"},);$meta->add_type(name=>StrongPassword,parent=>Password,constraint=>sub {length($_)> 7 and /[^a-zA-Z]/},inlined=>sub {SimpleStr()->inline_check($_),qq(length($_) > 7),qq($_ =~ /[^a-zA-Z]/)},message=>sub {"Must be between 8 and 255 chars, and contain a non-alpha char"},);$meta->add_type(name=>NonEmptyStr,parent=>Str,constraint=>sub {length($_)> 0},inlined=>sub {undef,qq(length($_) > 0)},message=>sub {"Must not be empty"},);$meta->add_type(name=>LowerCaseStr,parent=>NonEmptyStr,constraint=>sub {!/\p{Upper}/ms},inlined=>sub {undef,qq($_ !~ /\\p{Upper}/ms)},message=>sub {"Must not contain upper case letters"},);LowerCaseStr->coercion->add_type_coercions(NonEmptyStr,q[ lc($_) ],);$meta->add_type(name=>UpperCaseStr,parent=>NonEmptyStr,constraint=>sub {!/\p{Lower}/ms},inlined=>sub {undef,qq($_ !~ /\\p{Lower}/ms)},message=>sub {"Must not contain lower case letters"},);UpperCaseStr->coercion->add_type_coercions(NonEmptyStr,q[ uc($_) ],);$meta->add_type(name=>LowerCaseSimpleStr,parent=>NonEmptySimpleStr,constraint=>sub {!/\p{Upper}/ms},inlined=>sub {undef,qq($_ !~ /\\p{Upper}/ms)},message=>sub {"Must not contain pper case letters"},);LowerCaseSimpleStr->coercion->add_type_coercions(NonEmptySimpleStr,q[ lc($_) ],);$meta->add_type(name=>UpperCaseSimpleStr,parent=>NonEmptySimpleStr,constraint=>sub {!/\p{Lower}/ms},inlined=>sub {undef,qq($_ !~ /\\p{Lower}/ms)},message=>sub {"Must not contain lower case letters"},);UpperCaseSimpleStr->coercion->add_type_coercions(NonEmptySimpleStr,q[ uc($_) ],);1;
TYPES_COMMON_STRING

$fatpacked{"Types/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD';
  package Types::Standard;use 5.006001;use strict;use warnings;BEGIN {eval {require re};if ($] < 5.008){require Devel::TypeTiny::Perl56Compat};if ($] < 5.010){require Devel::TypeTiny::Perl58Compat}}BEGIN {$Types::Standard::AUTHORITY='cpan:TOBYINK';$Types::Standard::VERSION='0.034'}use Type::Library -base;our@EXPORT_OK=qw(slurpy);use Scalar::Util qw(blessed looks_like_number);use Types::TypeTiny ();sub _is_class_loaded {return!!0 if ref $_[0];return!!0 if not $_[0];my$stash=do {no strict 'refs';\%{"$_[0]\::"}};return!!1 if exists$stash->{'ISA'};return!!1 if exists$stash->{'VERSION'};for my$globref (values %$stash){return!!1 if *{$globref}{CODE}}return!!0}sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}my$meta=__PACKAGE__->meta;sub Stringable (&) {package Types::Standard::_Stringable;use overload q[""]=>sub {$_[0]{text}||=$_[0]{code}->()},fallback=>1;bless +{code=>$_[0]}}sub LazyLoad ($$) {package Types::Standard::LazyLoad;use overload fallback=>1,q[&{}]=>sub {my ($typename,$function)=@{$_[0]};my$type=$meta->get_type($typename);my$class="Types::Standard::$typename";eval "require $class; 1" or die($@);for my$key (keys %$type){next unless ref($type->{$key})eq __PACKAGE__;my$f=$type->{$key}[1];$type->{$key}=$class->can("__$f")}return$class->can("__$function")};bless \@_}no warnings;BEGIN {*STRICTNUM=$ENV{PERL_TYPES_STANDARD_STRICTNUM}? sub(){!!1}: sub(){!!0}};my$_any=$meta->add_type({name=>"Any",_is_core=>1,inlined=>sub {"!!1"},});my$_item=$meta->add_type({name=>"Item",_is_core=>1,inlined=>sub {"!!1"},parent=>$_any,});$meta->add_type({name=>"Bool",_is_core=>1,parent=>$_item,constraint=>sub {!defined $_ or $_ eq q() or $_ eq '0' or $_ eq '1'},inlined=>sub {"!defined $_[1] or $_[1] eq q() or $_[1] eq '0' or $_[1] eq '1'"},});my$_undef=$meta->add_type({name=>"Undef",_is_core=>1,parent=>$_item,constraint=>sub {!defined $_},inlined=>sub {"!defined($_[1])"},});my$_def=$meta->add_type({name=>"Defined",_is_core=>1,parent=>$_item,constraint=>sub {defined $_},inlined=>sub {"defined($_[1])"},});my$_val=$meta->add_type({name=>"Value",_is_core=>1,parent=>$_def,constraint=>sub {not ref $_},inlined=>sub {"defined($_[1]) and not ref($_[1])"},});my$_str=$meta->add_type({name=>"Str",_is_core=>1,parent=>$_val,constraint=>sub {ref(\$_)eq 'SCALAR' or ref(\(my$val=$_))eq 'SCALAR'},inlined=>sub {"defined($_[1]) and do { ref(\\$_[1]) eq 'SCALAR' or ref(\\(my \$val = $_[1])) eq 'SCALAR' }"},});my$_laxnum=$meta->add_type({name=>"LaxNum",parent=>$_str,constraint=>sub {looks_like_number $_},inlined=>sub {"defined($_[1]) && !ref($_[1]) && Scalar::Util::looks_like_number($_[1])"},});my$_strictnum=$meta->add_type({name=>"StrictNum",parent=>$_str,constraint=>sub {my$val=$_;($val =~ /\A[+-]?[0-9]+\z/)|| ($val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
  		(?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
  		[0-9]*                                #matches 0-9 zero or more times
  		(?:\.[0-9]+)?                         #matches optional .89 or nothing
  		(?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
  		\z/x)},inlined=>sub {'my $val = '.$_[1].';'.Value()->inline_check('$val').' && ( $val =~ /\A[+-]?[0-9]+\z/ || ' .'$val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
  			(?=[0-9]|\.[0-9])                 # matches previous +- only if there is something like 3 or .3
  			[0-9]*                            # matches 0-9 zero or more times
  			(?:\.[0-9]+)?                     # matches optional .89 or nothing
  			(?:[Ee](?:[+-]?[0-9]+))?          # matches E1 or e1 or e-1 or e+1 etc
  		\z/x ); '},});my$_num=$meta->add_type({name=>"Num",_is_core=>1,parent=>(STRICTNUM ? $_strictnum : $_laxnum),});$meta->add_type({name=>"Int",_is_core=>1,parent=>$_num,constraint=>sub {/\A-?[0-9]+\z/},inlined=>sub {"defined $_[1] and $_[1] =~ /\\A-?[0-9]+\\z/"},});my$_classn=$meta->add_type({name=>"ClassName",_is_core=>1,parent=>$_str,constraint=>sub {goto \&_is_class_loaded},inlined=>sub {"Types::Standard::_is_class_loaded($_[1])"},});$meta->add_type({name=>"RoleName",parent=>$_classn,constraint=>sub {not $_->can("new")},inlined=>sub {"Types::Standard::_is_class_loaded($_[1]) and not $_[1]\->can('new')"},});my$_ref=$meta->add_type({name=>"Ref",_is_core=>1,parent=>$_def,constraint=>sub {ref $_},inlined=>sub {"!!ref($_[1])"},constraint_generator=>sub {return$meta->get_type('Ref')unless @_;my$reftype=shift;Types::TypeTiny::StringLike->check($reftype)or _croak("Parameter to Ref[`a] expected to be string; got $reftype");$reftype="$reftype";return sub {ref($_[0])and Scalar::Util::reftype($_[0])eq $reftype}},inline_generator=>sub {my$reftype=shift;return sub {my$v=$_[1];"ref($v) and Scalar::Util::reftype($v) eq q($reftype)"}},deep_explanation=>sub {require B;my ($type,$value,$varname)=@_;my$param=$type->parameters->[0];return if$type->check($value);my$reftype=Scalar::Util::reftype($value);return [sprintf('"%s" constrains reftype(%s) to be equal to %s',$type,$varname,B::perlstring($param)),sprintf('reftype(%s) is %s',$varname,defined($reftype)? B::perlstring($reftype): "undef"),]},});$meta->add_type({name=>"CodeRef",_is_core=>1,parent=>$_ref,constraint=>sub {ref $_ eq "CODE"},inlined=>sub {"ref($_[1]) eq 'CODE'"},});$meta->add_type({name=>"RegexpRef",_is_core=>1,parent=>$_ref,constraint=>sub {ref($_)&&!!re::is_regexp($_)},inlined=>sub {"ref($_[1]) && !!re::is_regexp($_[1])"},});$meta->add_type({name=>"GlobRef",_is_core=>1,parent=>$_ref,constraint=>sub {ref $_ eq "GLOB"},inlined=>sub {"ref($_[1]) eq 'GLOB'"},});$meta->add_type({name=>"FileHandle",_is_core=>1,parent=>$_ref,constraint=>sub {(ref($_)eq "GLOB" && Scalar::Util::openhandle($_))or (blessed($_)&& $_->isa("IO::Handle"))},inlined=>sub {"(ref($_[1]) eq \"GLOB\" && Scalar::Util::openhandle($_[1])) "."or (Scalar::Util::blessed($_[1]) && $_[1]\->isa(\"IO::Handle\"))"},});my$_arr=$meta->add_type({name=>"ArrayRef",_is_core=>1,parent=>$_ref,constraint=>sub {ref $_ eq "ARRAY"},inlined=>sub {"ref($_[1]) eq 'ARRAY'"},constraint_generator=>LazyLoad(ArrayRef=>'constraint_generator'),inline_generator=>LazyLoad(ArrayRef=>'inline_generator'),deep_explanation=>LazyLoad(ArrayRef=>'deep_explanation'),coercion_generator=>LazyLoad(ArrayRef=>'coercion_generator'),});my$_hash=$meta->add_type({name=>"HashRef",_is_core=>1,parent=>$_ref,constraint=>sub {ref $_ eq "HASH"},inlined=>sub {"ref($_[1]) eq 'HASH'"},constraint_generator=>LazyLoad(HashRef=>'constraint_generator'),inline_generator=>LazyLoad(HashRef=>'inline_generator'),deep_explanation=>LazyLoad(HashRef=>'deep_explanation'),coercion_generator=>LazyLoad(HashRef=>'coercion_generator'),});$meta->add_type({name=>"ScalarRef",_is_core=>1,parent=>$_ref,constraint=>sub {ref $_ eq "SCALAR" or ref $_ eq "REF"},inlined=>sub {"ref($_[1]) eq 'SCALAR' or ref($_[1]) eq 'REF'"},constraint_generator=>LazyLoad(ScalarRef=>'constraint_generator'),inline_generator=>LazyLoad(ScalarRef=>'inline_generator'),deep_explanation=>LazyLoad(ScalarRef=>'deep_explanation'),coercion_generator=>LazyLoad(ScalarRef=>'coercion_generator'),});my$_obj=$meta->add_type({name=>"Object",_is_core=>1,parent=>$_ref,constraint=>sub {blessed $_},inlined=>sub {"Scalar::Util::blessed($_[1])"},});$meta->add_type({name=>"Maybe",_is_core=>1,parent=>$_item,constraint_generator=>sub {return$meta->get_type('Maybe')unless @_;my$param=Types::TypeTiny::to_TypeTiny(shift);Types::TypeTiny::TypeTiny->check($param)or _croak("Parameter to Maybe[`a] expected to be a type constraint; got $param");return sub {my$value=shift;return!!1 unless defined$value;return$param->check($value)}},inline_generator=>sub {my$param=shift;return unless$param->can_be_inlined;return sub {my$v=$_[1];my$param_check=$param->inline_check($v);"!defined($v) or $param_check"}},deep_explanation=>sub {my ($type,$value,$varname)=@_;my$param=$type->parameters->[0];return [sprintf('%s is defined',Type::Tiny::_dd($value)),sprintf('"%s" constrains the value with "%s" if it is defined',$type,$param),@{$param->validate_explain($value,$varname)},]},coercion_generator=>sub {my ($parent,$child,$param)=@_;return unless$param->has_coercion;return$param->coercion},});my$_map=$meta->add_type({name=>"Map",parent=>$_hash,constraint_generator=>LazyLoad(Map=>'constraint_generator'),inline_generator=>LazyLoad(Map=>'inline_generator'),deep_explanation=>LazyLoad(Map=>'deep_explanation'),coercion_generator=>LazyLoad(Map=>'coercion_generator'),});my$_Optional=$meta->add_type({name=>"Optional",parent=>$_item,constraint_generator=>sub {return$meta->get_type('Optional')unless @_;my$param=Types::TypeTiny::to_TypeTiny(shift);Types::TypeTiny::TypeTiny->check($param)or _croak("Parameter to Optional[`a] expected to be a type constraint; got $param");sub {exists($_[0])? $param->check($_[0]):!!1}},inline_generator=>sub {my$param=shift;return unless$param->can_be_inlined;return sub {my$v=$_[1];my$param_check=$param->inline_check($v);"!exists($v) or $param_check"}},deep_explanation=>sub {my ($type,$value,$varname)=@_;my$param=$type->parameters->[0];return [sprintf('%s exists',$varname),sprintf('"%s" constrains %s with "%s" if it exists',$type,$varname,$param),@{$param->validate_explain($value,$varname)},]},coercion_generator=>sub {my ($parent,$child,$param)=@_;return unless$param->has_coercion;return$param->coercion},});sub slurpy {my$t=shift;wantarray ? (+{slurpy=>$t },@_): +{slurpy=>$t }}$meta->add_type({name=>"Tuple",parent=>$_arr,name_generator=>sub {my ($s,@a)=@_;sprintf('%s[%s]',$s,join q[,],map {ref($_)eq "HASH" ? sprintf("slurpy %s",$_->{slurpy}): $_}@a)},constraint_generator=>LazyLoad(Tuple=>'constraint_generator'),inline_generator=>LazyLoad(Tuple=>'inline_generator'),deep_explanation=>LazyLoad(Tuple=>'deep_explanation'),coercion_generator=>LazyLoad(Tuple=>'coercion_generator'),});$meta->add_type({name=>"Dict",parent=>$_hash,name_generator=>sub {my ($s,@p)=@_;my$l=ref($p[-1])eq q(HASH) ? pop(@p)->{slurpy}: undef;my%a=@p;sprintf('%s[%s%s]',$s,join(q[,],map sprintf("%s=>%s",$_,$a{$_}),sort keys%a),$l ? ",slurpy $l" : '')},constraint_generator=>LazyLoad(Dict=>'constraint_generator'),inline_generator=>LazyLoad(Dict=>'inline_generator'),deep_explanation=>LazyLoad(Dict=>'deep_explanation'),coercion_generator=>LazyLoad(Dict=>'coercion_generator'),});use overload ();$meta->add_type({name=>"Overload",parent=>$_obj,constraint=>sub {overload::Overloaded($_)},inlined=>sub {"Scalar::Util::blessed($_[1]) and overload::Overloaded($_[1])"},constraint_generator=>sub {return$meta->get_type('Overload')unless @_;my@operations=map {Types::TypeTiny::StringLike->check($_)? "$_" : _croak("Parameters to Overload[`a] expected to be a strings; got $_")}@_;return sub {my$value=shift;for my$op (@operations){return unless overload::Method($value,$op)}return!!1}},inline_generator=>sub {my@operations=@_;return sub {my$v=$_[1];join " and ","Scalar::Util::blessed($v)",map "overload::Method($v, q[$_])",@operations}},});our%_StrMatch;$meta->add_type({name=>"StrMatch",parent=>$_str,constraint_generator=>sub {return$meta->get_type('StrMatch')unless @_;my ($regexp,$checker)=@_;ref($regexp)eq 'Regexp' or _croak("First parameter to StrMatch[`a] expected to be a Regexp; got $regexp");if (@_ > 1){$checker=Types::TypeTiny::to_TypeTiny($checker);Types::TypeTiny::TypeTiny->check($checker)or _croak("Second parameter to StrMatch[`a] expected to be a type constraint; got $checker")}$checker ? sub {my$value=shift;return if ref($value);my@m=($value =~ $regexp);$checker->check(\@m)}: sub {my$value=shift;!ref($value)and $value =~ $regexp}},inline_generator=>sub {require B;my ($regexp,$checker)=@_;my$regexp_string="$regexp";$_StrMatch{$regexp_string}=$regexp;if ($checker){return unless$checker->can_be_inlined;return sub {my$v=$_[1];sprintf "!ref($v) and do { my \$m = [$v =~ \$Types::Standard::_StrMatch{%s}]; %s }",B::perlstring($regexp_string),$checker->inline_check('$m'),}}else {return sub {my$v=$_[1];sprintf "!ref($v) and $v =~ \$Types::Standard::_StrMatch{%s}",B::perlstring($regexp_string),}}},});$meta->add_type({name=>"OptList",parent=>$_arr,constraint=>sub {for my$inner (@$_){return unless ref($inner)eq q(ARRAY);return unless @$inner==2;return unless is_Str($inner->[0])}return!!1},inlined=>sub {my ($self,$var)=@_;my$Str_check=Str()->inline_check('$inner->[0]');my@code='do { my $ok = 1; ';push@code,sprintf('for my $inner (@{%s}) { no warnings; ',$var);push@code,sprintf('($ok=0) && last unless ref($inner) eq q(ARRAY) && @$inner == 2 && (%s); ',$Str_check);push@code,'} ';push@code,'$ok }';return (undef,join(q( ),@code))},});$meta->add_type({name=>"Tied",parent=>$_ref,constraint=>sub {!!tied(Scalar::Util::reftype($_)eq 'HASH' ? %{$_}: Scalar::Util::reftype($_)eq 'ARRAY' ? @{$_}: ${$_})},inlined=>sub {my ($self,$var)=@_;$self->parent->inline_check($var)." and !!tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var})"},name_generator=>sub {my$self=shift;my$param=Types::TypeTiny::to_TypeTiny(shift);unless (Types::TypeTiny::TypeTiny->check($param)){Types::TypeTiny::StringLike->check($param)or _croak("Parameter to Tied[`a] expected to be a class name; got $param");require B;return sprintf("%s[%s]",$self,B::perlstring($param))}return sprintf("%s[%s]",$self,$param)},constraint_generator=>sub {return$meta->get_type('Tied')unless @_;my$param=Types::TypeTiny::to_TypeTiny(shift);unless (Types::TypeTiny::TypeTiny->check($param)){Types::TypeTiny::StringLike->check($param)or _croak("Parameter to Tied[`a] expected to be a class name; got $param");require Type::Tiny::Class;$param="Type::Tiny::Class"->new(class=>"$param")}my$check=$param->compiled_check;return sub {$check->(tied(Scalar::Util::reftype($_)eq 'HASH' ? %{$_}: Scalar::Util::reftype($_)eq 'ARRAY' ? @{$_}: ${$_}))}},inline_generator=>sub {my$param=Types::TypeTiny::to_TypeTiny(shift);unless (Types::TypeTiny::TypeTiny->check($param)){Types::TypeTiny::StringLike->check($param)or _croak("Parameter to Tied[`a] expected to be a class name; got $param");require Type::Tiny::Class;$param="Type::Tiny::Class"->new(class=>"$param")}return unless$param->can_be_inlined;return sub {require B;my$var=$_[1];sprintf("%s and do { my \$TIED = tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var}); %s }",Ref()->inline_check($var),$param->inline_check('$TIED'))}},});$meta->add_type({name=>"InstanceOf",parent=>$_obj,constraint_generator=>sub {return$meta->get_type('InstanceOf')unless @_;require Type::Tiny::Class;my@classes=map {Types::TypeTiny::TypeTiny->check($_)? $_ : "Type::Tiny::Class"->new(class=>$_,display_name=>sprintf('InstanceOf[%s]',B::perlstring($_)))}@_;return$classes[0]if@classes==1;require B;require Type::Tiny::Union;return "Type::Tiny::Union"->new(type_constraints=>\@classes,display_name=>sprintf('InstanceOf[%s]',join q[,],map B::perlstring($_->class),@classes),)},});$meta->add_type({name=>"ConsumerOf",parent=>$_obj,constraint_generator=>sub {return$meta->get_type('ConsumerOf')unless @_;require B;require Type::Tiny::Role;my@roles=map {Types::TypeTiny::TypeTiny->check($_)? $_ : "Type::Tiny::Role"->new(role=>$_,display_name=>sprintf('ConsumerOf[%s]',B::perlstring($_)))}@_;return$roles[0]if@roles==1;require Type::Tiny::Intersection;return "Type::Tiny::Intersection"->new(type_constraints=>\@roles,display_name=>sprintf('ConsumerOf[%s]',join q[,],map B::perlstring($_->role),@roles),)},});$meta->add_type({name=>"HasMethods",parent=>$_obj,constraint_generator=>sub {return$meta->get_type('HasMethods')unless @_;require B;require Type::Tiny::Duck;return "Type::Tiny::Duck"->new(methods=>\@_,display_name=>sprintf('HasMethods[%s]',join q[,],map B::perlstring($_),@_),)},});$meta->add_type({name=>"Enum",parent=>$_str,constraint_generator=>sub {return$meta->get_type('Enum')unless @_;require B;require Type::Tiny::Enum;return "Type::Tiny::Enum"->new(values=>\@_,display_name=>sprintf('Enum[%s]',join q[,],map B::perlstring($_),@_),)},});$meta->add_coercion({name=>"MkOpt",type_constraint=>$meta->get_type("OptList"),type_coercion_map=>[$_arr,q{ Exporter::Tiny::mkopt($_) },$_hash,q{ Exporter::Tiny::mkopt($_) },$_undef,q{ [] },],});$meta->add_coercion({name=>"Join",type_constraint=>$_str,coercion_generator=>sub {my ($self,$target,$sep)=@_;Types::TypeTiny::StringLike->check($sep)or _croak("Parameter to Join[`a] expected to be a string; got $sep");require B;$sep=B::perlstring($sep);return (ArrayRef(),qq{ join($sep, \@\$_) })},});$meta->add_coercion({name=>"Split",type_constraint=>$_arr,coercion_generator=>sub {my ($self,$target,$re)=@_;ref($re)eq q(Regexp) or _croak("Parameter to Split[`a] expected to be a regular expresssion; got $re");my$regexp_string="$re";$regexp_string =~ s/\\\//\\\\\//g;return (Str(),qq{ [split /$regexp_string/, \$_] })},});1;
TYPES_STANDARD

$fatpacked{"Types/Standard/ArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_ARRAYREF';
  package Types::Standard::ArrayRef;use 5.006001;use strict;use warnings;BEGIN {$Types::Standard::ArrayRef::AUTHORITY='cpan:TOBYINK';$Types::Standard::ArrayRef::VERSION='0.034'}use Types::Standard ();use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}no warnings;sub __constraint_generator {return Types::Standard::ArrayRef unless @_;my$param=Types::TypeTiny::to_TypeTiny(shift);Types::TypeTiny::TypeTiny->check($param)or _croak("Parameter to ArrayRef[`a] expected to be a type constraint; got $param");return sub {my$array=shift;$param->check($_)|| return for @$array;return!!1}}sub __inline_generator {my$param=shift;return unless$param->can_be_inlined;my$param_check=$param->inline_check('$i');return sub {my$v=$_[1];"ref($v) eq 'ARRAY' and do { " ."my \$ok = 1; " ."for my \$i (\@{$v}) { " ."\$ok = 0 && last unless $param_check " ."}; " ."\$ok " ."}"}}sub __deep_explanation {my ($type,$value,$varname)=@_;my$param=$type->parameters->[0];for my$i (0 .. $#$value){my$item=$value->[$i];next if$param->check($item);return [sprintf('"%s" constrains each value in the array with "%s"',$type,$param),@{$param->validate_explain($item,sprintf('%s->[%d]',$varname,$i))},]}return}sub __coercion_generator {my ($parent,$child,$param)=@_;return unless$param->has_coercion;my$coercable_item=$param->coercion->_source_type_union;my$C="Type::Coercion"->new(type_constraint=>$child);if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined){$C->add_type_coercions($parent=>Types::Standard::Stringable {my@code;push@code,'do { my ($orig, $return_orig, @new) = ($_, 0);';push@code,'for (@$orig) {';push@code,sprintf('$return_orig++ && last unless (%s);',$coercable_item->inline_check('$_'));push@code,sprintf('push @new, (%s);',$param->coercion->inline_coercion('$_'));push@code,'}';push@code,'$return_orig ? $orig : \\@new';push@code,'}';"@code"})}else {$C->add_type_coercions($parent=>sub {my$value=@_ ? $_[0]: $_;my@new;for my$item (@$value){return$value unless$coercable_item->check($item);push@new,$param->coerce($item)}return \@new},)}return$C}1;
TYPES_STANDARD_ARRAYREF

$fatpacked{"Types/Standard/Dict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_DICT';
  package Types::Standard::Dict;use 5.006001;use strict;use warnings;BEGIN {$Types::Standard::Dict::AUTHORITY='cpan:TOBYINK';$Types::Standard::Dict::VERSION='0.034'}use Types::Standard ();use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}my$_hash=Types::Standard::HashRef;my$_map=Types::Standard::Map;my$_any=Types::Standard::Any;no warnings;sub __constraint_generator {my$slurpy=ref($_[-1])eq q(HASH) ? pop(@_)->{slurpy}: undef;my%constraints=@_;while (my ($k,$v)=each%constraints){$constraints{$k}=Types::TypeTiny::to_TypeTiny($v);Types::TypeTiny::TypeTiny->check($v)or _croak("Parameter to Dict[`a] for key '$k' expected to be a type constraint; got $v")}return sub {my$value=$_[0];if ($slurpy){my%tmp=map {exists($constraints{$_})? (): ($_=>$value->{$_})}keys %$value;return unless$slurpy->check(\%tmp)}else {exists($constraints{$_})|| return for sort keys %$value}for (sort keys%constraints){my$c=$constraints{$_};return unless exists($value->{$_})|| $c->is_strictly_a_type_of(Types::Standard::Optional);return unless$c->check(exists$value->{$_}? $value->{$_}: ())}return!!1}}sub __inline_generator {my$slurpy=ref($_[-1])eq q(HASH) ? pop(@_)->{slurpy}: undef;return if$slurpy &&!$slurpy->can_be_inlined;my$slurpy_is_any=$slurpy && $_hash->is_a_type_of($slurpy);my$slurpy_is_map=$slurpy && $slurpy->is_parameterized && (($slurpy->parent->strictly_equals($_map)&& $slurpy->parameters)||($slurpy->parent->strictly_equals($_hash)&& [$_any,$slurpy->parameters->[0]]));my%constraints=@_;for my$c (values%constraints){next if$c->can_be_inlined;return}my$regexp=join "|",map quotemeta,sort keys%constraints;return sub {require B;my$h=$_[1];join " and ","ref($h) eq 'HASH'",($slurpy_is_any ? '1' : $slurpy_is_map ? do {'(not grep {' ."my \$v = ($h)->{\$_};" .sprintf('not((%s) and (%s))',$slurpy_is_map->[0]->inline_check('$_'),$slurpy_is_map->[1]->inline_check('$v'),)."} keys \%{$h})"}: $slurpy ? do {'do {' ."my \$slurpy_tmp = +{ map /\\A(?:$regexp)\\z/ ? () : (\$_ => ($h)->{\$_}), keys \%{$h} };" .$slurpy->inline_check('$slurpy_tmp').'}'}: "not(grep !/\\A(?:$regexp)\\z/, keys \%{$h})"),(map {my$k=B::perlstring($_);$constraints{$_}->is_strictly_a_type_of(Types::Standard::Optional)? $constraints{$_}->inline_check("$h\->{$k}"): ("exists($h\->{$k})",$constraints{$_}->inline_check("$h\->{$k}"))}sort keys%constraints),}}sub __deep_explanation {require B;my ($type,$value,$varname)=@_;my@params=@{$type->parameters};my$slurpy=ref($params[-1])eq q(HASH) ? pop(@params)->{slurpy}: undef;my%constraints=@params;for my$k (sort keys%constraints){next if$constraints{$k}->parent==Types::Standard::Optional &&!exists$value->{$k};next if$constraints{$k}->check($value->{$k});return [sprintf('"%s" requires key %s to appear in hash',$type,B::perlstring($k))]unless exists$value->{$k};return [sprintf('"%s" constrains value at key %s of hash with "%s"',$type,B::perlstring($k),$constraints{$k}),@{$constraints{$k}->validate_explain($value->{$k},sprintf('%s->{%s}',$varname,B::perlstring($k)))},]}if ($slurpy){my%tmp=map {exists($constraints{$_})? (): ($_=>$value->{$_})}keys %$value;my$explain=$slurpy->validate_explain(\%tmp,'$slurpy');return [sprintf('"%s" requires the hashref of additional key/value pairs to conform to "%s"',$type,$slurpy),@$explain,]if$explain}else {for my$k (sort keys %$value){return [sprintf('"%s" does not allow key %s to appear in hash',$type,B::perlstring($k))]unless exists$constraints{$k}}}return}my$label_counter=0;our ($keycheck_counter,@KEYCHECK)=-1;sub __coercion_generator {my$slurpy=ref($_[-1])eq q(HASH) ? pop(@_)->{slurpy}: undef;my ($parent,$child,%dict)=@_;my$C="Type::Coercion"->new(type_constraint=>$child);my$all_inlinable=1;for my$tc (values%dict){$all_inlinable=0 if!$tc->can_be_inlined;$all_inlinable=0 if$tc->has_coercion &&!$tc->coercion->can_be_inlined;last if!$all_inlinable}$all_inlinable=0 if$slurpy &&!$slurpy->can_be_inlined;$all_inlinable=0 if$slurpy && $slurpy->has_coercion &&!$slurpy->coercion->can_be_inlined;if ($all_inlinable){$C->add_type_coercions($parent=>Types::Standard::Stringable {require B;my$keycheck=join "|",map quotemeta,sort {length($b)<=> length($a)or $a cmp $b}keys%dict;$keycheck=$KEYCHECK[++$keycheck_counter]=qr{^($keycheck)$}ms;my$label=sprintf("DICTLABEL%d",++$label_counter);my@code;push@code,'do { my ($orig, $return_orig, %tmp, %new) = ($_, 0);';push@code,"$label: {";if ($slurpy){push@code,sprintf('my $slurped = +{ map +($_=~$%s::KEYCHECK[%d])?():($_=>$orig->{$_}), keys %%$orig };',__PACKAGE__,$keycheck_counter);if ($slurpy->has_coercion){push@code,sprintf('my $coerced = %s;',$slurpy->coercion->inline_coercion('$slurped'));push@code,sprintf('((%s)&&(%s))?(%%new=%%$coerced):(($return_orig = 1), last %s);',$_hash->inline_check('$coerced'),$slurpy->inline_check('$coerced'),$label)}else {push@code,sprintf('(%s)?(%%new=%%$slurped):(($return_orig = 1), last %s);',$slurpy->inline_check('$slurped'),$label)}}else {push@code,sprintf('($_ =~ $%s::KEYCHECK[%d])||(($return_orig = 1), last %s) for sort keys %%$orig;',__PACKAGE__,$keycheck_counter,$label)}for my$k (keys%dict){my$ct=$dict{$k};my$ct_coerce=$ct->has_coercion;my$ct_optional=$ct->is_a_type_of(Types::Standard::Optional);my$K=B::perlstring($k);push@code,"if (exists \$orig->{$K}) {" if$ct_optional;if ($ct_coerce){push@code,sprintf('%%tmp = (); $tmp{x} = %s;',$ct->coercion->inline_coercion("\$orig->{$K}"));push@code,sprintf('if (%s) { $new{%s}=$tmp{x} } else { $return_orig = 1; last %s }',$ct->inline_check('$tmp{x}'),$K,$label,)}else {push@code,sprintf('if (%s) { $new{%s}=$orig->{%s} } else { $return_orig = 1; last %s }',$ct->inline_check("\$orig->{$K}"),$K,$K,$label,)}push@code,'}' if$ct_optional}push@code,'}';push@code,'$return_orig ? $orig : \\%new';push@code,'}';"@code"})}else {$C->add_type_coercions($parent=>sub {my$value=@_ ? $_[0]: $_;my%new;if ($slurpy){my%slurped=map exists($dict{$_})? (): ($_=>$value->{$_}),keys %$value;if ($slurpy->check(\%slurped)){%new=%slurped}elsif ($slurpy->has_coercion){my$coerced=$slurpy->coerce(\%slurped);$slurpy->check($coerced)? (%new=%$coerced): (return$value)}else {return$value}}else {for my$k (keys %$value){return$value unless exists$dict{$k}}}for my$k (keys%dict){my$ct=$dict{$k};my@accept;if (exists$value->{$k}and $ct->check($value->{$k})){@accept=$value->{$k}}elsif (exists$value->{$k}and $ct->has_coercion){my$x=$ct->coerce($value->{$k});@accept=$x if$ct->check($x)}elsif (exists$value->{$k}){return$value}if (@accept){$new{$k}=$accept[0]}elsif (not $ct->is_a_type_of(Types::Standard::Optional)){return$value}}return \%new},)}return$C}1;
TYPES_STANDARD_DICT

$fatpacked{"Types/Standard/HashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_HASHREF';
  package Types::Standard::HashRef;use 5.006001;use strict;use warnings;BEGIN {$Types::Standard::HashRef::AUTHORITY='cpan:TOBYINK';$Types::Standard::HashRef::VERSION='0.034'}use Types::Standard ();use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}no warnings;sub __constraint_generator {return Types::Standard::HashRef unless @_;my$param=Types::TypeTiny::to_TypeTiny(shift);Types::TypeTiny::TypeTiny->check($param)or _croak("Parameter to HashRef[`a] expected to be a type constraint; got $param");return sub {my$hash=shift;$param->check($_)|| return for values %$hash;return!!1}}sub __inline_generator {my$param=shift;return unless$param->can_be_inlined;my$param_check=$param->inline_check('$i');return sub {my$v=$_[1];"ref($v) eq 'HASH' and do { " ."my \$ok = 1; " ."for my \$i (values \%{$v}) { " ."\$ok = 0 && last unless $param_check " ."}; " ."\$ok " ."}"}}sub __deep_explanation {require B;my ($type,$value,$varname)=@_;my$param=$type->parameters->[0];for my$k (sort keys %$value){my$item=$value->{$k};next if$param->check($item);return [sprintf('"%s" constrains each value in the hash with "%s"',$type,$param),@{$param->validate_explain($item,sprintf('%s->{%s}',$varname,B::perlstring($k)))},]}return}sub __coercion_generator {my ($parent,$child,$param)=@_;return unless$param->has_coercion;my$coercable_item=$param->coercion->_source_type_union;my$C="Type::Coercion"->new(type_constraint=>$child);if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined){$C->add_type_coercions($parent=>Types::Standard::Stringable {my@code;push@code,'do { my ($orig, $return_orig, %new) = ($_, 0);';push@code,'for (keys %$orig) {';push@code,sprintf('$return_orig++ && last unless (%s);',$coercable_item->inline_check('$orig->{$_}'));push@code,sprintf('$new{$_} = (%s);',$param->coercion->inline_coercion('$orig->{$_}'));push@code,'}';push@code,'$return_orig ? $orig : \\%new';push@code,'}';"@code"})}else {$C->add_type_coercions($parent=>sub {my$value=@_ ? $_[0]: $_;my%new;for my$k (keys %$value){return$value unless$coercable_item->check($value->{$k});$new{$k}=$param->coerce($value->{$k})}return \%new},)}return$C}1;
TYPES_STANDARD_HASHREF

$fatpacked{"Types/Standard/Map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_MAP';
  package Types::Standard::Map;use 5.006001;use strict;use warnings;BEGIN {$Types::Standard::Map::AUTHORITY='cpan:TOBYINK';$Types::Standard::Map::VERSION='0.034'}use Types::Standard ();use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}my$meta=Types::Standard->meta;no warnings;sub __constraint_generator {return$meta->get_type('Map')unless @_;my ($keys,$values)=map Types::TypeTiny::to_TypeTiny($_),@_;Types::TypeTiny::TypeTiny->check($keys)or _croak("First parameter to Map[`k,`v] expected to be a type constraint; got $keys");Types::TypeTiny::TypeTiny->check($values)or _croak("Second parameter to Map[`k,`v] expected to be a type constraint; got $values");return sub {my$hash=shift;$keys->check($_)|| return for keys %$hash;$values->check($_)|| return for values %$hash;return!!1}}sub __inline_generator {my ($k,$v)=@_;return unless$k->can_be_inlined && $v->can_be_inlined;my$k_check=$k->inline_check('$k');my$v_check=$v->inline_check('$v');return sub {my$h=$_[1];"ref($h) eq 'HASH' and do { " ."my \$ok = 1; " ."for my \$v (values \%{$h}) { " ."\$ok = 0 && last unless $v_check " ."}; " ."for my \$k (keys \%{$h}) { " ."\$ok = 0 && last unless $k_check " ."}; " ."\$ok " ."}"}}sub __deep_explanation {require B;my ($type,$value,$varname)=@_;my ($kparam,$vparam)=@{$type->parameters};for my$k (sort keys %$value){unless ($kparam->check($k)){return [sprintf('"%s" constrains each key in the hash with "%s"',$type,$kparam),@{$kparam->validate_explain($k,sprintf('key %s->{%s}',$varname,B::perlstring($k)))},]}unless ($vparam->check($value->{$k})){return [sprintf('"%s" constrains each value in the hash with "%s"',$type,$vparam),@{$vparam->validate_explain($value->{$k},sprintf('%s->{%s}',$varname,B::perlstring($k)))},]}}return}sub __coercion_generator {my ($parent,$child,$kparam,$vparam)=@_;return unless$kparam->has_coercion || $vparam->has_coercion;my$kcoercable_item=$kparam->has_coercion ? $kparam->coercion->_source_type_union : $kparam;my$vcoercable_item=$vparam->has_coercion ? $vparam->coercion->_source_type_union : $vparam;my$C="Type::Coercion"->new(type_constraint=>$child);if ((!$kparam->has_coercion or $kparam->coercion->can_be_inlined)and (!$vparam->has_coercion or $vparam->coercion->can_be_inlined)and $kcoercable_item->can_be_inlined and $vcoercable_item->can_be_inlined){$C->add_type_coercions($parent=>Types::Standard::Stringable {my@code;push@code,'do { my ($orig, $return_orig, %new) = ($_, 0);';push@code,'for (keys %$orig) {';push@code,sprintf('$return_orig++ && last unless (%s);',$kcoercable_item->inline_check('$_'));push@code,sprintf('$return_orig++ && last unless (%s);',$vcoercable_item->inline_check('$orig->{$_}'));push@code,sprintf('$new{(%s)} = (%s);',$kparam->has_coercion ? $kparam->coercion->inline_coercion('$_'): '$_',$vparam->has_coercion ? $vparam->coercion->inline_coercion('$orig->{$_}'): '$orig->{$_}',);push@code,'}';push@code,'$return_orig ? $orig : \\%new';push@code,'}';"@code"})}else {$C->add_type_coercions($parent=>sub {my$value=@_ ? $_[0]: $_;my%new;for my$k (keys %$value){return$value unless$kcoercable_item->check($k)&& $vcoercable_item->check($value->{$k});$new{$kparam->has_coercion ? $kparam->coerce($k): $k}=$vparam->has_coercion ? $vparam->coerce($value->{$k}): $value->{$k}}return \%new},)}return$C}1;
TYPES_STANDARD_MAP

$fatpacked{"Types/Standard/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_SCALARREF';
  package Types::Standard::ScalarRef;use 5.006001;use strict;use warnings;BEGIN {$Types::Standard::ScalarRef::AUTHORITY='cpan:TOBYINK';$Types::Standard::ScalarRef::VERSION='0.034'}use Types::Standard ();use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}no warnings;sub __constraint_generator {return Types::Standard::ScalarRef unless @_;my$param=Types::TypeTiny::to_TypeTiny(shift);Types::TypeTiny::TypeTiny->check($param)or _croak("Parameter to ScalarRef[`a] expected to be a type constraint; got $param");return sub {my$ref=shift;$param->check($$ref)|| return;return!!1}}sub __inline_generator {my$param=shift;return unless$param->can_be_inlined;return sub {my$v=$_[1];my$param_check=$param->inline_check("\${$v}");"(ref($v) eq 'SCALAR' or ref($v) eq 'REF') and $param_check"}}sub __deep_explanation {my ($type,$value,$varname)=@_;my$param=$type->parameters->[0];for my$item ($$value){next if$param->check($item);return [sprintf('"%s" constrains the referenced scalar value with "%s"',$type,$param),@{$param->validate_explain($item,sprintf('${%s}',$varname))},]}return}sub __coercion_generator {my ($parent,$child,$param)=@_;return unless$param->has_coercion;my$coercable_item=$param->coercion->_source_type_union;my$C="Type::Coercion"->new(type_constraint=>$child);if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined){$C->add_type_coercions($parent=>Types::Standard::Stringable {my@code;push@code,'do { my ($orig, $return_orig, $new) = ($_, 0);';push@code,'for ($$orig) {';push@code,sprintf('$return_orig++ && last unless (%s);',$coercable_item->inline_check('$_'));push@code,sprintf('$new = (%s);',$param->coercion->inline_coercion('$_'));push@code,'}';push@code,'$return_orig ? $orig : \\$new';push@code,'}';"@code"})}else {$C->add_type_coercions($parent=>sub {my$value=@_ ? $_[0]: $_;my$new;for my$item ($$value){return$value unless$coercable_item->check($item);$new=$param->coerce($item)}return \$new},)}return$C}1;
TYPES_STANDARD_SCALARREF

$fatpacked{"Types/Standard/Tuple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_TUPLE';
  package Types::Standard::Tuple;use 5.006001;use strict;use warnings;BEGIN {$Types::Standard::Tuple::AUTHORITY='cpan:TOBYINK';$Types::Standard::Tuple::VERSION='0.034'}use Types::Standard ();use Types::TypeTiny ();sub _croak ($;@) {require Error::TypeTiny;goto \&Error::TypeTiny::croak}my$_Optional=Types::Standard::Optional;no warnings;sub __constraint_generator {my@constraints=@_;my$slurpy;if (exists$constraints[-1]and ref$constraints[-1]eq "HASH"){$slurpy=Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});Types::TypeTiny::TypeTiny->check($slurpy)or _croak("Slurpy parameter to Tuple[...] expected to be a type constraint; got $slurpy")}@constraints=map Types::TypeTiny::to_TypeTiny($_),@constraints;for (@constraints){Types::TypeTiny::TypeTiny->check($_)or _croak("Parameters to Tuple[...] expected to be type constraints; got $_")}return sub {my$value=$_[0];if ($#constraints < $#$value){defined($slurpy)&& $slurpy->check($slurpy->is_a_type_of(Types::Standard::HashRef)? +{@$value[$#constraints+1 .. $#$value]}: +[@$value[$#constraints+1 .. $#$value]])or return}for my$i (0 .. $#constraints){$i <= $#$value or $constraints[$i]->is_strictly_a_type_of($_Optional)or return;$constraints[$i]->check(exists$value->[$i]? $value->[$i]: ())or return}return!!1}}sub __inline_generator {my@constraints=@_;my$slurpy;if (exists$constraints[-1]and ref$constraints[-1]eq "HASH"){$slurpy=pop(@constraints)->{slurpy}}return if grep {not $_->can_be_inlined}@constraints;return if defined$slurpy &&!$slurpy->can_be_inlined;my$tmpl=defined($slurpy)&& $slurpy->is_a_type_of(Types::Standard::HashRef)? "do { my \$tmp = +{\@{%s}[%d..\$#{%s}]}; %s }" : "do { my \$tmp = +[\@{%s}[%d..\$#{%s}]]; %s }";my$min=0 + grep!$_->is_strictly_a_type_of($_Optional),@constraints;return sub {my$v=$_[1];join " and ","ref($v) eq 'ARRAY'","scalar(\@{$v}) >= $min",($slurpy ? sprintf($tmpl,$v,$#constraints+1,$v,$slurpy->inline_check('$tmp')): sprintf("\@{$v} <= %d",scalar@constraints)),map {$constraints[$_]->inline_check("$v\->[$_]")}0 .. $#constraints}}sub __deep_explanation {my ($type,$value,$varname)=@_;my@constraints=@{$type->parameters};my$slurpy;if (exists$constraints[-1]and ref$constraints[-1]eq "HASH"){$slurpy=Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy})}@constraints=map Types::TypeTiny::to_TypeTiny($_),@constraints;if ($#constraints < $#$value and not $slurpy){return [sprintf('"%s" expects at most %d values in the array',$type,$#constraints),sprintf('%d values found; too many',$#$value),]}for my$i (0 .. $#constraints){next if$constraints[$i]->is_strictly_a_type_of(Types::Standard::Optional)&& $i > $#$value;next if$constraints[$i]->check($value->[$i]);return [sprintf('"%s" constrains value at index %d of array with "%s"',$type,$i,$constraints[$i]),@{$constraints[$i]->validate_explain($value->[$i],sprintf('%s->[%s]',$varname,$i))},]}if (defined($slurpy)){my$tmp=$slurpy->is_a_type_of(Types::Standard::HashRef)? +{@$value[$#constraints+1 .. $#$value]}: +[@$value[$#constraints+1 .. $#$value]];$slurpy->check($tmp)or return [sprintf('Array elements from index %d are slurped into a %s which is constrained with "%s"',$#constraints+1,$slurpy->is_a_type_of(Types::Standard::HashRef)? 'hashref' : 'arrayref',$slurpy,),@{$slurpy->validate_explain($tmp,'$SLURPY')},]}return}my$label_counter=0;sub __coercion_generator {my ($parent,$child,@tuple)=@_;my$C="Type::Coercion"->new(type_constraint=>$child);my$slurpy;if (exists$tuple[-1]and ref$tuple[-1]eq "HASH"){$slurpy=pop(@tuple)->{slurpy}}my$all_inlinable=1;for my$tc (@tuple,($slurpy ? $slurpy : ())){$all_inlinable=0 if!$tc->can_be_inlined;$all_inlinable=0 if$tc->has_coercion &&!$tc->coercion->can_be_inlined;last if!$all_inlinable}if ($all_inlinable){$C->add_type_coercions($parent=>Types::Standard::Stringable {my$label=sprintf("TUPLELABEL%d",++$label_counter);my@code;push@code,'do { my ($orig, $return_orig, @tmp, @new) = ($_, 0);';push@code,"$label: {";push@code,sprintf('(($return_orig = 1), last %s) if @$orig > %d;',$label,scalar@tuple)unless$slurpy;for my$i (0 .. $#tuple){my$ct=$tuple[$i];my$ct_coerce=$ct->has_coercion;my$ct_optional=$ct->is_a_type_of(Types::Standard::Optional);if ($ct_coerce){push@code,sprintf('@tmp = (); $tmp[0] = %s;',$ct->coercion->inline_coercion("\$orig->[$i]"));push@code,sprintf($ct_optional ? 'if (%s) { $new[%d]=$tmp[0] }' : 'if (%s) { $new[%d]=$tmp[0] } else { $return_orig = 1; last %s }',$ct->inline_check('$tmp[0]'),$i,$label,)}else {push@code,sprintf($ct_optional ? 'if (%s) { $new[%d]=$orig->[%s] }' : 'if (%s) { $new[%d]=$orig->[%s] } else { $return_orig = 1; last %s }',$ct->inline_check("\$orig->[$i]"),$i,$i,$label,)}}if ($slurpy){my$size=@tuple;push@code,sprintf('if (@$orig > %d) {',$size);push@code,sprintf('my $tail = [ @{$orig}[%d .. $#$orig] ];',$size);push@code,$slurpy->has_coercion ? sprintf('$tail = %s;',$slurpy->coercion->inline_coercion('$tail')): q();push@code,sprintf('(%s) ? push(@new, @$tail) : ($return_orig++);',$slurpy->inline_check('$tail'),);push@code,'}'}push@code,'}';push@code,'$return_orig ? $orig : \\@new';push@code,'}';"@code"})}else {$C->add_type_coercions($parent=>sub {my$value=@_ ? $_[0]: $_;if (!$slurpy and @$value > @tuple){return$value}my@new;for my$i (0 .. $#tuple){my$ct=$tuple[$i];my@accept;if (exists$value->[$i]and $ct->check($value->[$i])){@accept=$value->[$i]}elsif (exists$value->[$i]and $ct->has_coercion){my$x=$ct->coerce($value->[$i]);@accept=$x if$ct->check($x)}else {return$value}if (@accept){$new[$i]=$accept[0]}elsif (not $ct->is_a_type_of(Types::Standard::Optional)){return$value}}if ($slurpy and @$value > @tuple){my$tmp=$slurpy->has_coercion ? $slurpy->coerce([@{$value}[@tuple .. $#$value]]): [@{$value}[@tuple .. $#$value]];$slurpy->check($tmp)? push(@new,@$tmp): return($value)}return \@new},)};return$C}1;
TYPES_STANDARD_TUPLE

$fatpacked{"Types/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_TYPETINY';
  package Types::TypeTiny;use strict;use warnings;our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.034';use Scalar::Util qw<blessed refaddr weaken>;our@EXPORT_OK=(__PACKAGE__->type_names,qw/to_TypeTiny/);my%cache;sub import {no warnings "redefine";our@ISA=qw(Exporter::Tiny);require Exporter::Tiny;my$next=\&Exporter::Tiny::import;*import=$next;my$class=shift;my$opts={ref($_[0])? %{+shift}: ()};$opts->{into}||=scalar(caller);return$class->$next($opts,@_)}sub meta {return $_[0]}sub has_type {defined(shift->get_coercion(@_))}sub get_type {my$self=shift;my$func=$self->can(@_)or return;my$type=$func->();return$type if blessed($type)&& $type->isa("Type::Tiny");return}sub type_names {qw(CodeLike StringLike TypeTiny HashLike ArrayLike)}sub has_coercion {defined(shift->get_coercion(@_))}sub get_coercion {()}sub coercion_names {()}sub StringLike () {require Type::Tiny;$cache{StringLike}||="Type::Tiny"->new(name=>"StringLike",constraint=>sub {!ref($_)or Scalar::Util::blessed($_)&& overload::Method($_,q[""])},inlined=>sub {qq/!ref($_[1]) or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[""])/},library=>__PACKAGE__,)}sub HashLike () {require Type::Tiny;$cache{HashLike}||="Type::Tiny"->new(name=>"HashLike",constraint=>sub {ref($_)eq q[HASH] or Scalar::Util::blessed($_)&& overload::Method($_,q[%{}])},inlined=>sub {qq/ref($_[1]) eq q[HASH] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\%{}])/},library=>__PACKAGE__,)}sub ArrayLike () {require Type::Tiny;$cache{ArrayLike}||="Type::Tiny"->new(name=>"ArrayLike",constraint=>sub {ref($_)eq q[ARRAY] or Scalar::Util::blessed($_)&& overload::Method($_,q[@{}])},inlined=>sub {qq/ref($_[1]) eq q[ARRAY] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\@{}])/},library=>__PACKAGE__,)}sub CodeLike () {require Type::Tiny;$cache{CodeLike}||="Type::Tiny"->new(name=>"CodeLike",constraint=>sub {ref($_)eq q[CODE] or Scalar::Util::blessed($_)&& overload::Method($_,q[&{}])},inlined=>sub {qq/ref($_[1]) eq q[CODE] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\&{}])/},library=>__PACKAGE__,)}sub TypeTiny () {require Type::Tiny;$cache{TypeTiny}||="Type::Tiny"->new(name=>"TypeTiny",constraint=>sub {Scalar::Util::blessed($_)&& $_ ->isa(q[Type::Tiny])},inlined=>sub {my$var=$_[1];"Scalar::Util::blessed($var) && $var\->isa(q[Type::Tiny])"},library=>__PACKAGE__,)}my%ttt_cache;sub to_TypeTiny {my$t=$_[0];return$t unless ref$t;return$t if ref($t)=~ /^Type::Tiny\b/;return$ttt_cache{refaddr($t)}if$ttt_cache{refaddr($t)};if (my$class=blessed$t){return$t if$class->isa("Type::Tiny");goto \&_TypeTinyFromMoose if$class->isa("Moose::Meta::TypeConstraint");goto \&_TypeTinyFromMoose if$class->isa("MooseX::Types::TypeDecorator");goto \&_TypeTinyFromValidationClass if$class->isa("Validation::Class::Simple");goto \&_TypeTinyFromValidationClass if$class->isa("Validation::Class");goto \&_TypeTinyFromGeneric if$t->can("check")&& $t->can("get_message")}goto \&_TypeTinyFromCodeRef if ref($t)eq q(CODE);$t}sub _TypeTinyFromMoose {my$t=$_[0];if (ref$t->{"Types::TypeTiny::to_TypeTiny"}){return$t->{"Types::TypeTiny::to_TypeTiny"}}if ($t->name ne '__ANON__'){require Types::Standard;my$ts='Types::Standard'->get_type($t->name);return$ts if$ts->{_is_core}}my%opts;$opts{display_name}=$t->name;$opts{constraint}=$t->constraint;$opts{parent}=to_TypeTiny($t->parent)if$t->has_parent;$opts{inlined}=sub {shift;$t->_inline_check(@_)}if$t->can_be_inlined;$opts{message}=sub {$t->get_message($_)}if$t->has_message;$opts{moose_type}=$t;require Type::Tiny;my$new='Type::Tiny'->new(%opts);$ttt_cache{refaddr($t)}=$new;weaken($ttt_cache{refaddr($t)});$new->{coercion}=do {require Type::Coercion::FromMoose;'Type::Coercion::FromMoose'->new(type_constraint=>$new)}if$t->has_coercion;return$new}sub _TypeTinyFromValidationClass {my$t=$_[0];require Type::Tiny;require Types::Standard;my%opts=(parent=>Types::Standard::HashRef(),_validation_class=>$t,);if ($t->VERSION >= "7.900048"){$opts{constraint}=sub {$t->params->clear;$t->params->add(%$_);my$f=$t->filtering;$t->filtering('off');my$r=eval {$t->validate};$t->filtering($f || 'pre');return$r};$opts{message}=sub {$t->params->clear;$t->params->add(%$_);my$f=$t->filtering;$t->filtering('off');my$r=(eval {$t->validate}? "OK" : $t->errors_to_string);$t->filtering($f || 'pre');return$r}}else {$opts{constraint}=sub {$t->params->clear;$t->params->add(%$_);no warnings "redefine";local*Validation::Class::Directive::Filters::execute_filtering=sub {$_[0]};eval {$t->validate}};$opts{message}=sub {$t->params->clear;$t->params->add(%$_);no warnings "redefine";local*Validation::Class::Directive::Filters::execute_filtering=sub {$_[0]};eval {$t->validate}? "OK" : $t->errors_to_string}}require Type::Tiny;my$new="Type::Tiny"->new(%opts);$new->coercion->add_type_coercions(Types::Standard::HashRef()=>sub {my%params=%$_;for my$k (keys%params){delete$params{$_}unless$t->get_fields($k)};$t->params->clear;$t->params->add(%params);eval {$t->validate};$t->get_hash},);$ttt_cache{refaddr($t)}=$new;weaken($ttt_cache{refaddr($t)});return$new}sub _TypeTinyFromGeneric {my$t=$_[0];my%opts=(constraint=>sub {$t->check(@_ ? @_ : $_)},message=>sub {$t->get_message(@_ ? @_ : $_)},);$opts{display_name}=$t->name if$t->can("name");$opts{coercion}=sub {$t->coerce(@_ ? @_ : $_)}if$t->can("has_coercion")&& $t->has_coercion && $t->can("coerce");require Type::Tiny;my$new="Type::Tiny"->new(%opts);$ttt_cache{refaddr($t)}=$new;weaken($ttt_cache{refaddr($t)});return$new}sub _TypeTinyFromCodeRef {my$t=$_[0];my%opts=(constraint=>sub {return!!eval {$t->($_)}},message=>sub {local $@;eval {$t->($_);1}or do {chomp $@;return $@ if $@};return sprintf('%s did not pass type constraint',Type::Tiny::_dd($_))},);require Type::Tiny;my$new="Type::Tiny"->new(%opts);$ttt_cache{refaddr($t)}=$new;weaken($ttt_cache{refaddr($t)});return$new}1;
TYPES_TYPETINY

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  use 5.008001;package YAML;use YAML::Mo;our$VERSION='0.84';use Exporter;push@YAML::ISA,'Exporter';our@EXPORT=qw{Dump Load};our@EXPORT_OK=qw{freeze thaw DumpFile LoadFile Bless Blessed};use YAML::Node;use constant VALUE=>"\x07YAML\x07VALUE\x07";has dumper_class=>default=>sub {'YAML::Dumper'};has loader_class=>default=>sub {'YAML::Loader'};has dumper_object=>default=>sub {$_[0]->init_action_object("dumper")};has loader_object=>default=>sub {$_[0]->init_action_object("loader")};sub Dump {my$yaml=YAML->new;$yaml->dumper_class($YAML::DumperClass)if$YAML::DumperClass;return$yaml->dumper_object->dump(@_)}sub Load {my$yaml=YAML->new;$yaml->loader_class($YAML::LoaderClass)if$YAML::LoaderClass;return$yaml->loader_object->load(@_)}{no warnings 'once';*freeze=\ &Dump;*thaw=\ &Load}sub DumpFile {my$OUT;my$filename=shift;if (ref$filename eq 'GLOB'){$OUT=$filename}else {my$mode='>';if ($filename =~ /^\s*(>{1,2})\s*(.*)$/){($mode,$filename)=($1,$2)}open$OUT,$mode,$filename or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT',$filename,$!)}binmode$OUT,':utf8';local $/="\n";print$OUT Dump(@_)}sub LoadFile {my$IN;my$filename=shift;if (ref$filename eq 'GLOB'){$IN=$filename}else {open$IN,'<',$filename or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT',$filename,$!)}binmode$IN,':utf8';return Load(do {local $/;<$IN>})}sub init_action_object {my$self=shift;my$object_class=(shift).'_class';my$module_name=$self->$object_class;eval "require $module_name";$self->die("Error in require $module_name - $@")if $@ and "$@" !~ /Can't locate/;my$object=$self->$object_class->new;$object->set_global_options;return$object}my$global={};sub Bless {require YAML::Dumper::Base;YAML::Dumper::Base::bless($global,@_)}sub Blessed {require YAML::Dumper::Base;YAML::Dumper::Base::blessed($global,@_)}sub global_object {$global}1;
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  package YAML::Any;our$VERSION='0.84';use strict;use Exporter ();@YAML::Any::ISA='Exporter';@YAML::Any::EXPORT=qw(Dump Load);@YAML::Any::EXPORT_OK=qw(DumpFile LoadFile);my@dump_options=qw(UseCode DumpCode SpecVersion Indent UseHeader UseVersion SortKeys AnchorPrefix UseBlock UseFold CompressSeries InlineSeries UseAliases Purity Stringify);my@load_options=qw(UseCode LoadCode);my@implementations=qw(YAML::XS YAML::Syck YAML::Old YAML YAML::Tiny);sub import {__PACKAGE__->implementation;goto&Exporter::import}sub Dump {no strict 'refs';my$implementation=__PACKAGE__->implementation;for my$option (@dump_options){my$var="$implementation\::$option";my$value=$$var;local $$var;$$var=defined$value ? $value : ${"YAML::$option"}}return &{"$implementation\::Dump"}(@_)}sub DumpFile {no strict 'refs';my$implementation=__PACKAGE__->implementation;for my$option (@dump_options){my$var="$implementation\::$option";my$value=$$var;local $$var;$$var=defined$value ? $value : ${"YAML::$option"}}return &{"$implementation\::DumpFile"}(@_)}sub Load {no strict 'refs';my$implementation=__PACKAGE__->implementation;for my$option (@load_options){my$var="$implementation\::$option";my$value=$$var;local $$var;$$var=defined$value ? $value : ${"YAML::$option"}}return &{"$implementation\::Load"}(@_)}sub LoadFile {no strict 'refs';my$implementation=__PACKAGE__->implementation;for my$option (@load_options){my$var="$implementation\::$option";my$value=$$var;local $$var;$$var=defined$value ? $value : ${"YAML::$option"}}return &{"$implementation\::LoadFile"}(@_)}sub order {return@YAML::Any::_TEST_ORDER if@YAML::Any::_TEST_ORDER;return@implementations}sub implementation {my@order=__PACKAGE__->order;for my$module (@order){my$path=$module;$path =~ s/::/\//g;$path .= '.pm';return$module if exists$INC{$path};eval "require $module; 1" and return$module}croak("YAML::Any couldn't find any of these YAML implementations: @order")}sub croak {require Carp;Carp::Croak(@_)}1;
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;use YAML::Mo;extends 'YAML::Dumper::Base';our$VERSION='0.84';use YAML::Dumper::Base;use YAML::Node;use YAML::Types;use constant KEY=>3;use constant BLESSED=>4;use constant FROMARRAY=>5;use constant VALUE=>"\x07YAML\x07VALUE\x07";my$ESCAPE_CHAR='[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';my$LIT_CHAR='|';sub dump {my$self=shift;$self->stream('');$self->document(0);for my$document (@_){$self->{document}++;$self->transferred({});$self->id_refcnt({});$self->id_anchor({});$self->anchor(1);$self->level(0);$self->offset->[0]=0 - $self->indent_width;$self->_prewalk($document);$self->_emit_header($document);$self->_emit_node($document)}return$self->stream}sub _emit_header {my$self=shift;my ($node)=@_;if (not $self->use_header and $self->document==1){$self->die('YAML_DUMP_ERR_NO_HEADER')unless ref($node)=~ /^(HASH|ARRAY)$/;$self->die('YAML_DUMP_ERR_NO_HEADER')if ref($node)eq 'HASH' and keys(%$node)==0;$self->die('YAML_DUMP_ERR_NO_HEADER')if ref($node)eq 'ARRAY' and @$node==0;$self->headless(1);return}$self->{stream}.= '---';if ($self->use_version){}}sub _prewalk {my$self=shift;my$stringify=$self->stringify;my ($class,$type,$node_id)=$self->node_info(\$_[0],$stringify);if ($type eq 'GLOB'){$self->transferred->{$node_id}=YAML::Type::glob->yaml_dump($_[0]);$self->_prewalk($self->transferred->{$node_id});return}if (ref($_[0])eq 'Regexp'){return}if (not ref $_[0]){$self->{id_refcnt}{$node_id}++ if$self->purity;return}my$value=$_[0];($class,$type,$node_id)=$self->node_info($value,$stringify);return if (ref($value)and not $type);if ($self->transferred->{$node_id}){(undef,undef,$node_id)=(ref$self->transferred->{$node_id})? $self->node_info($self->transferred->{$node_id},$stringify): $self->node_info(\ $self->transferred->{$node_id},$stringify);$self->{id_refcnt}{$node_id}++;return}if ($type eq 'CODE'){$self->transferred->{$node_id}='placeholder';YAML::Type::code->yaml_dump($self->dump_code,$_[0],$self->transferred->{$node_id});($class,$type,$node_id)=$self->node_info(\ $self->transferred->{$node_id},$stringify);$self->{id_refcnt}{$node_id}++;return}if (defined$class){if ($value->can('yaml_dump')){$value=$value->yaml_dump}elsif ($type eq 'SCALAR'){$self->transferred->{$node_id}='placeholder';YAML::Type::blessed->yaml_dump ($_[0],$self->transferred->{$node_id});($class,$type,$node_id)=$self->node_info(\ $self->transferred->{$node_id},$stringify);$self->{id_refcnt}{$node_id}++;return}else {$value=YAML::Type::blessed->yaml_dump($value)}$self->transferred->{$node_id}=$value;(undef,$type,$node_id)=$self->node_info($value,$stringify)}if (defined YAML->global_object()->{blessed_map}{$node_id}){$value=YAML->global_object()->{blessed_map}{$node_id};$self->transferred->{$node_id}=$value;($class,$type,$node_id)=$self->node_info($value,$stringify);$self->_prewalk($value);return}if ($type eq 'REF' or $type eq 'SCALAR'){$value=YAML::Type::ref->yaml_dump($value);$self->transferred->{$node_id}=$value;(undef,$type,$node_id)=$self->node_info($value,$stringify)}elsif ($type eq 'GLOB'){my$ref_ynode=$self->transferred->{$node_id}=YAML::Type::ref->yaml_dump($value);my$glob_ynode=$ref_ynode->{&VALUE}=YAML::Type::glob->yaml_dump($$value);(undef,undef,$node_id)=$self->node_info($glob_ynode,$stringify);$self->transferred->{$node_id}=$glob_ynode;$self->_prewalk($glob_ynode);return}return if ++($self->{id_refcnt}{$node_id})> 1;if ($type eq 'HASH'){$self->_prewalk($value->{$_})for keys %{$value};return}elsif ($type eq 'ARRAY'){$self->_prewalk($_)for @{$value};return}$self->warn(<<"...");return}sub _emit_node {my$self=shift;my ($type,$node_id);my$ref=ref($_[0]);if ($ref){if ($ref eq 'Regexp'){$self->_emit(' !!perl/regexp');$self->_emit_str("$_[0]");return}(undef,$type,$node_id)=$self->node_info($_[0],$self->stringify)}else {$type=$ref || 'SCALAR';(undef,undef,$node_id)=$self->node_info(\$_[0],$self->stringify)}my ($ynode,$tag)=('')x 2;my ($value,$context)=(@_,0);if (defined$self->transferred->{$node_id}){$value=$self->transferred->{$node_id};$ynode=ynode($value);if (ref$value){$tag=defined$ynode ? $ynode->tag->short : '';(undef,$type,$node_id)=$self->node_info($value,$self->stringify)}else {$ynode=ynode($self->transferred->{$node_id});$tag=defined$ynode ? $ynode->tag->short : '';$type='SCALAR';(undef,undef,$node_id)=$self->node_info(\ $self->transferred->{$node_id},$self->stringify)}}elsif ($ynode=ynode($value)){$tag=$ynode->tag->short}if ($self->use_aliases){$self->{id_refcnt}{$node_id}||=0;if ($self->{id_refcnt}{$node_id}> 1){if (defined$self->{id_anchor}{$node_id}){$self->{stream}.= ' *' .$self->{id_anchor}{$node_id}."\n";return}my$anchor=$self->anchor_prefix .$self->{anchor}++;$self->{stream}.= ' &' .$anchor;$self->{id_anchor}{$node_id}=$anchor}}return$self->_emit_str("$value")if ref($value)and not $type;return$self->_emit_scalar($value,$tag)if$type eq 'SCALAR' and $tag;return$self->_emit_str($value)if$type eq 'SCALAR';return$self->_emit_mapping($value,$tag,$node_id,$context)if$type eq 'HASH';return$self->_emit_sequence($value,$tag)if$type eq 'ARRAY';$self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE',$type);return$self->_emit_str("$value")}sub _emit_mapping {my$self=shift;my ($value,$tag,$node_id,$context)=@_;$self->{stream}.= " !$tag" if$tag;my$empty_hash=not(eval {keys %$value});$self->warn('YAML_EMIT_WARN_KEYS',$@)if $@;return ($self->{stream}.= " {}\n")if$empty_hash;if ($context==FROMARRAY and $self->compress_series and not (defined$self->{id_anchor}{$node_id}or $tag or $empty_hash)){$self->{stream}.= ' ';$self->offset->[$self->level+1]=$self->offset->[$self->level]+ 2}else {$context=0;$self->{stream}.= "\n" unless$self->headless && not($self->headless(0));$self->offset->[$self->level+1]=$self->offset->[$self->level]+ $self->indent_width}$self->{level}++;my@keys;if ($self->sort_keys==1){if (ynode($value)){@keys=keys %$value}else {@keys=sort keys %$value}}elsif ($self->sort_keys==2){@keys=sort keys %$value}elsif (ref($self->sort_keys)eq 'ARRAY'){my$i=1;my%order=map {($_,$i++)}@{$self->sort_keys};@keys=sort {(defined$order{$a}and defined$order{$b})? ($order{$a}<=> $order{$b}): ($a cmp $b)}keys %$value}else {@keys=keys %$value}if (exists$value->{&VALUE}){for (my$i=0;$i < @keys;$i++){if ($keys[$i]eq &VALUE){splice(@keys,$i,1);push@keys,&VALUE;last}}}for my$key (@keys){$self->_emit_key($key,$context);$context=0;$self->{stream}.= ':';$self->_emit_node($value->{$key})}$self->{level}--}sub _emit_sequence {my$self=shift;my ($value,$tag)=@_;$self->{stream}.= " !$tag" if$tag;return ($self->{stream}.= " []\n")if @$value==0;$self->{stream}.= "\n" unless$self->headless && not($self->headless(0));if ($self->inline_series and @$value <= $self->inline_series and not (scalar grep {ref or /\n/}@$value)){$self->{stream}=~ s/\n\Z/ /;$self->{stream}.= '[';for (my$i=0;$i < @$value;$i++){$self->_emit_str($value->[$i],KEY);last if$i==$#{$value};$self->{stream}.= ', '}$self->{stream}.= "]\n";return}$self->offset->[$self->level + 1]=$self->offset->[$self->level]+ $self->indent_width;$self->{level}++;for my$val (@$value){$self->{stream}.= ' ' x $self->offset->[$self->level];$self->{stream}.= '-';$self->_emit_node($val,FROMARRAY)}$self->{level}--}sub _emit_key {my$self=shift;my ($value,$context)=@_;$self->{stream}.= ' ' x $self->offset->[$self->level]unless$context==FROMARRAY;$self->_emit_str($value,KEY)}sub _emit_scalar {my$self=shift;my ($value,$tag)=@_;$self->{stream}.= " !$tag";$self->_emit_str($value,BLESSED)}sub _emit {my$self=shift;$self->{stream}.= join '',@_}sub _emit_str {my$self=shift;my$type=$_[1]|| 0;$self->offset->[$self->level + 1]=$self->offset->[$self->level]+ $self->indent_width;$self->{level}++;my$sf=$type==KEY ? '' : ' ';my$sb=$type==KEY ? '? ' : ' ';my$ef=$type==KEY ? '' : "\n";my$eb="\n";while (1){$self->_emit($sf),$self->_emit_plain($_[0]),$self->_emit($ef),last if not defined $_[0];$self->_emit($sf,'=',$ef),last if $_[0]eq VALUE;$self->_emit($sf),$self->_emit_double($_[0]),$self->_emit($ef),last if $_[0]=~ /$ESCAPE_CHAR/;if ($_[0]=~ /\n/){$self->_emit($sb),$self->_emit_block($LIT_CHAR,$_[0]),$self->_emit($eb),last if$self->use_block;Carp::cluck "[YAML] \$UseFold is no longer supported" if$self->use_fold;$self->_emit($sf),$self->_emit_double($_[0]),$self->_emit($ef),last if length $_[0]<= 30;$self->_emit($sf),$self->_emit_double($_[0]),$self->_emit($ef),last if $_[0]!~ /\n\s*\S/;$self->_emit($sb),$self->_emit_block($LIT_CHAR,$_[0]),$self->_emit($eb),last}$self->_emit($sf),$self->_emit_plain($_[0]),$self->_emit($ef),last if$self->is_valid_plain($_[0]);$self->_emit($sf),$self->_emit_double($_[0]),$self->_emit($ef),last if $_[0]=~ /'/;$self->_emit($sf),$self->_emit_single($_[0]),$self->_emit($ef);last}$self->{level}--;return}sub is_valid_plain {my$self=shift;return 0 unless length $_[0];return 0 if $_[0]=~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;return 0 if $_[0]=~ /[\{\[\]\},]/;return 0 if $_[0]=~ /[:\-\?]\s/;return 0 if $_[0]=~ /\s#/;return 0 if $_[0]=~ /\:(\s|$)/;return 0 if $_[0]=~ /[\s\|\>]$/;return 1}sub _emit_block {my$self=shift;my ($indicator,$value)=@_;$self->{stream}.= $indicator;$value =~ /(\n*)\Z/;my$chomp=length $1 ? (length $1 > 1)? '+' : '' : '-';$value='~' if not defined$value;$self->{stream}.= $chomp;$self->{stream}.= $self->indent_width if$value =~ /^\s/;$self->{stream}.= $self->indent($value)}sub _emit_plain {my$self=shift;$self->{stream}.= defined $_[0]? $_[0]: '~'}sub _emit_double {my$self=shift;(my$escaped=$self->escape($_[0]))=~ s/"/\\"/g;$self->{stream}.= qq{"$escaped"}}sub _emit_single {my$self=shift;my$item=shift;$item =~ s{'}{''}g;$self->{stream}.= "'$item'"}sub indent {my$self=shift;my ($text)=@_;return$text unless length$text;$text =~ s/\n\Z//;my$indent=' ' x $self->offset->[$self->level];$text =~ s/^/$indent/gm;$text="\n$text";return$text}my@escapes=qw(\0 \x01 \x02 \x03 \x04 \x05 \x06 \a \x08 \t \n \v \f \r \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 \x1a \e \x1c \x1d \x1e \x1f);sub escape {my$self=shift;my ($text)=@_;$text =~ s/\\/\\\\/g;$text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;return$text}1;
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;use YAML::Mo;our$VERSION='0.84';use YAML::Node;has spec_version=>default=>sub {'1.0'};has indent_width=>default=>sub {2};has use_header=>default=>sub {1};has use_version=>default=>sub {0};has sort_keys=>default=>sub {1};has anchor_prefix=>default=>sub {''};has dump_code=>default=>sub {0};has use_block=>default=>sub {0};has use_fold=>default=>sub {0};has compress_series=>default=>sub {1};has inline_series=>default=>sub {0};has use_aliases=>default=>sub {1};has purity=>default=>sub {0};has stringify=>default=>sub {0};has stream=>default=>sub {''};has document=>default=>sub {0};has transferred=>default=>sub {{}};has id_refcnt=>default=>sub {{}};has id_anchor=>default=>sub {{}};has anchor=>default=>sub {1};has level=>default=>sub {0};has offset=>default=>sub {[]};has headless=>default=>sub {0};has blessed_map=>default=>sub {{}};sub set_global_options {my$self=shift;$self->spec_version($YAML::SpecVersion)if defined$YAML::SpecVersion;$self->indent_width($YAML::Indent)if defined$YAML::Indent;$self->use_header($YAML::UseHeader)if defined$YAML::UseHeader;$self->use_version($YAML::UseVersion)if defined$YAML::UseVersion;$self->sort_keys($YAML::SortKeys)if defined$YAML::SortKeys;$self->anchor_prefix($YAML::AnchorPrefix)if defined$YAML::AnchorPrefix;$self->dump_code($YAML::DumpCode || $YAML::UseCode)if defined$YAML::DumpCode or defined$YAML::UseCode;$self->use_block($YAML::UseBlock)if defined$YAML::UseBlock;$self->use_fold($YAML::UseFold)if defined$YAML::UseFold;$self->compress_series($YAML::CompressSeries)if defined$YAML::CompressSeries;$self->inline_series($YAML::InlineSeries)if defined$YAML::InlineSeries;$self->use_aliases($YAML::UseAliases)if defined$YAML::UseAliases;$self->purity($YAML::Purity)if defined$YAML::Purity;$self->stringify($YAML::Stringify)if defined$YAML::Stringify}sub dump {my$self=shift;$self->die('dump() not implemented in this class.')}sub blessed {my$self=shift;my ($ref)=@_;$ref=\$_[0]unless ref$ref;my (undef,undef,$node_id)=YAML::Mo::Object->node_info($ref);$self->{blessed_map}->{$node_id}}sub bless {my$self=shift;my ($ref,$blessing)=@_;my$ynode;$ref=\$_[0]unless ref$ref;my (undef,undef,$node_id)=YAML::Mo::Object->node_info($ref);if (not defined$blessing){$ynode=YAML::Node->new($ref)}elsif (ref$blessing){$self->die()unless ynode($blessing);$ynode=$blessing}else {no strict 'refs';my$transfer=$blessing ."::yaml_dump";$self->die()unless defined &{$transfer};$ynode=&{$transfer}($ref);$self->die()unless ynode($ynode)}$self->{blessed_map}->{$node_id}=$ynode;my$object=ynode($ynode)or $self->die();return$object;}1;
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;use YAML::Mo;our$VERSION='0.84';has 'code';has 'type'=>default=>sub {'Error'};has 'line';has 'document';has 'arguments'=>default=>sub {[]};my ($error_messages,%line_adjust);sub format_message {my$self=shift;my$output='YAML ' .$self->type .': ';my$code=$self->code;if ($error_messages->{$code}){$code=sprintf($error_messages->{$code},@{$self->arguments})}$output .= $code ."\n";$output .= '   Code: ' .$self->code ."\n" if defined$self->code;$output .= '   Line: ' .$self->line ."\n" if defined$self->line;$output .= '   Document: ' .$self->document ."\n" if defined$self->document;return$output}sub error_messages {$error_messages}%$error_messages=map {s/^\s+//;$_}split "\n",<<'...';%line_adjust=map {($_,1)}qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION YAML_PARSE_WARN_BAD_MINOR_VERSION YAML_PARSE_ERR_TEXT_AFTER_INDICATOR YAML_PARSE_ERR_NO_ANCHOR YAML_PARSE_ERR_MANY_EXPLICIT YAML_PARSE_ERR_MANY_IMPLICIT YAML_PARSE_ERR_MANY_ANCHOR YAML_PARSE_ERR_ANCHOR_ALIAS YAML_PARSE_ERR_BAD_ALIAS YAML_PARSE_ERR_MANY_ALIAS YAML_LOAD_ERR_NO_CONVERT YAML_LOAD_ERR_NO_DEFAULT_VALUE YAML_LOAD_ERR_NON_EMPTY_STRING YAML_LOAD_ERR_BAD_MAP_TO_SEQ YAML_LOAD_ERR_BAD_STR_TO_INT YAML_LOAD_ERR_BAD_STR_TO_DATE YAML_LOAD_ERR_BAD_STR_TO_TIME YAML_LOAD_WARN_DUPLICATE_KEY YAML_PARSE_ERR_INLINE_MAP YAML_PARSE_ERR_INLINE_SEQUENCE YAML_PARSE_ERR_BAD_DOUBLE YAML_PARSE_ERR_BAD_SINGLE YAML_PARSE_ERR_BAD_INLINE_IMPLICIT YAML_PARSE_ERR_BAD_IMPLICIT YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP YAML_LOAD_WARN_BAD_REGEXP_ELEM YAML_LOAD_WARN_REGEXP_CREATE YAML_LOAD_WARN_GLOB_NAME YAML_LOAD_WARN_PARSE_CODE YAML_LOAD_WARN_CODE_DEPARSE YAML_LOAD_WARN_BAD_GLOB_ELEM YAML_PARSE_ERR_ZERO_INDENT);package YAML::Warning;our@ISA='YAML::Error';1;
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;use YAML::Mo;extends 'YAML::Loader::Base';our$VERSION='0.84';use YAML::Loader::Base;use YAML::Types;use constant LEAF=>1;use constant COLLECTION=>2;use constant VALUE=>"\x07YAML\x07VALUE\x07";use constant COMMENT=>"\x07YAML\x07COMMENT\x07";my$ESCAPE_CHAR='[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';my$FOLD_CHAR='>';my$LIT_CHAR='|';my$LIT_CHAR_RX="\\$LIT_CHAR";sub load {my$self=shift;$self->stream($_[0]|| '');return$self->_parse()}sub _parse {my$self=shift;my (%directives,$preface);$self->{stream}=~ s|\015\012|\012|g;$self->{stream}=~ s|\015|\012|g;$self->line(0);$self->die('YAML_PARSE_ERR_BAD_CHARS')if$self->stream =~ /$ESCAPE_CHAR/;$self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE')if length($self->stream)and $self->{stream}!~ s/(.)\n\Z/$1/s;$self->lines([split /\x0a/,$self->stream,-1]);$self->line(1);$self->_parse_throwaway_comments();$self->document(0);$self->documents([]);if (not $self->eos){if ($self->lines->[0]!~ /^---(\s|$)/){unshift @{$self->lines},'---';$self->{line}--}}while (not $self->eos){$self->anchor2node({});$self->{document}++;$self->done(0);$self->level(0);$self->offset->[0]=-1;if ($self->lines->[0]=~ /^---\s*(.*)$/){my@words=split /\s+/,$1;%directives=();while (@words && $words[0]=~ /^#(\w+):(\S.*)$/){my ($key,$value)=($1,$2);shift(@words);if (defined$directives{$key}){$self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',$key,$self->document);next}$directives{$key}=$value}$self->preface(join ' ',@words)}else {$self->die('YAML_PARSE_ERR_NO_SEPARATOR')}if (not $self->done){$self->_parse_next_line(COLLECTION)}if ($self->done){$self->{indent}=-1;$self->content('')}$directives{YAML}||='1.0';$directives{TAB}||='NONE';($self->{major_version},$self->{minor_version})=split /\./,$directives{YAML},2;$self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION',$directives{YAML})if$self->major_version ne '1';$self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION',$directives{YAML})if$self->minor_version ne '0';$self->die('Unrecognized TAB policy')unless$directives{TAB}=~ /^(NONE|\d+)(:HARD)?$/;push @{$self->documents},$self->_parse_node()}return wantarray ? @{$self->documents}: $self->documents->[-1]}sub _parse_node {my$self=shift;my$preface=$self->preface;$self->preface('');my ($node,$type,$indicator,$escape,$chomp)=('')x 5;my ($anchor,$alias,$explicit,$implicit,$class)=('')x 5;($anchor,$alias,$explicit,$implicit,$preface)=$self->_parse_qualifiers($preface);if ($anchor){$self->anchor2node->{$anchor}=CORE::bless [],'YAML-anchor2node'}$self->inline('');while (length$preface){my$line=$self->line - 1;if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//){$indicator=$1;$chomp=$2 if defined($2)}else {$self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR')if$indicator;$self->inline($preface);$preface=''}}if ($alias){$self->die('YAML_PARSE_ERR_NO_ANCHOR',$alias)unless defined$self->anchor2node->{$alias};if (ref($self->anchor2node->{$alias})ne 'YAML-anchor2node'){$node=$self->anchor2node->{$alias}}else {$node=do {my$sv="*$alias"};push @{$self->anchor2node->{$alias}},[\$node,$self->line]}}elsif (length$self->inline){$node=$self->_parse_inline(1,$implicit,$explicit);if (length$self->inline){$self->die('YAML_PARSE_ERR_SINGLE_LINE')}}elsif ($indicator eq $LIT_CHAR){$self->{level}++;$node=$self->_parse_block($chomp);$node=$self->_parse_implicit($node)if$implicit;$self->{level}--}elsif ($indicator eq $FOLD_CHAR){$self->{level}++;$node=$self->_parse_unfold($chomp);$node=$self->_parse_implicit($node)if$implicit;$self->{level}--}else {$self->{level}++;$self->offset->[$self->level]||=0;if ($self->indent==$self->offset->[$self->level]){if ($self->content =~ /^-( |$)/){$node=$self->_parse_seq($anchor)}elsif ($self->content =~ /(^\?|\:( |$))/){$node=$self->_parse_mapping($anchor)}elsif ($preface =~ /^\s*$/){$node=$self->_parse_implicit('')}else {$self->die('YAML_PARSE_ERR_BAD_NODE')}}else {$node=undef}$self->{level}--}$#{$self->offset}=$self->level;if ($explicit){if ($class){if (not ref$node){my$copy=$node;undef$node;$node=\$copy}CORE::bless$node,$class}else {$node=$self->_parse_explicit($node,$explicit)}}if ($anchor){if (ref($self->anchor2node->{$anchor})eq 'YAML-anchor2node'){for my$ref (@{$self->anchor2node->{$anchor}}){${$ref->[0]}=$node;$self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',$anchor,$ref->[1])}}$self->anchor2node->{$anchor}=$node}return$node}sub _parse_qualifiers {my$self=shift;my ($preface)=@_;my ($anchor,$alias,$explicit,$implicit,$token)=('')x 5;$self->inline('');while ($preface =~ /^[&*!]/){my$line=$self->line - 1;if ($preface =~ s/^\!(\S+)\s*//){$self->die('YAML_PARSE_ERR_MANY_EXPLICIT')if$explicit;$explicit=$1}elsif ($preface =~ s/^\!\s*//){$self->die('YAML_PARSE_ERR_MANY_IMPLICIT')if$implicit;$implicit=1}elsif ($preface =~ s/^\&([^ ,:]+)\s*//){$token=$1;$self->die('YAML_PARSE_ERR_BAD_ANCHOR')unless$token =~ /^[a-zA-Z0-9]+$/;$self->die('YAML_PARSE_ERR_MANY_ANCHOR')if$anchor;$self->die('YAML_PARSE_ERR_ANCHOR_ALIAS')if$alias;$anchor=$token}elsif ($preface =~ s/^\*([^ ,:]+)\s*//){$token=$1;$self->die('YAML_PARSE_ERR_BAD_ALIAS')unless$token =~ /^[a-zA-Z0-9]+$/;$self->die('YAML_PARSE_ERR_MANY_ALIAS')if$alias;$self->die('YAML_PARSE_ERR_ANCHOR_ALIAS')if$anchor;$alias=$token}}return ($anchor,$alias,$explicit,$implicit,$preface)}sub _parse_explicit {my$self=shift;my ($node,$explicit)=@_;my ($type,$class);if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/){($type,$class)=(($1 || ''),($2 || ''));if ($type eq "ref"){$self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE','XXX',$explicit)unless exists$node->{VALUE()}and scalar(keys %$node)==1;my$value=$node->{VALUE()};$node=\$value}if ($type eq "scalar" and length($class)and!ref($node)){my$value=$node;$node=\$value}if (length($class)){CORE::bless($node,$class)}return$node}if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}){($type,$class)=(($1 || ''),($2 || ''));my$type_class="YAML::Type::$type";no strict 'refs';if ($type_class->can('yaml_load')){return$type_class->yaml_load($node,$class,$self)}else {$self->die('YAML_LOAD_ERR_NO_CONVERT','XXX',$explicit)}}elsif ($YAML::TagClass->{$explicit}|| $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}){$class=$YAML::TagClass->{$explicit}|| $2;if ($class->can('yaml_load')){require YAML::Node;return$class->yaml_load(YAML::Node->new($node,$explicit))}else {if (ref$node){return CORE::bless$node,$class}else {return CORE::bless \$node,$class}}}elsif (ref$node){require YAML::Node;return YAML::Node->new($node,$explicit)}else {return$node}}sub _parse_mapping {my$self=shift;my ($anchor)=@_;my$mapping={};$self->anchor2node->{$anchor}=$mapping;my$key;while (not $self->done and $self->indent==$self->offset->[$self->level]){if ($self->{content}=~ s/^\?\s*//){$self->preface($self->content);$self->_parse_next_line(COLLECTION);$key=$self->_parse_node();$key="$key"}elsif ($self->{content}=~ s/^\=\s*//){$key=VALUE}elsif ($self->{content}=~ s/^\=\s*//){$key=COMMENT}else {$self->inline($self->content);$key=$self->_parse_inline();$key="$key";$self->content($self->inline);$self->inline('')}unless ($self->{content}=~ s/^:\s*//){$self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT')}$self->preface($self->content);my$line=$self->line;$self->_parse_next_line(COLLECTION);my$value=$self->_parse_node();if (exists$mapping->{$key}){$self->warn('YAML_LOAD_WARN_DUPLICATE_KEY')}else {$mapping->{$key}=$value}}return$mapping}sub _parse_seq {my$self=shift;my ($anchor)=@_;my$seq=[];$self->anchor2node->{$anchor}=$seq;while (not $self->done and $self->indent==$self->offset->[$self->level]){if ($self->content =~ /^-(?: (.*))?$/){$self->preface(defined($1)? $1 : '')}else {$self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT')}if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/){$self->indent($self->offset->[$self->level]+ 2 + length($1));$self->content($2);$self->level($self->level + 1);$self->offset->[$self->level]=$self->indent;$self->preface('');push @$seq,$self->_parse_mapping('');$self->{level}--;$#{$self->offset}=$self->level}else {$self->_parse_next_line(COLLECTION);push @$seq,$self->_parse_node()}}return$seq}sub _parse_inline {my$self=shift;my ($top,$top_implicit,$top_explicit)=(@_,'','','');$self->{inline}=~ s/^\s*(.*)\s*$/$1/;my ($node,$anchor,$alias,$explicit,$implicit)=('')x 5;($anchor,$alias,$explicit,$implicit,$self->{inline})=$self->_parse_qualifiers($self->inline);if ($anchor){$self->anchor2node->{$anchor}=CORE::bless [],'YAML-anchor2node'}$implicit ||=$top_implicit;$explicit ||=$top_explicit;($top_implicit,$top_explicit)=('','');if ($alias){$self->die('YAML_PARSE_ERR_NO_ANCHOR',$alias)unless defined$self->anchor2node->{$alias};if (ref($self->anchor2node->{$alias})ne 'YAML-anchor2node'){$node=$self->anchor2node->{$alias}}else {$node=do {my$sv="*$alias"};push @{$self->anchor2node->{$alias}},[\$node,$self->line]}}elsif ($self->inline =~ /^\{/){$node=$self->_parse_inline_mapping($anchor)}elsif ($self->inline =~ /^\[/){$node=$self->_parse_inline_seq($anchor)}elsif ($self->inline =~ /^"/){$node=$self->_parse_inline_double_quoted();$node=$self->_unescape($node);$node=$self->_parse_implicit($node)if$implicit}elsif ($self->inline =~ /^'/){$node=$self->_parse_inline_single_quoted();$node=$self->_parse_implicit($node)if$implicit}else {if ($top){$node=$self->inline;$self->inline('')}else {$node=$self->_parse_inline_simple()}$node=$self->_parse_implicit($node)unless$explicit}if ($explicit){$node=$self->_parse_explicit($node,$explicit)}if ($anchor){if (ref($self->anchor2node->{$anchor})eq 'YAML-anchor2node'){for my$ref (@{$self->anchor2node->{$anchor}}){${$ref->[0]}=$node;$self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',$anchor,$ref->[1])}}$self->anchor2node->{$anchor}=$node}return$node}sub _parse_inline_mapping {my$self=shift;my ($anchor)=@_;my$node={};$self->anchor2node->{$anchor}=$node;$self->die('YAML_PARSE_ERR_INLINE_MAP')unless$self->{inline}=~ s/^\{\s*//;while (not $self->{inline}=~ s/^\s*\}//){my$key=$self->_parse_inline();$self->die('YAML_PARSE_ERR_INLINE_MAP')unless$self->{inline}=~ s/^\: \s*//;my$value=$self->_parse_inline();if (exists$node->{$key}){$self->warn('YAML_LOAD_WARN_DUPLICATE_KEY')}else {$node->{$key}=$value}next if$self->inline =~ /^\s*\}/;$self->die('YAML_PARSE_ERR_INLINE_MAP')unless$self->{inline}=~ s/^\,\s*//}return$node}sub _parse_inline_seq {my$self=shift;my ($anchor)=@_;my$node=[];$self->anchor2node->{$anchor}=$node;$self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')unless$self->{inline}=~ s/^\[\s*//;while (not $self->{inline}=~ s/^\s*\]//){my$value=$self->_parse_inline();push @$node,$value;next if$self->inline =~ /^\s*\]/;$self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')unless$self->{inline}=~ s/^\,\s*//}return$node}sub _parse_inline_double_quoted {my$self=shift;my$node;if ($self->inline =~ /^"((?:\\"|[^"])*)"\s*(.*)$/){$node=$1;$self->inline($2);$node =~ s/\\"/"/g}else {$self->die('YAML_PARSE_ERR_BAD_DOUBLE')}return$node}sub _parse_inline_single_quoted {my$self=shift;my$node;if ($self->inline =~ /^'((?:''|[^'])*)'\s*(.*)$/){$node=$1;$self->inline($2);$node =~ s/''/'/g}else {$self->die('YAML_PARSE_ERR_BAD_SINGLE')}return$node}sub _parse_inline_simple {my$self=shift;my$value;if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/){$value=$1;substr($self->{inline},0,length($1))=''}else {$self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT',$value)}return$value}sub _parse_implicit {my$self=shift;my ($value)=@_;$value =~ s/\s*$//;return$value if$value eq '';return undef if$value =~ /^~$/;return$value unless$value =~ /^[\@\`\^]/ or $value =~ /^[\-\?]\s/;$self->die('YAML_PARSE_ERR_BAD_IMPLICIT',$value)}sub _parse_unfold {my$self=shift;my ($chomp)=@_;my$node='';my$space=0;while (not $self->done and $self->indent==$self->offset->[$self->level]){$node .= $self->content."\n";$self->_parse_next_line(LEAF)}$node =~ s/^(\S.*)\n(?=\S)/$1 /gm;$node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;$node =~ s/\n*\Z// unless$chomp eq '+';$node .= "\n" unless$chomp;return$node}sub _parse_block {my$self=shift;my ($chomp)=@_;my$node='';while (not $self->done and $self->indent==$self->offset->[$self->level]){$node .= $self->content ."\n";$self->_parse_next_line(LEAF)}return$node if '+' eq $chomp;$node =~ s/\n*\Z/\n/;$node =~ s/\n\Z// if$chomp eq '-';return$node}sub _parse_throwaway_comments {my$self=shift;while (@{$self->lines}and $self->lines->[0]=~ m{^\s*(\#|$)}){shift @{$self->lines};$self->{line}++}$self->eos($self->{done}=not @{$self->lines})}sub _parse_next_line {my$self=shift;my ($type)=@_;my$level=$self->level;my$offset=$self->offset->[$level];$self->die('YAML_EMIT_ERR_BAD_LEVEL')unless defined$offset;shift @{$self->lines};$self->eos($self->{done}=not @{$self->lines});return if$self->eos;$self->{line}++;if ($self->preface =~ qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/){$self->die('YAML_PARSE_ERR_ZERO_INDENT')if length($1)and $1==0;$type=LEAF;if (length($1)){$self->offset->[$level + 1]=$offset + $1}else {while (@{$self->lines}&& ($self->lines->[0]=~ /^\s*#/)){$self->lines->[0]=~ /^( *)/ or die;last unless length($1)<= $offset;shift @{$self->lines};$self->{line}++}$self->eos($self->{done}=not @{$self->lines});return if$self->eos;if ($self->lines->[0]=~ /^( *)\S/ and length($1)> $offset){$self->offset->[$level+1]=length($1)}else {$self->offset->[$level+1]=$offset + 1}}$offset=$self->offset->[++$level]}elsif ($type==COLLECTION and $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/){$self->_parse_throwaway_comments();if ($self->eos){$self->offset->[$level+1]=$offset + 1;return}else {$self->lines->[0]=~ /^( *)\S/ or die;if (length($1)> $offset){$self->offset->[$level+1]=length($1)}else {$self->offset->[$level+1]=$offset + 1}}$offset=$self->offset->[++$level]}if ($type==LEAF){while (@{$self->lines}and $self->lines->[0]=~ m{^( *)(\#)} and length($1)< $offset){shift @{$self->lines};$self->{line}++}$self->eos($self->{done}=not @{$self->lines})}else {$self->_parse_throwaway_comments()}return if$self->eos;if ($self->lines->[0]=~ /^---(\s|$)/){$self->done(1);return}if ($type==LEAF and $self->lines->[0]=~ /^ {$offset}(.*)$/){$self->indent($offset);$self->content($1)}elsif ($self->lines->[0]=~ /^\s*$/){$self->indent($offset);$self->content('')}else {$self->lines->[0]=~ /^( *)(\S.*)$/;while ($self->offset->[$level]> length($1)){$level--}$self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION')if$self->offset->[$level]!=length($1);$self->indent(length($1));$self->content($2)}$self->die('YAML_PARSE_ERR_INDENTATION')if$self->indent - $offset > 1}my%unescapes=(0=>"\x00",a=>"\x07",t=>"\x09",n=>"\x0a",'v'=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);sub _unescape {my$self=shift;my ($node)=@_;$node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;return$node}1;
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;use YAML::Mo;our$VERSION='0.84';has load_code=>default=>sub {0};has stream=>default=>sub {''};has document=>default=>sub {0};has line=>default=>sub {0};has documents=>default=>sub {[]};has lines=>default=>sub {[]};has eos=>default=>sub {0};has done=>default=>sub {0};has anchor2node=>default=>sub {{}};has level=>default=>sub {0};has offset=>default=>sub {[]};has preface=>default=>sub {''};has content=>default=>sub {''};has indent=>default=>sub {0};has major_version=>default=>sub {0};has minor_version=>default=>sub {0};has inline=>default=>sub {''};sub set_global_options {my$self=shift;$self->load_code($YAML::LoadCode || $YAML::UseCode)if defined$YAML::LoadCode or defined$YAML::UseCode}sub load {die 'load() not implemented in this class.'}1;
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict;use warnings;package YAML::Marshall;our$VERSION='0.84';use YAML::Node ();sub import {my$class=shift;no strict 'refs';my$package=caller;unless (grep {$_ eq $class}@{$package .'::ISA'}){push @{$package .'::ISA'},$class}my$tag=shift;if ($tag){no warnings 'once';$YAML::TagClass->{$tag}=$package;${$package ."::YamlTag"}=$tag}}sub yaml_dump {my$self=shift;no strict 'refs';my$tag=${ref($self)."::YamlTag"}|| 'perl/' .ref($self);$self->yaml_node($self,$tag)}sub yaml_load {my ($class,$node)=@_;if (my$ynode=$class->yaml_ynode($node)){$node=$ynode->{NODE}}bless$node,$class}sub yaml_node {shift;YAML::Node->new(@_)}sub yaml_ynode {shift;YAML::Node::ynode(@_)}1;
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo;$VERSION='0.84';no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;our$DumperModule='Data::Dumper';my ($_new_error,$_info,$_scalar_info);no strict 'refs';*{$M.'Object::die'}=sub {my$self=shift;my$error=$self->$_new_error(@_);$error->type('Error');Carp::croak($error->format_message)};*{$M.'Object::warn'}=sub {my$self=shift;return unless $^W;my$error=$self->$_new_error(@_);$error->type('Warning');Carp::cluck($error->format_message)};*{$M.'Object::node_info'}=sub {my$self=shift;my$stringify=$_[1]|| 0;my ($class,$type,$id)=ref($_[0])? $stringify ? &$_info("$_[0]"): do {require overload;my@info=&$_info(overload::StrVal($_[0]));if (ref($_[0])eq 'Regexp'){@info[0,1]=(undef,'REGEXP')}@info}: &$_scalar_info($_[0]);($class,$type,$id)=&$_scalar_info("$_[0]")unless$id;return wantarray ? ($class,$type,$id): $id};$_info=sub {return (($_[0])=~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o)};$_scalar_info=sub {my$id='undef';if (defined $_[0]){\$_[0]=~ /\((\w+)\)$/o or CORE::die();$id="$1-S"}return (undef,undef,$id)};$_new_error=sub {require Carp;my$self=shift;require YAML::Error;my$code=shift || 'unknown error';my$error=YAML::Error->new(code=>$code);$error->line($self->line)if$self->can('line');$error->document($self->document)if$self->can('document');$error->arguments([@_]);return$error};1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict;use warnings;package YAML::Node;our$VERSION='0.84';use YAML::Tag;require YAML::Mo;use Exporter;our@ISA=qw(Exporter YAML::Mo::Object);our@EXPORT=qw(ynode);sub ynode {my$self;if (ref($_[0])eq 'HASH'){$self=tied(%{$_[0]})}elsif (ref($_[0])eq 'ARRAY'){$self=tied(@{$_[0]})}elsif (ref(\$_[0])eq 'GLOB'){$self=tied(*{$_[0]})}else {$self=tied($_[0])}return (ref($self)=~ /^yaml_/)? $self : undef}sub new {my ($class,$node,$tag)=@_;my$self;$self->{NODE}=$node;my (undef,$type)=YAML::Mo::Object->node_info($node);$self->{KIND}=(not defined$type)? 'scalar' : ($type eq 'ARRAY')? 'sequence' : ($type eq 'HASH')? 'mapping' : $class->die("Can't create YAML::Node from '$type'");tag($self,($tag || ''));if ($self->{KIND}eq 'scalar'){yaml_scalar->new($self,$_[1]);return \ $_[1]}my$package="yaml_" .$self->{KIND};$package->new($self)}sub node {$_->{NODE}}sub kind {$_->{KIND}}sub tag {my ($self,$value)=@_;if (defined$value){$self->{TAG}=YAML::Tag->new($value);return$self}else {return$self->{TAG}}}sub keys {my ($self,$value)=@_;if (defined$value){$self->{KEYS}=$value;return$self}else {return$self->{KEYS}}}package yaml_scalar;@yaml_scalar::ISA=qw(YAML::Node);sub new {my ($class,$self)=@_;tie $_[2],$class,$self}sub TIESCALAR {my ($class,$self)=@_;bless$self,$class;$self}sub FETCH {my ($self)=@_;$self->{NODE}}sub STORE {my ($self,$value)=@_;$self->{NODE}=$value}package yaml_sequence;@yaml_sequence::ISA=qw(YAML::Node);sub new {my ($class,$self)=@_;my$new;tie @$new,$class,$self;$new}sub TIEARRAY {my ($class,$self)=@_;bless$self,$class}sub FETCHSIZE {my ($self)=@_;scalar @{$self->{NODE}}}sub FETCH {my ($self,$index)=@_;$self->{NODE}[$index]}sub STORE {my ($self,$index,$value)=@_;$self->{NODE}[$index]=$value}sub undone {die "Not implemented yet"}*STORESIZE=*POP=*PUSH=*SHIFT=*UNSHIFT=*SPLICE=*DELETE=*EXISTS=*STORESIZE=*POP=*PUSH=*SHIFT=*UNSHIFT=*SPLICE=*DELETE=*EXISTS=*undone;package yaml_mapping;@yaml_mapping::ISA=qw(YAML::Node);sub new {my ($class,$self)=@_;@{$self->{KEYS}}=sort keys %{$self->{NODE}};my$new;tie %$new,$class,$self;$new}sub TIEHASH {my ($class,$self)=@_;bless$self,$class}sub FETCH {my ($self,$key)=@_;if (exists$self->{NODE}{$key}){return (grep {$_ eq $key}@{$self->{KEYS}})? $self->{NODE}{$key}: undef}return$self->{HASH}{$key}}sub STORE {my ($self,$key,$value)=@_;if (exists$self->{NODE}{$key}){$self->{NODE}{$key}=$value}elsif (exists$self->{HASH}{$key}){$self->{HASH}{$key}=$value}else {if (not grep {$_ eq $key}@{$self->{KEYS}}){push(@{$self->{KEYS}},$key)}$self->{HASH}{$key}=$value}$value}sub DELETE {my ($self,$key)=@_;my$return;if (exists$self->{NODE}{$key}){$return=$self->{NODE}{$key}}elsif (exists$self->{HASH}{$key}){$return=delete$self->{NODE}{$key}}for (my$i=0;$i < @{$self->{KEYS}};$i++){if ($self->{KEYS}[$i]eq $key){splice(@{$self->{KEYS}},$i,1)}}return$return}sub CLEAR {my ($self)=@_;@{$self->{KEYS}}=();%{$self->{HASH}}=()}sub FIRSTKEY {my ($self)=@_;$self->{ITER}=0;$self->{KEYS}[0]}sub NEXTKEY {my ($self)=@_;$self->{KEYS}[++$self->{ITER}]}sub EXISTS {my ($self,$key)=@_;exists$self->{NODE}{$key}}1;
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict;use warnings;package YAML::Tag;our$VERSION='0.84';use overload '""'=>sub {${$_[0]}};sub new {my ($class,$self)=@_;bless \$self,$class}sub short {${$_[0]}}sub canonical {${$_[0]}}1;
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;use YAML::Mo;our$VERSION='0.84';use YAML::Node;package YAML::Type::blessed;use YAML::Mo;sub yaml_dump {my$self=shift;my ($value)=@_;my ($class,$type)=YAML::Mo::Object->node_info($value);no strict 'refs';my$kind=lc($type).':';my$tag=${$class .'::ClassTag'}|| "!perl/$kind$class";if ($type eq 'REF'){YAML::Node->new({(&YAML::VALUE,${$_[0]})},$tag)}elsif ($type eq 'SCALAR'){$_[1]=$$value;YAML::Node->new($_[1],$tag)}else {YAML::Node->new($value,$tag)}}package YAML::Type::undef;sub yaml_dump {my$self=shift}sub yaml_load {my$self=shift}package YAML::Type::glob;sub yaml_dump {my$self=shift;my$ynode=YAML::Node->new({},'!perl/glob:');for my$type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)){my$value=*{$_[0]}{$type};$value=$$value if$type eq 'SCALAR';if (defined$value){if ($type eq 'IO'){my@stats=qw(device inode mode links uid gid rdev size atime mtime ctime blksize blocks);undef$value;$value->{stat}=YAML::Node->new({});if ($value->{fileno}=fileno(*{$_[0]})){local $^W;map {$value->{stat}{shift@stats}=$_}stat(*{$_[0]});$value->{tell}=tell(*{$_[0]})}}$ynode->{$type}=$value}}return$ynode}sub yaml_load {my$self=shift;my ($node,$class,$loader)=@_;my ($name,$package);if (defined$node->{NAME}){$name=$node->{NAME};delete$node->{NAME}}else {$loader->warn('YAML_LOAD_WARN_GLOB_NAME');return undef}if (defined$node->{PACKAGE}){$package=$node->{PACKAGE};delete$node->{PACKAGE}}else {$package='main'}no strict 'refs';if (exists$node->{SCALAR}){*{"${package}::$name"}=\$node->{SCALAR};delete$node->{SCALAR}}for my$elem (qw(ARRAY HASH CODE IO)){if (exists$node->{$elem}){if ($elem eq 'IO'){$loader->warn('YAML_LOAD_WARN_GLOB_IO');delete$node->{IO};next}*{"${package}::$name"}=$node->{$elem};delete$node->{$elem}}}for my$elem (sort keys %$node){$loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM',$elem)}return *{"${package}::$name"}}package YAML::Type::code;my$dummy_warned=0;my$default='{ "DUMMY" }';sub yaml_dump {my$self=shift;my$code;my ($dumpflag,$value)=@_;my ($class,$type)=YAML::Mo::Object->node_info($value);my$tag="!perl/code";$tag .= ":$class" if defined$class;if (not $dumpflag){$code=$default}else {bless$value,"CODE" if$class;eval {use B::Deparse};return if $@;my$deparse=B::Deparse->new();eval {local $^W=0;$code=$deparse->coderef2text($value)};if ($@){warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED()if $^W;$code=$default}bless$value,$class if$class;chomp$code;$code .= "\n"}$_[2]=$code;YAML::Node->new($_[2],$tag)}sub yaml_load {my$self=shift;my ($node,$class,$loader)=@_;if ($loader->load_code){my$code=eval "package main; sub $node";if ($@){$loader->warn('YAML_LOAD_WARN_PARSE_CODE',$@);return sub {}}else {CORE::bless$code,$class if$class;return$code}}else {return CORE::bless sub {},$class if$class;return sub {}}}package YAML::Type::ref;sub yaml_dump {my$self=shift;YAML::Node->new({(&YAML::VALUE,${$_[0]})},'!perl/ref')}sub yaml_load {my$self=shift;my ($node,$class,$loader)=@_;$loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE','ptr')unless exists$node->{&YAML::VALUE};return \$node->{&YAML::VALUE}}package YAML::Type::regexp;sub yaml_dump {die "YAML::Type::regexp::yaml_dump not currently implemented"}use constant _QR_TYPES=>{''=>sub {qr{$_[0]}},x=>sub {qr{$_[0]}x},i=>sub {qr{$_[0]}i},s=>sub {qr{$_[0]}s},m=>sub {qr{$_[0]}m},ix=>sub {qr{$_[0]}ix},sx=>sub {qr{$_[0]}sx},mx=>sub {qr{$_[0]}mx},si=>sub {qr{$_[0]}si},mi=>sub {qr{$_[0]}mi},ms=>sub {qr{$_[0]}sm},six=>sub {qr{$_[0]}six},mix=>sub {qr{$_[0]}mix},msx=>sub {qr{$_[0]}msx},msi=>sub {qr{$_[0]}msi},msix=>sub {qr{$_[0]}msix},};sub yaml_load {my$self=shift;my ($node,$class)=@_;return qr{$node} unless$node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;my ($flags,$re)=($1,$2);$flags =~ s/-.*//;$flags =~ s/^\^//;my$sub=_QR_TYPES->{$flags}|| sub {qr{$_[0]}};my$qr=&$sub($re);bless$qr,$class if length$class;return$qr}1;
YAML_TYPES

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;use strictures 1;use Moo::_Utils;sub moo {print <<'EOMOO';exit 0}BEGIN {my$package;sub import {moo()if $0 eq '-';$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;_load_module($package)}}use Filter::Simple sub {s/^/package $package;\nuse Moo;\n/}}1;
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
OO

$fatpacked{"strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES';
  package strictures;use strict;use warnings FATAL=>'all';BEGIN {*_PERL_LT_5_8_4=($] < 5.008004)? sub(){1}: sub(){0}}our$VERSION='1.005001';sub VERSION {for ($_[1]){last unless defined &&!ref && int!=1;die "Major version specified as $_ - this is strictures version 1"}no warnings 'uninitialized';shift->SUPER::VERSION(@_)}our$extra_load_states;our$Smells_Like_VCS=(-e '.git' || -e '.svn' || -e '.hg' || (-e '../../dist.ini' && (-e '../../.git' || -e '../../.svn' || -e '../../.hg')));sub import {strict->import;warnings->import(FATAL=>'all');my$extra_tests=do {if (exists$ENV{PERL_STRICTURES_EXTRA}){if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}){die 'PERL_STRICTURES_EXTRA checks are not available on perls older than 5.8.4: ' ."please unset \$ENV{PERL_STRICTURES_EXTRA}\n"}$ENV{PERL_STRICTURES_EXTRA}}elsif (!_PERL_LT_5_8_4){!!((caller)[1]=~ /^(?:t|xt|lib|blib)/ and $Smells_Like_VCS)}};if ($extra_tests){$extra_load_states ||=do {my (%rv,@failed);for my$mod (qw(indirect multidimensional bareword::filehandles)){eval "require $mod; \$rv{'$mod'} = 1;" or do {push@failed,$mod;(my$file=$mod)=~ s|::|/|g;delete$INC{"${file}.pm"}}}if (@failed){my$failed=join ' ',@failed;print STDERR <<EOE}\%rv};indirect->unimport(':fatal')if$extra_load_states->{indirect};multidimensional->unimport if$extra_load_states->{multidimensional};bareword::filehandles->unimport if$extra_load_states->{'bareword::filehandles'}}}1;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  EOE
STRICTURES

$fatpacked{"x86_64-linux/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CWD';
  package Cwd;use strict;use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);$VERSION='3.40';my$xs_version=$VERSION;$VERSION =~ tr/_//;@ISA=qw/Exporter/;@EXPORT=qw(cwd getcwd fastcwd fastgetcwd);push@EXPORT,qw(getdcwd) if $^O eq 'MSWin32';@EXPORT_OK=qw(chdir abs_path fast_abs_path realpath fast_realpath);if ($^O eq 'os2'){local $^W=0;*cwd=defined&sys_cwd ? \&sys_cwd : \&_os2_cwd;*getcwd=\&cwd;*fastgetcwd=\&cwd;*fastcwd=\&cwd;*fast_abs_path=\&sys_abspath if defined&sys_abspath;*abs_path=\&fast_abs_path;*realpath=\&fast_abs_path;*fast_realpath=\&fast_abs_path;return 1}my$use_vms_feature;BEGIN {if ($^O eq 'VMS'){if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_vms_feature=1}}}sub _vms_unix_rpt {my$unix_rpt;if ($use_vms_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _vms_efs {my$efs;if ($use_vms_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}eval {if ($] >= 5.006){require XSLoader;XSLoader::load(__PACKAGE__,$xs_version)}else {require DynaLoader;push@ISA,'DynaLoader';__PACKAGE__->bootstrap($xs_version)}};my%METHOD_MAP=(VMS=>{cwd=>'_vms_cwd',getcwd=>'_vms_cwd',fastcwd=>'_vms_cwd',fastgetcwd=>'_vms_cwd',abs_path=>'_vms_abs_path',fast_abs_path=>'_vms_abs_path',},MSWin32=>{cwd=>'_NT_cwd',getcwd=>'_NT_cwd',fastcwd=>'_NT_cwd',fastgetcwd=>'_NT_cwd',abs_path=>'fast_abs_path',realpath=>'fast_abs_path',},dos=>{cwd=>'_dos_cwd',getcwd=>'_dos_cwd',fastgetcwd=>'_dos_cwd',fastcwd=>'_dos_cwd',abs_path=>'fast_abs_path',},qnx=>{cwd=>'_qnx_cwd',getcwd=>'_qnx_cwd',fastgetcwd=>'_qnx_cwd',fastcwd=>'_qnx_cwd',abs_path=>'_qnx_abs_path',fast_abs_path=>'_qnx_abs_path',},cygwin=>{getcwd=>'cwd',fastgetcwd=>'cwd',fastcwd=>'cwd',abs_path=>'fast_abs_path',realpath=>'fast_abs_path',},epoc=>{cwd=>'_epoc_cwd',getcwd=>'_epoc_cwd',fastgetcwd=>'_epoc_cwd',fastcwd=>'_epoc_cwd',abs_path=>'fast_abs_path',},MacOS=>{getcwd=>'cwd',fastgetcwd=>'cwd',fastcwd=>'cwd',abs_path=>'fast_abs_path',},);$METHOD_MAP{NT}=$METHOD_MAP{MSWin32};my$pwd_cmd;for my$try ('/bin/pwd','/usr/bin/pwd','/QOpenSys/bin/pwd',){if(-x $try){$pwd_cmd=$try;last}}my$found_pwd_cmd=defined($pwd_cmd);unless ($pwd_cmd){$pwd_cmd='pwd'}sub _carp {require Carp;Carp::carp(@_)}sub _croak {require Carp;Carp::croak(@_)}sub _backtick_pwd {my@localize=grep exists$ENV{$_},qw(PATH IFS CDPATH ENV BASH_ENV);local@ENV{@localize};my$cwd=`$pwd_cmd`;local $/="\n";chomp($cwd)if defined$cwd;$cwd}unless ($METHOD_MAP{$^O}{cwd}or defined&cwd){my$sep=$Config::Config{path_sep}|| ':';my$os=$^O;if (defined$ENV{PATH}and $os ne 'MSWin32'){my@candidates=split($sep,$ENV{PATH});while (!$found_pwd_cmd and @candidates){my$candidate=shift@candidates;$found_pwd_cmd=1 if -x "$candidate/pwd"}}if($os eq 'MacOS' || $found_pwd_cmd){*cwd=\&_backtick_pwd}else {*cwd=\&getcwd}}if ($^O eq 'cygwin'){local $^W=0;my$orig_cwd=\&cwd;*cwd=sub {&$orig_cwd()}}*fastgetcwd=\&cwd;sub _perl_getcwd {abs_path('.')}sub fastcwd_ {my($odev,$oino,$cdev,$cino,$tdev,$tino);my(@path,$path);local(*DIR);my($orig_cdev,$orig_cino)=stat('.');($cdev,$cino)=($orig_cdev,$orig_cino);for (;;){my$direntry;($odev,$oino)=($cdev,$cino);CORE::chdir('..')|| return undef;($cdev,$cino)=stat('.');last if$odev==$cdev && $oino==$cino;opendir(DIR,'.')|| return undef;for (;;){$direntry=readdir(DIR);last unless defined$direntry;next if$direntry eq '.';next if$direntry eq '..';($tdev,$tino)=lstat($direntry);last unless$tdev!=$odev || $tino!=$oino}closedir(DIR);return undef unless defined$direntry;unshift(@path,$direntry)}$path='/' .join('/',@path);if ($^O eq 'apollo'){$path="/".$path}$path =~ /^(.*)\z/s && CORE::chdir($1)or return undef;($cdev,$cino)=stat('.');die "Unstable directory path, current directory changed unexpectedly" if$cdev!=$orig_cdev || $cino!=$orig_cino;$path}if (not defined&fastcwd){*fastcwd=\&fastcwd_}my$chdir_init=0;sub chdir_init {if ($ENV{'PWD'}and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32'){my($dd,$di)=stat('.');my($pd,$pi)=stat($ENV{'PWD'});if (!defined$dd or!defined$pd or $di!=$pi or $dd!=$pd){$ENV{'PWD'}=cwd()}}else {my$wd=cwd();$wd=Win32::GetFullPathName($wd)if $^O eq 'MSWin32';$ENV{'PWD'}=$wd}if ($^O ne 'MSWin32' and $ENV{'PWD'}=~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s){my($pd,$pi)=stat($2);my($dd,$di)=stat($1);if (defined$pd and defined$dd and $di==$pi and $dd==$pd){$ENV{'PWD'}="$2$3"}}$chdir_init=1}sub chdir {my$newdir=@_ ? shift : '';$newdir =~ s|///*|/|g unless $^O eq 'MSWin32';chdir_init()unless$chdir_init;my$newpwd;if ($^O eq 'MSWin32'){$newpwd=Win32::GetFullPathName($newdir)}return 0 unless CORE::chdir$newdir;if ($^O eq 'VMS'){return$ENV{'PWD'}=$ENV{'DEFAULT'}}elsif ($^O eq 'MacOS'){return$ENV{'PWD'}=cwd()}elsif ($^O eq 'MSWin32'){$ENV{'PWD'}=$newpwd;return 1}if (ref$newdir eq 'GLOB'){$ENV{'PWD'}=cwd()}elsif ($newdir =~ m#^/#s){$ENV{'PWD'}=$newdir}else {my@curdir=split(m#/#,$ENV{'PWD'});@curdir=('')unless@curdir;my$component;for$component (split(m#/#,$newdir)){next if$component eq '.';pop(@curdir),next if$component eq '..';push(@curdir,$component)}$ENV{'PWD'}=join('/',@curdir)|| '/'}1}sub _perl_abs_path {my$start=@_ ? shift : '.';my($dotdots,$cwd,@pst,@cst,$dir,@tst);unless (@cst=stat($start)){_carp("stat($start): $!");return ''}unless (-d _){my ($dir,$file)=$start =~ m{^(.*)/(.+)$} or return cwd().'/' .$start;if (-l $start){my$link_target=readlink($start);die "Can't resolve link $start: $!" unless defined$link_target;require File::Spec;$link_target=$dir .'/' .$link_target unless File::Spec->file_name_is_absolute($link_target);return abs_path($link_target)}return$dir ? abs_path($dir)."/$file" : "/$file"}$cwd='';$dotdots=$start;do {$dotdots .= '/..';@pst=@cst;local*PARENT;unless (opendir(PARENT,$dotdots)){require File::Spec;return File::Spec->rel2abs($start,_backtick_pwd())}unless (@cst=stat($dotdots)){_carp("stat($dotdots): $!");closedir(PARENT);return ''}if ($pst[0]==$cst[0]&& $pst[1]==$cst[1]){$dir=undef}else {do {unless (defined ($dir=readdir(PARENT))){_carp("readdir($dotdots): $!");closedir(PARENT);return ''}$tst[0]=$pst[0]+1 unless (@tst=lstat("$dotdots/$dir"))}while ($dir eq '.' || $dir eq '..' || $tst[0]!=$pst[0]|| $tst[1]!=$pst[1])}$cwd=(defined$dir ? "$dir" : "")."/$cwd" ;closedir(PARENT)}while (defined$dir);chop($cwd)unless$cwd eq '/';$cwd}my$Curdir;sub fast_abs_path {local$ENV{PWD}=$ENV{PWD}|| '';my$cwd=getcwd();require File::Spec;my$path=@_ ? shift : ($Curdir ||=File::Spec->curdir);($path)=$path =~ /(.*)/s;($cwd)=$cwd =~ /(.*)/s;unless (-e $path){_croak("$path: No such file or directory")}unless (-d _){my ($vol,$dir,$file)=File::Spec->splitpath($path);return File::Spec->catfile($cwd,$path)unless length$dir;if (-l $path){my$link_target=readlink($path);die "Can't resolve link $path: $!" unless defined$link_target;$link_target=File::Spec->catpath($vol,$dir,$link_target)unless File::Spec->file_name_is_absolute($link_target);return fast_abs_path($link_target)}return$dir eq File::Spec->rootdir ? File::Spec->catpath($vol,$dir,$file): fast_abs_path(File::Spec->catpath($vol,$dir,'')).'/' .$file}if (!CORE::chdir($path)){_croak("Cannot chdir to $path: $!")}my$realpath=getcwd();if (!((-d $cwd)&& (CORE::chdir($cwd)))){_croak("Cannot chdir back to $cwd: $!")}$realpath}*fast_realpath=\&fast_abs_path;sub _vms_cwd {return$ENV{'DEFAULT'}}sub _vms_abs_path {return$ENV{'DEFAULT'}unless @_;my$path=shift;my$efs=_vms_efs;my$unix_rpt=_vms_unix_rpt;if (defined&VMS::Filespec::vmsrealpath){my$path_unix=0;my$path_vms=0;$path_unix=1 if ($path =~ m#(?<=\^)/#);$path_unix=1 if ($path =~ /^\.\.?$/);$path_vms=1 if ($path =~ m#[\[<\]]#);$path_vms=1 if ($path =~ /^--?$/);my$unix_mode=$path_unix;if ($efs){if ($path_vms==$path_unix){$unix_mode=$unix_rpt}else {$unix_mode=0 if$path_vms}}if ($unix_mode){return VMS::Filespec::unixrealpath($path)}my$new_path=VMS::Filespec::vmsrealpath($path);$new_path=VMS::Filespec::pathify($new_path)if -d $path;return$new_path}if (-l $path){my$link_target=readlink($path);die "Can't resolve link $path: $!" unless defined$link_target;return _vms_abs_path($link_target)}my$pathified=VMS::Filespec::pathify($path);$path=$pathified if defined$pathified;return VMS::Filespec::rmsexpand($path)}sub _os2_cwd {$ENV{'PWD'}=`cmd /c cd`;chomp$ENV{'PWD'};$ENV{'PWD'}=~ s:\\:/:g ;return$ENV{'PWD'}}sub _win32_cwd_simple {$ENV{'PWD'}=`cd`;chomp$ENV{'PWD'};$ENV{'PWD'}=~ s:\\:/:g ;return$ENV{'PWD'}}sub _win32_cwd {if (*{$DynaLoader::{boot_DynaLoader}}{CODE}){$ENV{'PWD'}=Win32::GetCwd()}else {chomp($ENV{'PWD'}=`cd`)}$ENV{'PWD'}=~ s:\\:/:g ;return$ENV{'PWD'}}*_NT_cwd=defined&Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;sub _dos_cwd {if (!defined&Dos::GetCwd){$ENV{'PWD'}=`command /c cd`;chomp$ENV{'PWD'};$ENV{'PWD'}=~ s:\\:/:g }else {$ENV{'PWD'}=Dos::GetCwd()}return$ENV{'PWD'}}sub _qnx_cwd {local$ENV{PATH}='';local$ENV{CDPATH}='';local$ENV{ENV}='';$ENV{'PWD'}=`/usr/bin/fullpath -t`;chomp$ENV{'PWD'};return$ENV{'PWD'}}sub _qnx_abs_path {local$ENV{PATH}='';local$ENV{CDPATH}='';local$ENV{ENV}='';my$path=@_ ? shift : '.';local*REALPATH;defined(open(REALPATH,'-|')|| exec '/usr/bin/fullpath','-t',$path)or die "Can't open /usr/bin/fullpath: $!";my$realpath=<REALPATH>;close REALPATH;chomp$realpath;return$realpath}sub _epoc_cwd {$ENV{'PWD'}=EPOC::getcwd();return$ENV{'PWD'}}if (exists$METHOD_MAP{$^O}){my$map=$METHOD_MAP{$^O};for my$name (keys %$map){local $^W=0;no strict 'refs';*{$name}=\&{$map->{$name}}}}*abs_path=\&_perl_abs_path unless defined&abs_path;*getcwd=\&_perl_getcwd unless defined&getcwd;*realpath=\&abs_path;1;
X86_64-LINUX_CWD

$fatpacked{"x86_64-linux/Devel/GlobalDestruction/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DEVEL_GLOBALDESTRUCTION_XS';
  package Devel::GlobalDestruction::XS;use strict;use warnings;our$VERSION='0.01';require XSLoader;XSLoader::load(__PACKAGE__,$VERSION);1;
X86_64-LINUX_DEVEL_GLOBALDESTRUCTION_XS

$fatpacked{"x86_64-linux/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC';
  package File::Spec;use strict;use vars qw(@ISA $VERSION);$VERSION='3.40';$VERSION =~ tr/_//;my%module=(MacOS=>'Mac',MSWin32=>'Win32',os2=>'OS2',VMS=>'VMS',epoc=>'Epoc',NetWare=>'Win32',symbian=>'Win32',dos=>'OS2',cygwin=>'Cygwin');my$module=$module{$^O}|| 'Unix';require "File/Spec/$module.pm";@ISA=("File::Spec::$module");1;
X86_64-LINUX_FILE_SPEC

$fatpacked{"x86_64-linux/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);sub canonpath {my($self,$path)=@_;return unless defined$path;$path =~ s|\\|/|g;my$node='';if ($path =~ s@^(//[^/]+)(?:/|\z)@/@s){$node=$1}return$node .$self->SUPER::canonpath($path)}sub catdir {my$self=shift;return unless @_;if ($_[0]and ($_[0]eq '/' or $_[0]eq '\\')){shift;return$self->SUPER::catdir('',@_)}$self->SUPER::catdir(@_)}sub file_name_is_absolute {my ($self,$file)=@_;return 1 if$file =~ m{^([a-z]:)?[\\/]}is;return$self->SUPER::file_name_is_absolute($file)}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR},"/tmp",$ENV{'TMP'},$ENV{'TEMP'},'C:/temp')}sub case_tolerant {return 1 unless $^O eq 'cygwin' and defined&Cygwin::mount_flags;my$drive=shift;if (!$drive){my@flags=split(/,/,Cygwin::mount_flags('/cygwin'));my$prefix=pop(@flags);if (!$prefix || $prefix eq 'cygdrive'){$drive='/cygdrive/c'}elsif ($prefix eq '/'){$drive='/c'}else {$drive="$prefix/c"}}my$mntopts=Cygwin::mount_flags($drive);if ($mntopts and ($mntopts =~ /,managed/)){return 0}eval {require Win32API::File}or return 1;my$osFsType="\0"x256;my$osVolName="\0"x256;my$ouFsFlags=0;Win32API::File::GetVolumeInformation($drive,$osVolName,256,[],[],$ouFsFlags,$osFsType,256);if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()){return 0}else {return 1}}1;
X86_64-LINUX_FILE_SPEC_CYGWIN

$fatpacked{"x86_64-linux/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_EPOC';
  package File::Spec::Epoc;use strict;use vars qw($VERSION @ISA);$VERSION='3.40';$VERSION =~ tr/_//;require File::Spec::Unix;@ISA=qw(File::Spec::Unix);sub case_tolerant {return 1}sub canonpath {my ($self,$path)=@_;return unless defined$path;$path =~ s|/+|/|g;$path =~ s|(/\.)+/|/|g;$path =~ s|^(\./)+||s unless$path eq "./";$path =~ s|^/(\.\./)+|/|s;$path =~ s|/\Z(?!\n)|| unless$path eq "/";return$path}1;
X86_64-LINUX_FILE_SPEC_EPOC

$fatpacked{"x86_64-linux/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;use File::Spec;use strict;use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);$VERSION='3.40';$VERSION =~ tr/_//;require Exporter;@ISA=qw(Exporter);@EXPORT=qw(canonpath catdir catfile curdir rootdir updir no_upwards file_name_is_absolute path);@EXPORT_OK=qw(devnull tmpdir splitpath splitdir catpath abs2rel rel2abs case_tolerant);%EXPORT_TAGS=(ALL=>[@EXPORT_OK,@EXPORT ]);for my$meth (@EXPORT,@EXPORT_OK){my$sub=File::Spec->can($meth);no strict 'refs';*{$meth}=sub {&$sub('File::Spec',@_)}}1;
X86_64-LINUX_FILE_SPEC_FUNCTIONS

$fatpacked{"x86_64-linux/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_MAC';
  package File::Spec::Mac;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);my$macfiles;if ($^O eq 'MacOS'){$macfiles=eval {require Mac::Files}}sub case_tolerant {1}sub canonpath {my ($self,$path)=@_;return$path}sub catdir {my$self=shift;return '' unless @_;my@args=@_;my$first_arg;my$relative;if ($args[0]eq ''){shift@args;$relative=0;$first_arg=$self->rootdir}elsif ($args[0]=~ /^[^:]+:/){$relative=0;$first_arg=shift@args;$first_arg="$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/)}else {$relative=1;if ($args[0]=~ /^::+\Z(?!\n)/){$first_arg=':'}elsif ($args[0]eq ':'){$first_arg=shift@args}else {$first_arg=shift@args;$first_arg="$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/)}}my$result=$first_arg;while (@args){my$arg=shift@args;unless (($arg eq '')|| ($arg eq ':')){if ($arg =~ /^::+\Z(?!\n)/){my$updir_count=length($arg)- 1;while ((@args)&& ($args[0]=~ /^::+\Z(?!\n)/)){$arg=shift@args;$updir_count += (length($arg)- 1)}$arg=(':' x $updir_count)}else {$arg =~ s/^://s;$arg="$arg:" unless ($arg =~ /:\Z(?!\n)/)}$result .= $arg}}if (($relative)&& ($result !~ /^:/)){$result=":$result"}unless ($relative){$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/}return$result}sub catfile {my$self=shift;return '' unless @_;my$file=pop @_;return$file unless @_;my$dir=$self->catdir(@_);$file =~ s/^://s;return$dir.$file}sub curdir {return ":"}sub devnull {return "Dev:Null"}sub rootdir {return '' unless$macfiles;my$system=Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,&Mac::Files::kSystemFolderType);$system =~ s/:.*\Z(?!\n)/:/s;return$system}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR})}sub updir {return "::"}sub file_name_is_absolute {my ($self,$file)=@_;if ($file =~ /:/){return (!($file =~ m/^:/s))}elsif ($file eq ''){return 1 }else {return 0}}sub path {return unless exists$ENV{Commands};return split(/,/,$ENV{Commands})}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file);if ($nofile){($volume,$directory)=$path =~ m|^((?:[^:]+:)?)(.*)|s}else {$path =~ m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;$volume=$1;$directory=$2;$file=$3}$volume='' unless defined($volume);$directory=":$directory" if ($volume && $directory);if ($directory){$directory .= ':' unless (substr($directory,-1)eq ':');$directory=":$directory" unless (substr($directory,0,1)eq ':')}else {$directory=''}$file='' unless defined($file);return ($volume,$directory,$file)}sub splitdir {my ($self,$path)=@_;my@result=();my ($head,$sep,$tail,$volume,$directories);return@result if ((!defined($path))|| ($path eq ''));return (':')if ($path eq ':');($volume,$sep,$directories)=$path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;if ($volume){push (@result,$volume);$sep .= ':'}while ($sep || $directories){if (length($sep)> 1){my$updir_count=length($sep)- 1;for (my$i=0;$i<$updir_count;$i++){push (@result,'::')}}$sep='';if ($directories){($head,$sep,$tail)=$directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;push (@result,$head);$directories=$tail}}return@result}sub catpath {my ($self,$volume,$directory,$file)=@_;if ((!$volume)&& (!$directory)){$file =~ s/^:// if$file;return$file }my ($dir_volume,$dir_dirs)=$self->splitpath($directory,1);$volume=$dir_volume unless length$volume;my$path=$volume;$path .= ':' unless (substr($path,-1)eq ':');if ($directory){$directory=$dir_dirs if$volume;$directory =~ s/^://;$path .= $directory;$path .= ':' unless (substr($path,-1)eq ':')}if ($file){$file =~ s/^://;$path .= $file}return$path}sub _resolve_updirs {my$path=shift @_;my$proceed;do {$proceed=($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/)}while ($proceed);return$path}sub abs2rel {my($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){$path=$self->rel2abs($path)}if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base);$base=_resolve_updirs($base)}else {$base=_resolve_updirs($base)}my ($path_vol,$path_dirs,$path_file)=$self->splitpath($path);my ($base_vol,$base_dirs)=$self->splitpath($base);return$path unless lc($path_vol)eq lc($base_vol);my@pathchunks=$self->splitdir($path_dirs);my@basechunks=$self->splitdir($base_dirs);while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }$path_dirs=$self->catdir(':',@pathchunks);$base_dirs=(':' x @basechunks).':' ;return$self->catpath('',$self->catdir($base_dirs,$path_dirs),$path_file)}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}my ($path_dirs,$path_file)=($self->splitpath($path))[1,2];my ($base_vol,$base_dirs)=$self->splitpath($base);$path_dirs=':' if ($path_dirs eq '');$base_dirs =~ s/:$//;$base_dirs=$base_dirs .$path_dirs;$path=$self->catpath($base_vol,$base_dirs,$path_file)}return$path}1;
X86_64-LINUX_FILE_SPEC_MAC

$fatpacked{"x86_64-linux/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_OS2';
  package File::Spec::OS2;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);sub devnull {return "/dev/nul"}sub case_tolerant {return 1}sub file_name_is_absolute {my ($self,$file)=@_;return scalar($file =~ m{^([a-z]:)?[\\/]}is)}sub path {my$path=$ENV{PATH};$path =~ s:\\:/:g;my@path=split(';',$path);for (@path){$_='.' if $_ eq ''}return@path}sub _cwd {return Cwd::sys_cwd()}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;my@d=@ENV{qw(TMPDIR TEMP TMP)};$tmpdir=$_[0]->_tmpdir(@d,'/tmp','/')}sub catdir {my$self=shift;my@args=@_;for (@args){tr[\\][/];$_ .= "/" unless m{/$}}return$self->canonpath(join('',@args))}sub canonpath {my ($self,$path)=@_;return unless defined$path;$path =~ s/^([a-z]:)/\l$1/s;$path =~ s|\\|/|g;$path =~ s|([^/])/+|$1/|g;$path =~ s|(/\.)+/|/|g;$path =~ s|^(\./)+(?=[^/])||s;$path =~ s|/\Z(?!\n)|| unless$path =~ m#^([a-z]:)?/\Z(?!\n)#si;$path =~ s{^/\.\.$}{/};1 while$path =~ s{^/\.\.}{};return$path}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$path =~ m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;$volume=$1;$directory=$2}else {$path =~ m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;$volume=$1;$directory=$2;$file=$3}return ($volume,$directory,$file)}sub splitdir {my ($self,$directories)=@_ ;split m|[\\/]|,$directories,-1}sub catpath {my ($self,$volume,$directory,$file)=@_;$volume .= $1 if ($volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s && $directory =~ m@^[^\\/]@s);$volume .= $directory ;if ($volume !~ m@^[a-zA-Z]:\Z(?!\n)@s && $volume =~ m@[^\\/]\Z(?!\n)@ && $file =~ m@[^\\/]@){$volume =~ m@([\\/])@ ;my$sep=$1 ? $1 : '/' ;$volume .= $sep }$volume .= $file ;return$volume }sub abs2rel {my($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){$path=$self->rel2abs($path)}else {$path=$self->canonpath($path)}if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_volume,$path_directories,$path_file)=$self->splitpath($path,1);my ($base_volume,$base_directories)=$self->splitpath($base,1);return$path unless$path_volume eq $base_volume;my@pathchunks=$self->splitdir($path_directories);my@basechunks=$self->splitdir($base_directories);while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }$path_directories=CORE::join('/',@pathchunks);$base_directories=CORE::join('/',@basechunks);$base_directories =~ s|[^\\/]+|..|g ;if ($path_directories ne '' && $base_directories ne ''){$path_directories="$base_directories/$path_directories" }else {$path_directories="$base_directories$path_directories" }return$self->canonpath($self->catpath("",$path_directories,$path_file))}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path,1))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base,1);$path=$self->catpath($base_volume,$self->catdir($base_directories,$path_directories),$path_file)}return$self->canonpath($path)}1;
X86_64-LINUX_FILE_SPEC_OS2

$fatpacked{"x86_64-linux/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_UNIX';
  package File::Spec::Unix;use strict;use vars qw($VERSION);$VERSION='3.40';$VERSION =~ tr/_//;sub canonpath {my ($self,$path)=@_;return unless defined$path;my$node='';my$double_slashes_special=$^O eq 'qnx' || $^O eq 'nto';if ($double_slashes_special && ($path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s)){$node=$1}$path =~ s|/{2,}|/|g;$path =~ s{(?:/\.)+(?:/|\z)}{/}g;$path =~ s|^(?:\./)+||s unless$path eq "./";$path =~ s|^/(?:\.\./)+|/|;$path =~ s|^/\.\.$|/|;$path =~ s|/\z|| unless$path eq "/";return "$node$path"}sub catdir {my$self=shift;$self->canonpath(join('/',@_,''))}sub catfile {my$self=shift;my$file=$self->canonpath(pop @_);return$file unless @_;my$dir=$self->catdir(@_);$dir .= "/" unless substr($dir,-1)eq "/";return$dir.$file}sub curdir {'.'}sub devnull {'/dev/null'}sub rootdir {'/'}my$tmpdir;sub _tmpdir {return$tmpdir if defined$tmpdir;my$self=shift;my@dirlist=@_;{no strict 'refs';if (${"\cTAINT"}){require Scalar::Util;@dirlist=grep {!Scalar::Util::tainted($_)}@dirlist}elsif ($] < 5.007){@dirlist=grep {eval {eval('1'.substr $_,0,0)}}@dirlist}}for (@dirlist){next unless defined && -d && -w _;$tmpdir=$_;last}$tmpdir=$self->curdir unless defined$tmpdir;$tmpdir=defined$tmpdir && $self->canonpath($tmpdir);return$tmpdir}sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR},"/tmp")}sub updir {'..'}sub no_upwards {my$self=shift;return grep(!/^\.{1,2}\z/s,@_)}sub case_tolerant {0}sub file_name_is_absolute {my ($self,$file)=@_;return scalar($file =~ m:^/:s)}sub path {return ()unless exists$ENV{PATH};my@path=split(':',$ENV{PATH});for (@path){$_='.' if $_ eq ''}return@path}sub join {my$self=shift;return$self->catfile(@_)}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$directory=$path}else {$path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;$directory=$1;$file=$2}return ($volume,$directory,$file)}sub splitdir {return split m|/|,$_[1],-1}sub catpath {my ($self,$volume,$directory,$file)=@_;if ($directory ne '' && $file ne '' && substr($directory,-1)ne '/' && substr($file,0,1)ne '/'){$directory .= "/$file" }else {$directory .= $file }return$directory }sub abs2rel {my($self,$path,$base)=@_;$base=$self->_cwd()unless defined$base and length$base;($path,$base)=map$self->canonpath($_),$path,$base;my$path_directories;my$base_directories;if (grep$self->file_name_is_absolute($_),$path,$base){($path,$base)=map$self->rel2abs($_),$path,$base;my ($path_volume)=$self->splitpath($path,1);my ($base_volume)=$self->splitpath($base,1);return$path unless$path_volume eq $base_volume;$path_directories=($self->splitpath($path,1))[1];$base_directories=($self->splitpath($base,1))[1];if (!length($base_directories)and $self->file_name_is_absolute($base)){$base_directories=$self->rootdir}}else {my$wd=($self->splitpath($self->_cwd(),1))[1];$path_directories=$self->catdir($wd,$path);$base_directories=$self->catdir($wd,$base)}my@pathchunks=$self->splitdir($path_directories);my@basechunks=$self->splitdir($base_directories);if ($base_directories eq $self->rootdir){return$self->curdir if$path_directories eq $self->rootdir;shift@pathchunks;return$self->canonpath($self->catpath('',$self->catdir(@pathchunks),''))}my@common;while (@pathchunks && @basechunks && $self->_same($pathchunks[0],$basechunks[0])){push@common,shift@pathchunks ;shift@basechunks }return$self->curdir unless@pathchunks || @basechunks;my@reverse_base;while(defined(my$dir=shift@basechunks)){if($dir ne $self->updir){unshift@reverse_base,$self->updir;push@common,$dir}elsif(@common){if(@reverse_base && $reverse_base[0]eq $self->updir){shift@reverse_base;pop@common}else {unshift@reverse_base,pop@common}}}my$result_dirs=$self->catdir(@reverse_base,@pathchunks);return$self->canonpath($self->catpath('',$result_dirs,''))}sub _same {$_[1]eq $_[2]}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}$path=$self->catdir($base,$path)}return$self->canonpath($path)}sub _cwd {require Cwd;Cwd::getcwd()}sub _collapse {my($fs,$path)=@_;my$updir=$fs->updir;my$curdir=$fs->curdir;my($vol,$dirs,$file)=$fs->splitpath($path);my@dirs=$fs->splitdir($dirs);pop@dirs if@dirs && $dirs[-1]eq '';my@collapsed;for my$dir (@dirs){if($dir eq $updir and @collapsed and length$collapsed[-1]and $collapsed[-1]ne $updir and $collapsed[-1]ne $curdir){pop@collapsed}else {push@collapsed,$dir}}return$fs->catpath($vol,$fs->catdir(@collapsed),$file)}1;
X86_64-LINUX_FILE_SPEC_UNIX

$fatpacked{"x86_64-linux/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_VMS';
  package File::Spec::VMS;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);use File::Basename;use VMS::Filespec;my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub canonpath {my($self,$path)=@_;return undef unless defined$path;my$unix_rpt=$self->_unix_rpt;if ($path =~ m|/|){my$pathify=$path =~ m|/\Z(?!\n)|;$path=$self->SUPER::canonpath($path);return$path if$unix_rpt;$path=$pathify ? vmspath($path): vmsify($path)}$path =~ s/(?<!\^)</[/;$path =~ s/(?<!\^)>/]/;$path =~ s/(?<!\^)\]\[\./\.\]\[/g;$path =~ s/(?<!\^)\[000000\.\]\[/\[/g;$path =~ s/(?<!\^)\[000000\./\[/g;$path =~ s/(?<!\^)\.\]\[000000\]/\]/g;$path =~ s/(?<!\^)\.\]\[/\./g;1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);$path =~ s/(?<!\^)\[\.-/[-/;$path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;$path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;$path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;$path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;$path =~ s/(?<!\^)\[\]// unless$path eq '[]';return$unix_rpt ? unixify($path): $path}sub catdir {my$self=shift;my$dir=pop;my$unix_rpt=$self->_unix_rpt;my@dirs=grep {defined()&& length()}@_;my$rslt;if (@dirs){my$path=(@dirs==1 ? $dirs[0]: $self->catdir(@dirs));my ($spath,$sdir)=($path,$dir);$spath =~ s/\.dir\Z(?!\n)//i;$sdir =~ s/\.dir\Z(?!\n)//i;if ($unix_rpt){$spath=unixify($spath)unless$spath =~ m#/#;$sdir=unixify($sdir)unless$sdir =~ m#/#;return$self->SUPER::catdir($spath,$sdir)}$sdir=$self->eliminate_macros($sdir)unless$sdir =~ /^[\w\-]+\Z(?!\n)/s;$rslt=$self->fixpath($self->eliminate_macros($spath)."/$sdir",1);if ($spath =~ /^[\[<][^.\-]/s){$rslt =~ s/^[^\[<]+//s}}else {if (not defined$dir or not length$dir){$rslt=''}else {$rslt=$unix_rpt ? $dir : vmspath($dir)}}return$self->canonpath($rslt)}sub catfile {my$self=shift;my$tfile=pop();my$file=$self->canonpath($tfile);my@files=grep {defined()&& length()}@_;my$unix_rpt=$self->_unix_rpt;my$rslt;if (@files){my$path=(@files==1 ? $files[0]: $self->catdir(@files));my$spath=$path;$spath =~ s/\.dir\Z(?!\n)//i;if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file)eq $file){$rslt="$spath$file"}else {$rslt=$self->eliminate_macros($spath);$rslt .= (defined($rslt)&& length($rslt)? '/' : '').unixify($file);$rslt=vmsify($rslt)unless$unix_rpt}}else {my$xfile=(defined($file)&& length($file))? $file : '';$rslt=$unix_rpt ? $file : vmsify($file)}return$self->canonpath($rslt)unless$unix_rpt;return$rslt}sub curdir {my$self=shift @_;return '.' if ($self->_unix_rpt);return '[]'}sub devnull {my$self=shift @_;return '/dev/null' if ($self->_unix_rpt);return "_NLA0:"}sub rootdir {my$self=shift @_;if ($self->_unix_rpt){my$try='/';my ($dev1,$ino1)=stat('/');my ($dev2,$ino2)=stat('.');if (($dev1!=$dev2)|| ($ino1!=$ino2)){return$try}return '/sys$disk/'}return 'SYS$DISK:[000000]'}my$tmpdir;sub tmpdir {my$self=shift @_;return$tmpdir if defined$tmpdir;if ($self->_unix_rpt){$tmpdir=$self->_tmpdir('/tmp','/sys$scratch',$ENV{TMPDIR});return$tmpdir}$tmpdir=$self->_tmpdir('sys$scratch:',$ENV{TMPDIR})}sub updir {my$self=shift @_;return '..' if ($self->_unix_rpt);return '[-]'}sub case_tolerant {return 1}sub path {my (@dirs,$dir,$i);while ($dir=$ENV{'DCL$PATH;' .$i++}){push(@dirs,$dir)}return@dirs}sub file_name_is_absolute {my ($self,$file)=@_;$file=$ENV{$file}while$file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};return scalar($file =~ m!^/!s || $file =~ m![<\[][^.\-\]>]! || $file =~ /:[^<\[]/)}sub splitpath {my($self,$path,$nofile)=@_;my($dev,$dir,$file)=('','','');my$vmsify_path=vmsify($path);if ($nofile){if($vmsify_path =~ /(.*)\](.+)/){$vmsify_path=$1.'.'.$2.']'}$vmsify_path =~ /(.+:)?(.*)/s;$dir=defined $2 ? $2 : '';return ($1 || '',$dir,$file)}else {$vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;return ($1 || '',$2 || '',$3)}}sub splitdir {my($self,$dirspec)=@_;my@dirs=();return@dirs if ((!defined$dirspec)|| ('' eq $dirspec));$dirspec =~ s/(?<!\^)</[/;$dirspec =~ s/(?<!\^)>/]/;$dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;$dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;$dirspec =~ s/(?<!\^)\[000000\./\[/g;$dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;$dirspec =~ s/(?<!\^)\.\]\[/\./g;while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g){}$dirspec="[$dirspec]" unless$dirspec =~ /(?<!\^)[\[<]/;$dirspec =~ s/^(\[|<)\./$1/;@dirs=split /(?<!\^)\./,vmspath($dirspec);$dirs[0]=~ s/^[\[<]//s;$dirs[-1]=~ s/[\]>]\Z(?!\n)//s;@dirs}sub catpath {my($self,$dev,$dir,$file)=@_;my ($dir_volume,$dir_dir,$dir_file)=$self->splitpath($dir);$dev=$dir_volume unless length$dev;$dir=length$dir_file ? $self->catfile($dir_dir,$dir_file): $dir_dir;if ($dev =~ m|^(?<!\^)/+([^/]+)|){$dev="$1:"}else {$dev .= ':' unless$dev eq '' or $dev =~ /:\Z(?!\n)/}if (length($dev)or length($dir)){$dir="[$dir]" unless$dir =~ /(?<!\^)[\[<\/]/;$dir=vmspath($dir)}$dir='' if length($dev)&& ($dir eq '[]' || $dir eq '<>');"$dev$dir$file"}sub abs2rel {my$self=shift;return vmspath(File::Spec::Unix::abs2rel($self,@_))if grep m{/},@_;my($path,$base)=@_;$base=$self->_cwd()unless defined$base and length$base;for ($path,$base){$_=$self->canonpath($_)}my ($path_volume,$path_directories,$path_file)=$self->splitpath($path);my ($base_volume,$base_directories,$base_file)=$self->splitpath($base);return$path unless lc($path_volume)eq lc($base_volume);for ($path,$base){$_=$self->rel2abs($_)}my@pathchunks=$self->splitdir($path_directories);my$pathchunks=@pathchunks;unshift(@pathchunks,'000000')unless$pathchunks[0]eq '000000';my@basechunks=$self->splitdir($base_directories);my$basechunks=@basechunks;unshift(@basechunks,'000000')unless$basechunks[0]eq '000000';while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }if ((@basechunks > 0)|| ($basechunks!=$pathchunks)){$path_directories=join '.',('-' x @basechunks,@pathchunks)}else {$path_directories=join '.',@pathchunks}$path_directories='['.$path_directories.']';return$self->canonpath($self->catpath('',$path_directories,$path_file))}sub rel2abs {my$self=shift ;my ($path,$base)=@_;return undef unless defined$path;if ($path =~ m/\//){$path=(-d $path || $path =~ m/\/\z/ ? vmspath($path): vmsify($path))}$base=vmspath($base)if defined$base && $base =~ m/\//;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base);$path_directories='' if$path_directories eq '[]' || $path_directories eq '<>';my$sep='' ;$sep='.' if ($base_directories =~ m{[^.\]>]\Z(?!\n)} && $path_directories =~ m{^[^.\[<]}s);$base_directories="$base_directories$sep$path_directories";$base_directories =~ s{\.?[\]>][\[<]\.?}{.};$path=$self->catpath($base_volume,$base_directories,$path_file)}return$self->canonpath($path)}sub eliminate_macros {my($self,$path)=@_;return '' unless (defined$path)&& ($path ne '');$self={}unless ref$self;if ($path =~ /\s/){return join ' ',map {$self->eliminate_macros($_)}split /\s+/,$path}my$npath=unixify($path);$npath =~ s{\0$}{};my($complex)=0;my($head,$macro,$tail);while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs){if (defined$self->{$2}){($head,$macro,$tail)=($1,$2,$3);if (ref$self->{$macro}){if (ref$self->{$macro}eq 'ARRAY'){$macro=join ' ',@{$self->{$macro}}}else {print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),"\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";$macro="\cB$macro\cB";$complex=1}}else {($macro=unixify($self->{$macro}))=~ s#/\Z(?!\n)##}$npath="$head$macro$tail"}}if ($complex){$npath =~ s#\cB(.*?)\cB#\${$1}#gs}$npath}sub fixpath {my($self,$path,$force_path)=@_;return '' unless$path;$self=bless {},$self unless ref$self;my($fixedpath,$prefix,$name);if ($path =~ /\s/){return join ' ',map {$self->fixpath($_,$force_path)}split /\s+/,$path}if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#){if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/){$fixedpath=vmspath($self->eliminate_macros($path))}else {$fixedpath=vmsify($self->eliminate_macros($path))}}elsif ((($prefix,$name)=($path =~ m#^\$\(([^\)]+)\)(.+)#s))&& $self->{$prefix}){my($vmspre)=$self->eliminate_macros("\$($prefix)");$vmspre=($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/)? vmspath($vmspre): '';$fixedpath=($vmspre ? $vmspre : $self->{$prefix}).$name;$fixedpath=vmspath($fixedpath)if$force_path}else {$fixedpath=$path;$fixedpath=vmspath($fixedpath)if$force_path}if (!defined($force_path)and $fixedpath !~ /[:>(.\]]/){$fixedpath=vmspath($fixedpath)if -d $fixedpath}$fixedpath =~ s/\.000000([\]>])/$1/;if ($path =~ /^[\[>][^.\-]/){$fixedpath =~ s/^[^\[<]+//}$fixedpath}1;
X86_64-LINUX_FILE_SPEC_VMS

$fatpacked{"x86_64-linux/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_WIN32';
  package File::Spec::Win32;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);my$DRIVE_RX='[a-zA-Z]:';my$UNC_RX='(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';my$VOL_RX="(?:$DRIVE_RX|$UNC_RX)";sub devnull {return "nul"}sub rootdir {'\\'}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir(map($ENV{$_},qw(TMPDIR TEMP TMP)),'SYS:/temp','C:\system\temp','C:/temp','/tmp','/')}sub case_tolerant {eval {require Win32API::File}or return 1;my$drive=shift || "C:";my$osFsType="\0"x256;my$osVolName="\0"x256;my$ouFsFlags=0;Win32API::File::GetVolumeInformation($drive,$osVolName,256,[],[],$ouFsFlags,$osFsType,256);if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()){return 0}else {return 1}}sub file_name_is_absolute {my ($self,$file)=@_;if ($file =~ m{^($VOL_RX)}o){my$vol=$1;return ($vol =~ m{^$UNC_RX}o ? 2 : $file =~ m{^$DRIVE_RX[\\/]}o ? 2 : 0)}return$file =~ m{^[\\/]} ? 1 : 0}sub catfile {shift;shift,return _canon_cat("/",@_)if $_[0]eq "";return _canon_cat(($_[0].'\\'),@_[1..$#_])if $_[0]=~ m{^$DRIVE_RX\z}o;return _canon_cat(@_)}sub catdir {shift;return "" unless @_;shift,return _canon_cat("/",@_)if $_[0]eq "";return _canon_cat(($_[0].'\\'),@_[1..$#_])if $_[0]=~ m{^$DRIVE_RX\z}o;return _canon_cat(@_)}sub path {my@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path;unshift(@path,".");return@path}sub canonpath {return $_[1]if!defined($_[1])or $_[1]eq '';return _canon_cat($_[1])}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$path =~ m{^ ( $VOL_RX ? ) (.*) }sox;$volume=$1;$directory=$2}else {$path =~ m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;$volume=$1;$directory=$2;$file=$3}return ($volume,$directory,$file)}sub splitdir {my ($self,$directories)=@_ ;if ($directories !~ m|[\\/]\Z(?!\n)|){return split(m|[\\/]|,$directories)}else {my(@directories)=split(m|[\\/]|,"${directories}dummy");$directories[$#directories ]='' ;return@directories }}sub catpath {my ($self,$volume,$directory,$file)=@_;my$v;$volume .= $v if ((($v)=$volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s)&& $directory =~ m@^[^\\/]@s);$volume .= $directory ;if ($volume !~ m@^[a-zA-Z]:\Z(?!\n)@s && $volume =~ m@[^\\/]\Z(?!\n)@ && $file =~ m@[^\\/]@){$volume =~ m@([\\/])@ ;my$sep=$1 ? $1 : '\\' ;$volume .= $sep }$volume .= $file ;return$volume }sub _same {lc($_[1])eq lc($_[2])}sub rel2abs {my ($self,$path,$base)=@_;my$is_abs=$self->file_name_is_absolute($path);return$self->canonpath($path)if$is_abs==2;if ($is_abs){my$vol=($self->splitpath($self->_cwd()))[0];return$self->canonpath($vol .$path)}if (!defined($base)|| $base eq ''){require Cwd ;$base=Cwd::getdcwd(($self->splitpath($path))[0])if defined&Cwd::getdcwd ;$base=$self->_cwd()unless defined$base }elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path,1))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base,1);$path=$self->catpath($base_volume,$self->catdir($base_directories,$path_directories),$path_file);return$self->canonpath($path)}sub _canon_cat {my ($first,@rest)=@_;my$volume=$first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x ? ucfirst($1).($2 ? "\\" : ""): $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs ? "\\\\$1".(defined $2 ? "\\$2" : "")."\\" : $first =~ s{ \A [\\/] }{}x ? "\\" : "";my$path=join "\\",$first,@rest;$path =~ tr#\\/#\\\\#s;$path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;$path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;while ($path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx){}$path =~ s#\A\\##;$path =~ s#\\\z##;if ($volume =~ m#\\\z#){$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;return $1 if$path eq "" and $volume =~ m#\A(\\\\.*)\\\z#s}return$path ne "" || $volume ? $volume.$path : "."}1;
X86_64-LINUX_FILE_SPEC_WIN32

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  package List::Util;use strict;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(all any first min max minstr maxstr none notall product reduce sum sum0 shuffle pairmap pairgrep pairfirst pairs pairkeys pairvalues);our$VERSION="1.35";our$XS_VERSION=$VERSION;$VERSION=eval$VERSION;require XSLoader;XSLoader::load('List::Util',$XS_VERSION);sub import {my$pkg=caller;no strict 'refs';${"${pkg}::a"}=${"${pkg}::a"};${"${pkg}::b"}=${"${pkg}::b"};goto&Exporter::import}1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;use strict;use List::Util;our$VERSION="1.35";$VERSION=eval$VERSION;1;
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  package Scalar::Util;use strict;require Exporter;require List::Util;our@ISA=qw(Exporter);our@EXPORT_OK=qw(blessed dualvar isdual isvstring isweak looks_like_number openhandle readonly refaddr reftype set_prototype tainted weaken);our$VERSION="1.35";$VERSION=eval$VERSION;our@EXPORT_FAIL;unless (defined&weaken){push@EXPORT_FAIL,qw(weaken)}unless (defined&isweak){push@EXPORT_FAIL,qw(isweak isvstring)}unless (defined&isvstring){push@EXPORT_FAIL,qw(isvstring)}sub export_fail {if (grep {/^(?:weaken|isweak)$/}@_){require Carp;Carp::croak("Weak references are not implemented in the version of perl")}if (grep {/^isvstring$/}@_){require Carp;Carp::croak("Vstrings are not implemented in the version of perl")}@_}1;
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_NAME';
  package Sub::Name;use 5.006;use strict;use warnings;our$VERSION='0.05';use base 'Exporter';use base 'DynaLoader';our@EXPORT=qw(subname);our@EXPORT_OK=@EXPORT;bootstrap Sub::Name$VERSION;1;
X86_64-LINUX_SUB_NAME

$fatpacked{"x86_64-linux/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION';
  package version;use 5.005_04;use strict;use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);$VERSION=0.9904;$CLASS='version';my$FRACTION_PART=qr/\.[0-9]+/;my$STRICT_INTEGER_PART=qr/0|[1-9][0-9]*/;my$LAX_INTEGER_PART=qr/[0-9]+/;my$STRICT_DOTTED_DECIMAL_PART=qr/\.[0-9]{1,3}/;my$LAX_DOTTED_DECIMAL_PART=qr/\.[0-9]+/;my$LAX_ALPHA_PART=qr/_[0-9]+/;my$STRICT_DECIMAL_VERSION=qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;my$STRICT_DOTTED_DECIMAL_VERSION=qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;$STRICT=qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;my$LAX_DECIMAL_VERSION=qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;my$LAX_DOTTED_DECIMAL_VERSION=qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;$LAX=qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;{local$SIG{'__DIE__'};eval "use version::vxs $VERSION";if ($@){eval "use version::vpp $VERSION";die "$@" if ($@);push@ISA,"version::vpp";local $^W;*version::qv=\&version::vpp::qv;*version::declare=\&version::vpp::declare;*version::_VERSION=\&version::vpp::_VERSION;*version::vcmp=\&version::vpp::vcmp;*version::new=\&version::vpp::new;if ($] >= 5.009000){no strict 'refs';*version::stringify=\&version::vpp::stringify;*{'version::(""'}=\&version::vpp::stringify;*{'version::(<=>'}=\&version::vpp::vcmp;*version::parse=\&version::vpp::parse}}else {push@ISA,"version::vxs";local $^W;*version::declare=\&version::vxs::declare;*version::qv=\&version::vxs::qv;*version::_VERSION=\&version::vxs::_VERSION;*version::vcmp=\&version::vxs::VCMP;*version::new=\&version::vxs::new;if ($] >= 5.009000){no strict 'refs';*version::stringify=\&version::vxs::stringify;*{'version::(""'}=\&version::vxs::stringify;*{'version::(<=>'}=\&version::vxs::VCMP;*version::parse=\&version::vxs::parse}}}sub import {no strict 'refs';my ($class)=shift;unless ($class eq 'version'){local $^W;*{$class.'::declare'}=\&version::declare;*{$class.'::qv'}=\&version::qv}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){local $^W;*UNIVERSAL::VERSION =\&version::_VERSION}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&version::_VERSION}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&version::is_strict unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&version::is_lax unless defined(&{$callpkg.'::is_lax'})}}sub is_strict {defined $_[0]&& $_[0]=~ qr/ \A $STRICT \z /x}sub is_lax {defined $_[0]&& $_[0]=~ qr/ \A $LAX \z /x}1;
X86_64-LINUX_VERSION

$fatpacked{"x86_64-linux/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VPP';
  package charstar;use overload ('""'=>\&thischar,'0+'=>\&thischar,'++'=>\&increment,'--'=>\&decrement,'+'=>\&plus,'-'=>\&minus,'*'=>\&multiply,'cmp'=>\&cmp,'<=>'=>\&spaceship,'bool'=>\&thischar,'='=>\&clone,);sub new {my ($self,$string)=@_;my$class=ref($self)|| $self;my$obj={string=>[split(//,$string)],current=>0,};return bless$obj,$class}sub thischar {my ($self)=@_;my$last=$#{$self->{string}};my$curr=$self->{current};if ($curr >= 0 && $curr <= $last){return$self->{string}->[$curr]}else {return ''}}sub increment {my ($self)=@_;$self->{current}++}sub decrement {my ($self)=@_;$self->{current}--}sub plus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}+= $offset;return$rself}sub minus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}-= $offset;return$rself}sub multiply {my ($left,$right,$swapped)=@_;my$char=$left->thischar();return$char * $right}sub spaceship {my ($left,$right,$swapped)=@_;unless (ref($right)){$right=$left->new($right)}return$left->{current}<=> $right->{current}}sub cmp {my ($left,$right,$swapped)=@_;unless (ref($right)){if (length($right)==1){return$left->thischar cmp $right}$right=$left->new($right)}return$left->currstr cmp $right->currstr}sub bool {my ($self)=@_;my$char=$self->thischar;return ($char ne '')}sub clone {my ($left,$right,$swapped)=@_;$right={string=>[@{$left->{string}}],current=>$left->{current},};return bless$right,ref($left)}sub currstr {my ($self,$s)=@_;my$curr=$self->{current};my$last=$#{$self->{string}};if (defined($s)&& $s->{current}< $last){$last=$s->{current}}my$string=join('',@{$self->{string}}[$curr..$last]);return$string}package version::vpp;use strict;use POSIX qw/locale_h/;use locale;use vars qw ($VERSION @ISA @REGEXS);$VERSION=0.9904;use overload ('""'=>\&stringify,'0+'=>\&numify,'cmp'=>\&vcmp,'<=>'=>\&vcmp,'bool'=>\&vbool,'+'=>\&vnoop,'-'=>\&vnoop,'*'=>\&vnoop,'/'=>\&vnoop,'+='=>\&vnoop,'-='=>\&vnoop,'*='=>\&vnoop,'/='=>\&vnoop,'abs'=>\&vnoop,);eval "use warnings";if ($@){eval '
  	package
  	warnings;
  	sub enabled {return $^W;}
  	1;
      '}my$VERSION_MAX=0x7FFFFFFF;use constant TRUE=>1;use constant FALSE=>0;sub isDIGIT {my ($char)=shift->thischar();return ($char =~ /\d/)}sub isALPHA {my ($char)=shift->thischar();return ($char =~ /[a-zA-Z]/)}sub isSPACE {my ($char)=shift->thischar();return ($char =~ /\s/)}sub BADVERSION {my ($s,$errstr,$error)=@_;if ($errstr){$$errstr=$error}return$s}sub prescan_version {my ($s,$strict,$errstr,$sqv,$ssaw_decimal,$swidth,$salpha)=@_;my$qv=defined$sqv ? $$sqv : FALSE;my$saw_decimal=defined$ssaw_decimal ? $$ssaw_decimal : 0;my$width=defined$swidth ? $$swidth : 3;my$alpha=defined$salpha ? $$salpha : FALSE;my$d=$s;if ($qv && isDIGIT($d)){goto dotted_decimal_version}if ($d eq 'v'){$d++;if (isDIGIT($d)){$qv=TRUE}else {return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}dotted_decimal_version: if ($strict && $d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}else {if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}else {goto version_prescan_finish}}{my$i=0;my$j=0;while (isDIGIT($d)){$i++;while (isDIGIT($d)){$d++;$j++;if ($strict && $j > 3){return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)")}}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}$d++;$alpha=TRUE}elsif ($d eq '.'){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}$saw_decimal++;$d++}elsif (!isDIGIT($d)){last}$j=0}if ($strict && $i < 2){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}}}else {my$j=0;if ($strict){if ($d eq '.'){return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)")}if ($d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}}if ($d eq '-'){return BADVERSION($s,$errstr,"Invalid version format (negative version number)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}elsif (!$d || $d eq ';' || isSPACE($d)|| $d eq '}'){if ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (version required)")}goto version_prescan_finish}elsif ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}elsif ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}elsif (isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)")}else {return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}}elsif ($d){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($d &&!isDIGIT($d)&& ($strict ||!($d eq ';' || isSPACE($d)|| $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (fractional part required)")}while (isDIGIT($d)){$d++;$j++;if ($d eq '.' && isDIGIT($d-1)){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')")}$d=$s;$qv=TRUE;goto dotted_decimal_version}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}if (!isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}$width=$j;$d++;$alpha=TRUE}}}version_prescan_finish: while (isSPACE($d)){$d++}if ($d &&!isDIGIT($d)&& (!($d eq ';' || $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if (defined$sqv){$$sqv=$qv}if (defined$swidth){$$swidth=$width}if (defined$ssaw_decimal){$$ssaw_decimal=$saw_decimal}if (defined$salpha){$$salpha=$alpha}return$d}sub scan_version {my ($s,$rv,$qv)=@_;my$start;my$pos;my$last;my$errstr;my$saw_decimal=0;my$width=3;my$alpha=FALSE;my$vinf=FALSE;my@av;$s=new charstar$s;while (isSPACE($s)){$s++}$last=prescan_version($s,FALSE,\$errstr,\$qv,\$saw_decimal,\$width,\$alpha);if ($errstr){if ($s ne 'undef'){use Carp;Carp::croak($errstr)}}$start=$s;if ($s eq 'v'){$s++}$pos=$s;if ($qv){$$rv->{qv}=$qv}if ($alpha){$$rv->{alpha}=$alpha}if (!$qv && $width < 3){$$rv->{width}=$width}while (isDIGIT($pos)){$pos++}if (!isALPHA($pos)){my$rev;for (;;){$rev=0;{my$end=$pos;my$mult=1;my$orev;if (!$qv && $s > $start && $saw_decimal==1){$mult *= 100;while ($s < $end){$orev=$rev;$rev += $s * $mult;$mult /= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version %d",$VERSION_MAX);$s=$end - 1;$rev=$VERSION_MAX;$vinf=1}$s++;if ($s eq '_'){$s++}}}else {while (--$end >= $s){$orev=$rev;$rev += $end * $mult;$mult *= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version");$end=$s - 1;$rev=$VERSION_MAX;$vinf=1}}}}push@av,$rev;if ($vinf){$s=$last;last}elsif ($pos eq '.'){$s=++$pos}elsif ($pos eq '_' && isDIGIT($pos+1)){$s=++$pos}elsif ($pos eq ',' && isDIGIT($pos+1)){$s=++$pos}elsif (isDIGIT($pos)){$s=$pos}else {$s=$pos;last}if ($qv){while (isDIGIT($pos)){$pos++}}else {my$digits=0;while ((isDIGIT($pos)|| $pos eq '_')&& $digits < 3){if ($pos ne '_'){$digits++}$pos++}}}}if ($qv){my$len=$#av;$len=2 - $len;while ($len-- > 0){push@av,0}}if ($vinf){$$rv->{original}="v.Inf";$$rv->{vinf}=1}elsif ($s > $start){$$rv->{original}=$start->currstr($s);if ($qv && $saw_decimal==1 && $start ne 'v'){$$rv->{original}='v' .$$rv->{original}}}else {$$rv->{original}='0';push(@av,0)}$$rv->{version}=\@av;if ($s eq 'undef'){$s += 5}return$s}sub new {my ($class,$value)=@_;unless (defined$class){require Carp;Carp::croak('Usage: version::new(class, version)')}my$self=bless ({},ref ($class)|| $class);my$qv=FALSE;if (ref($value)&& eval('$value->isa("version")')){$self->{version}=[@{$value->{version}}];$self->{qv}=1 if$value->{qv};$self->{alpha}=1 if$value->{alpha};$self->{original}=''.$value->{original};return$self}my$currlocale=setlocale(LC_ALL);if (localeconv()->{decimal_point}eq ','){$value =~ tr/,/./}if (not defined$value or $value =~ /^undef$/){push @{$self->{version}},0;$self->{original}="0";return ($self)}if ($#_==2){$value=$_[2];$qv=TRUE}$value=_un_vstring($value);if ($value =~ /\d+.?\d*e[-+]?\d+/){$value=sprintf("%.9f",$value);$value =~ s/(0+)$//}my$s=scan_version($value,\$self,$qv);if ($s){warn("Version string '%s' contains invalid data; " ."ignoring: '%s'",$value,$s)}return ($self)}*parse=\&new;sub numify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$width=$self->{width}|| 3;my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("%d.",$digit);for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];if ($width < 3){my$denom=10**(3-$width);my$quot=int($digit/$denom);my$rem=$digit - ($quot * $denom);$string .= sprintf("%0".$width."d_%d",$quot,$rem)}else {$string .= sprintf("%03d",$digit)}}if ($len > 0){$digit=$self->{version}[$len];if ($alpha && $width==3){$string .= "_"}$string .= sprintf("%0".$width."d",$digit)}else {$string .= sprintf("000")}return$string}sub normal {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("v%d",$digit);for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];$string .= sprintf(".%d",$digit)}if ($len > 0){$digit=$self->{version}[$len];if ($alpha){$string .= sprintf("_%0d",$digit)}else {$string .= sprintf(".%0d",$digit)}}if ($len <= 2){for ($len=2 - $len;$len!=0;$len-- ){$string .= sprintf(".%0d",0)}}return$string}sub stringify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}return exists$self->{original}? $self->{original}: exists$self->{qv}? $self->normal : $self->numify}sub vcmp {require UNIVERSAL;my ($left,$right,$swap)=@_;my$class=ref($left);unless (UNIVERSAL::isa($right,$class)){$right=$class->new($right)}if ($swap){($left,$right)=($right,$left)}unless (_verify($left)){require Carp;Carp::croak("Invalid version object")}unless (_verify($right)){require Carp;Carp::croak("Invalid version format")}my$l=$#{$left->{version}};my$r=$#{$right->{version}};my$m=$l < $r ? $l : $r;my$lalpha=$left->is_alpha;my$ralpha=$right->is_alpha;my$retval=0;my$i=0;while ($i <= $m && $retval==0){$retval=$left->{version}[$i]<=> $right->{version}[$i];$i++}if ($retval==0 && $l==$r && $left->{version}[$m]==$right->{version}[$m]&& ($lalpha || $ralpha)){if ($lalpha &&!$ralpha){$retval=-1}elsif ($ralpha &&!$lalpha){$retval=+1}}if ($retval==0 && $l!=$r){if ($l < $r){while ($i <= $r && $retval==0){if ($right->{version}[$i]!=0){$retval=-1}$i++}}else {while ($i <= $l && $retval==0){if ($left->{version}[$i]!=0){$retval=+1}$i++}}}return$retval}sub vbool {my ($self)=@_;return vcmp($self,$self->new("0"),1)}sub vnoop {require Carp;Carp::croak("operation not supported with version object")}sub is_alpha {my ($self)=@_;return (exists$self->{alpha})}sub qv {my$value=shift;my$class='version';if (@_){$class=ref($value)|| $value;$value=shift}$value=_un_vstring($value);$value='v'.$value unless$value =~ /(^v|\d+\.\d+\.\d)/;my$obj=version->new($value);return bless$obj,$class}*declare=\&qv;sub is_qv {my ($self)=@_;return (exists$self->{qv})}sub _verify {my ($self)=@_;if (ref($self)&& eval {exists$self->{version}}&& ref($self->{version})eq 'ARRAY'){return 1}else {return 0}}sub _is_non_alphanumeric {my$s=shift;$s=new charstar$s;while ($s){return 0 if isSPACE($s);return 1 unless (isALPHA($s)|| isDIGIT($s)|| $s =~ /[.-]/);$s++}return 0}sub _un_vstring {my$value=shift;if (length($value)>= 3 && $value !~ /[._]/ && _is_non_alphanumeric($value)){my$tvalue;if ($] ge 5.008_001){$tvalue=_find_magic_vstring($value);$value=$tvalue if length$tvalue}elsif ($] ge 5.006_000){$tvalue=sprintf("v%vd",$value);if ($tvalue =~ /^v\d+(\.\d+){2,}$/){$value=$tvalue}}}return$value}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub _VERSION {my ($obj,$req)=@_;my$class=ref($obj)|| $obj;no strict 'refs';if (exists$INC{"$class.pm"}and not %{"$class\::"}and $] >= 5.008){require Carp;Carp::croak("$class defines neither package nor VERSION" ."--version check failed")}my$version=eval "\$$class\::VERSION";if (defined$version){local $^W if $] <= 5.008;$version=version::vpp->new($version)}if (defined$req){unless (defined$version){require Carp;my$msg=$] < 5.006 ? "$class version $req required--this is only version " : "$class does not define \$$class\::VERSION" ."--version check failed";if ($ENV{VERSION_DEBUG}){Carp::confess($msg)}else {Carp::croak($msg)}}$req=version::vpp->new($req);if ($req > $version){require Carp;if ($req->is_qv){Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->normal,$version->normal))}else {Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->stringify,$version->stringify))}}}return defined$version ? $version->stringify : undef}1;
X86_64-LINUX_VERSION_VPP

$fatpacked{"x86_64-linux/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VXS';
  package version::vxs;use 5.005_03;use strict;use vars qw(@ISA $VERSION $CLASS);$VERSION=0.9904;$CLASS='version::vxs';eval {require XSLoader;local $^W;XSLoader::load('version::vxs',$VERSION);1}or do {require DynaLoader;push@ISA,'DynaLoader';local $^W;bootstrap version::vxs$VERSION};1;
X86_64-LINUX_VERSION_VXS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE



use strict;
use warnings;
$|++;

use App::Task::Base;
use App::Task::Command::Start;
use App::Task::Command::Ready;
use App::Task::Command::Deploy;
use App::Task::Command::Status;
use App::Task::Command::Cleanup;

my $task = App::Task::Base->new;
$task->run;
