#!/usr/bin/env perl

our $VERSION = "4.00";

# DO NOT EDIT -- this is an auto generated file

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Task/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_BASE';
  package App::Task::Base;
  use Moo;
  
  use IO::CaptureOutput qw( capture_exec capture_exec_combined );
  use IO::Interactive qw( is_interactive );
  use Getopt::Long;
  use Term::ANSIColor;
  use App::Task::ContentTracker;
  use App::Task::Config;
  
  Getopt::Long::Configure( qw( no_ignore_case bundling pass_through require_order ));
  
  our $VERSION = '4.00';
  
  my $instance;
  
  # this is a singleton class
  sub instance {
  	return $instance if $instance;
  	die __PACKAGE__ . ' instance has not been built yet';
  }
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	if (my $message = App::Task::Config->configure($args->{config_file})) {
  		usage($message);
  	}
  
  	$instance = $self;
  
  	# use Getopt::Long to get the command line options
  	GetOptions(
  		'help|h'     => sub { usage() },
  		'verbose|v+' => \($App::Task::Config::options{verbose}),
  	) or usage();
  }
  
  sub run {
  	my ($self) = @_;
  
  	my $content_tracker = App::Task::ContentTracker->new;
  
  	my $command_name = shift @ARGV;
  	usage() if !$command_name;
  
  	my $command = App::Task::Config->find_command($command_name);
  	if (!$command) {
  		usage("Invalid command: $command_name");
  	}
  
  	my $command_instance = $command->{module}->new(
  		content_tracker => $content_tracker,
  	);
  	$command_instance->run;
  }
  
  sub prompt {
  	my ($self, %options) = @_;
  	$self = instance() if !ref $self;
  
  	print 'Enter ' . join(', ', map { "'$_' to $options{$_}" } grep { !/default/ } keys %options) . ', anything else to exit: ';
  	chomp(my $response = <STDIN>);
  	if (defined $options{lc $response}) {
  		return $options{lc $response};
  	} elsif (defined $options{default}) {
  		return $options{default};
  	} else {
  		print "Exiting...\n";
  		exit;
  	}
  }
  
  # perform system calls, returning both stdout and stderr
  sub system_call {
  	my ($self, $command, %options) = @_;
  	$self = ref $self ? $self : instance();
  
  	# handle arrayrefs or scalars for $command
  	$command = [ $command ] if !ref $command;
  
  	my $command_text = join(' ', @$command);
  	if (App::Task::Config->get_option('verbose') && App::Task::Config->get_option('verbose') >= 1 || $options{verbose}) {
  		printf("\r%s\r", ' ' x 80) if is_interactive();
  		print "* $command_text\n"
  	}
  
  	# run the command
  	my ($stdout, $stderr);
  	if ($options{combine}) {
  		($stdout) = capture_exec_combined(@$command);
  	} else {
  		($stdout, $stderr) = capture_exec(@$command);
  	}
  
  	my $exit_status = $? & 127 ? $? & 127 : $? >> 8;
  
  	my $output = '';
  	if ($stdout) {
  		# replace each line (except the first with some asterisks
  		chomp(my $stdout_copy = $stdout);
  		$stdout_copy =~ s/(?!\A)^/** /gims;
  		$output .= "** stdout: '$stdout_copy'\n";
  	}
  	if ($stderr) {
  		chomp(my $stderr_copy = $stderr);
  		$stderr_copy =~ s/(?!\A)^/** /gims;
  		$output .= "** stderr: '$stderr_copy'\n";
  	}
  
  	if (!defined $options{ignore_exit_status} and $exit_status) {
  		$self->highlighted_die("Command failed: $command_text\n$output\n");
  	}
  	if (App::Task::Config->get_option('verbose') && App::Task::Config->get_option('verbose') >= 2) {
  		print $output;
  	}
  
  	return ($stdout, $stderr, $exit_status);
  }
  
  sub highlighted_die {
  	my ($self, $message) = @_;
  	# preserve last-line perl non-stack trace behavior
  	$message =~ s/(\n?)\z/color('reset') . $1/e;
  	die color('red') . $message;
  }
  
  sub environments {
  	my ($class) = @_;
  	return App::Task::Config->config->{environments};
  }
  
  sub usage {
  	my ($message) = @_;
  
  	print "$message\n\n" if $message;
  
  	print <<"END_USAGE";
  Usage: task <subcommand>
  
  task is a release management tool for git designed to aid multi-user
  development in tiny chunks (task branches). It supports
  multiple environments and can build de facto releases (defined by whatever is
  on a given branch) or versioned releases
  
  Available subcommands are:
  END_USAGE
  
  	for my $command_name (App::Task::Config->command_list) {
  		printf "    %-12s %s\n", $command_name, App::Task::Config->find_command($command_name)->{description};
  	}
  
  	print "\nUse 'task <subcommand> --help' for more information\n";
  
  
  	exit 1;
  }
  
  no Moo;
  
  1;
APP_TASK_BASE

$fatpacked{"App/Task/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND';
  package App::Task::Command;
  use Moo::Role;
  use Types::Standard qw(ArrayRef HashRef InstanceOf);
  
  use Cwd qw( getcwd );
  use Getopt::Long;
  Getopt::Long::Configure( qw( no_ignore_case bundling pass_through permute ));
  
  has 'environment'   => ( is => 'ro', isa => HashRef, reader => 'get_environment' );
  has 'content_tracker' => ( is => 'ro', required => 1, isa => InstanceOf['App::Task::ContentTracker'], reader => 'content_tracker' );
  
  has 'task_branch' => ( is => 'rw' );
  has 'original_dir' => ( is => 'ro', default => sub { getcwd() }, reader => 'get_original_dir' );
  has 'allow_branch_switch' => ( is => 'rw', default => sub { 0 } );
  has 'deployment_branch' => ( is => 'rw', reader => 'get_deployment_branch', writer => 'set_deployment_branch' );
  
  requires 'run';
  requires 'usage';
  
  around 'run' => sub {
  	my ($next, $self, %options) = @_;
  
  	my $original_branch = $self->content_tracker->get_current_branch;
  	$self->content_tracker->update_remotes;
  
  	# eval the run and make sure we end up in the same place we started
  	my @returned_values;
  	eval {
  		@returned_values = $next->($self);
  	};
  	my $error;
  	if ($@) {
  		$error = $@;
  	}
  
  	$self->return_to_original_dir;
  	my $current_branch = $self->content_tracker->get_current_branch;
  	if ($current_branch ne $original_branch and !$self->allow_branch_switch) {
  		App::Task::Base->system_call("git checkout '$original_branch'");
  	}
  
  	die $error if $error;
  
  	return (@returned_values);
  };
  
  sub return_to_original_dir {
  	my ($self) = @_;
  
  	my $current_dir  = getcwd;
  	my $original_dir = $self->get_original_dir;
  	if ($original_dir ne $current_dir) {
  		chdir $self->get_original_dir
  			or die "Couldn't change back to $original_dir from $current_dir";
  	}
  }
  
  sub set_environment {
  	my ($self, $env) = @_;
  
  	if ($env) {
  		$self->{environment} = App::Task::Base->environments->{$env} or die "Invalid destination environment: $env";
  	} else {
  
  		my $destination_env = shift @ARGV;
  		$self->usage("error: No environment specified") if !defined $destination_env;
  
  		$self->{environment} = App::Task::Base->environments->{$destination_env};
  		if (!defined $self->{environment}) {
  			$self->usage("error: '$destination_env' is not a valid environment\nvalid environments are: " . join(', ', sort keys %{App::Task::Base->environments}));
  		}
  	}
  }
  
  sub env {
  	my ($self) = @_;
  	return $self->{environment};
  }
  
  sub add_task {
  	my ($self, $branch_name) = @_;
  	if (my ($valid_branch) = sort $self->content_tracker->get_branches_by_prefix($branch_name)) {
  		$self->task_branch($valid_branch);
  		return 1;
  	}
  	return 0;
  }
  
  sub resolve_file {
  	my ($self, $path) = @_;
  
  	my $relative_to_root = `git rev-parse --show-cdup`;
  	chomp $relative_to_root;
  
  	# if the relative path isn't in git, assume it is a canonical path
  	# note that the file could be deleted, so we still have to check
  	if (-e $path) {
  		if ($relative_to_root) {
  			return abs2rel(abs_path(rel2abs $path), $self->content_tracker->get_repository_root);
  		} else {
  			return $path;
  		}
  	}
  
  	return $path if -e "$relative_to_root$path";
  
  	die "Couldn't find file: $path";
  }
  
  sub parse_options {
  	my ($self, %options) = @_;
  
  	$options{'verbose|v+'} = \($App::Task::Config::options{verbose});
  
  	# use Getopt::Long to get the command line options
  	GetOptions(%options) or $self->usage;
  };
  
  no Moo::Role;
  no Types::Standard;
  
  1;
APP_TASK_COMMAND

$fatpacked{"App/Task/Command/Cleanup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_CLEANUP';
  package App::Task::Command::Cleanup;
  use Moo;
  
  use App::Task::Config;
  
  with 'App::Task::Command';
  
  App::Task::Config->register_command( cleanup => 'Cleanup branches that have been deployed or abandoned' );
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	# set some defaults
  	my $deployed_to_env = 'prod';
  	my $days            = 7;
  
  	$self->parse_options(
  		'help|h'   => sub { $self->usage },
  		'delete|d' => sub { App::Task::Config->set_option('delete-task-branches' => 1) },
  		'days=i'   => \$days,
  		'deployed-to=s' => \$deployed_to_env,
  	);
  	# TODO: add a --production option that will make sure branch tips are the same and delete them
  
  	# make sure the specified environment is a valid one
  	die "Invalid env '$deployed_to_env'" if !defined App::Task::Base->environments->{$deployed_to_env};
  
  	App::Task::Config->set_option('deployed-to' => $deployed_to_env);
  	App::Task::Config->set_option('days-since-last-commit' => $days);
  
  	for my $arg (@ARGV) {
  		if (!$self->add_task($arg)) {
  			print "Unknown option: $arg\n";
  		}
  	}
  }
  
  sub run {
  	my ($self) = @_;
  
  	$self->content_tracker->update_remotes;
  
  	my ($local_branches) = App::Task::Base->system_call("git branch");
  	my ($current_branch) = $local_branches =~ /^\* ([^\n]+)/ims;
  
  	LOCAL_BRANCH:
  	for my $raw_branch (split /\n/, $local_branches) {
  		my ($branch_name) = $raw_branch =~ /^\*?[ \t]*\b(.*)/ims;
  
  		# only deal with task branches
  		# TODO: this should skip env branches, but doesn't right now
  		next LOCAL_BRANCH if !$branch_name;
  
  		# skip branches that weren't specified if branches were specified
  		next LOCAL_BRANCH if $self->task_branch !~ /^\Q$branch_name/;
  
  		my ($deployed_envs) = $self->content_tracker->get_deployed_envs($branch_name);
  		my $target_env = App::Task::Config->get_option('deployed-to');
  
  		# branches are removable when they are on integration (shared with other people) and on the target env
  		if (defined $deployed_envs->{integration} and defined $deployed_envs->{$target_env}) {
  			chomp(my ($last_commit_timestamp) = App::Task::Base->system_call("git log -1 --pretty=format:'%ct' '$target_env/$branch_name'", ignore_exit_status => 1));
  			if (!$last_commit_timestamp) {
  				chomp(my ($sha1) = App::Task::Base->system_call("git rev-parse $branch_name"));
  
  				# it's possible that the branch was merged into another branch and deployed that way, so if you don't have the ref on the env, look up based on the local head
  				chomp(($last_commit_timestamp) = App::Task::Base->system_call("git log -1 --pretty=format:'%ct' '$sha1'"));
  			}
  
  			my $actual_days_since_last_commit = int((time() - $last_commit_timestamp) / 86400);
  			if ($actual_days_since_last_commit >= App::Task::Config->get_option('days-since-last-commit')) {
  				print "Branch '$branch_name' has existed on $target_env for $actual_days_since_last_commit days and can be deleted\n";
  
  				# delete the local branch if we're doing that
  				if (App::Task::Config->get_option('delete-task-branches')) {
  					system("git branch -D '$branch_name'");
  				}
  #			} else {
  #				print "Branch '$branch_name' has only existed on $target_env for $actual_days_since_last_commit days\n";
  			}
  		}
  	}
  }
  
  sub usage {
  	my ($self, $message) = @_;
  
  	print "$message\n\n" if $message;
  
  	print <<"END_USAGE";
  Usage: task cleanup [-hd] <branch_name>
  
  Show (and delete) task branches that have been deployed to production or another environment
  
  Options:
  
      -h, --help                   Show a brief help message and exit
      -n, --noconfirm  Don't show a confirmation message before doing the deploy
      -d, --delete                 Delete the branches that exist on the target
                                   environment
      --deployed-to=<environment>  Sets the target environment for which task
                                   branches must have been deployed to.
                                   Defaults to what your mainline branch is set to
      --days=<number>              Make sure the task branches have existed on the
                                   target environment for at least this many days
  
  Examples:
  
      task cleanup
  
  Show local branches whose tips have existed on prod for at least 7 days
  
      task cleanup -d
  
  Delete local branches whose tips have existed on prod for at least 7 days
  END_USAGE
  
  	exit 1;
  }
  
  1;
APP_TASK_COMMAND_CLEANUP

$fatpacked{"App/Task/Command/Deploy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_DEPLOY';
  package App::Task::Command::Deploy;
  use Moo;
  
  use Cwd qw( getcwd );
  use Term::ANSIColor;
  use App::Task::Config;
  use App::Task::Hooks;
  
  with 'App::Task::Command';
  
  App::Task::Config->register_command( deploy => 'Deploy a task branch to a given environment (and all its dependent envs too)' );
  
  sub highlighted_die {
  	my ($message) = @_;
  	# preserve last-line perl non-stack trace behavior
  	$message =~ s/(\n?)\z/color('reset') . $1/e;
  	die color('red') . $message;
  }
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	$self->parse_options(
  		'help|h'      => sub { $self->usage },
  		'noconfirm|n' => sub { App::Task::Config->set_option('noconfirm'  => 1)},
  		'again'       => sub { App::Task::Config->set_option('redeploy' => 1)},
  	);
  
  	$self->set_environment($args->{destination_environment});
  
  	my $branch_name = $self->env->{branch_name};
  	$self->content_tracker->update_remotes;
  	my ($branch_tip) = App::Task::Base->system_call("git rev-parse 'origin/$branch_name'");
  	chomp $branch_tip;
  
  	if (scalar @ARGV and !$self->task_branch) {
  
  		my @files;
  		while (my $arg = pop @ARGV) {
  			if ($arg =~ /-deploy\d+$/ && $self->add_task($arg)) {
  				$self->set_deployment_branch($arg);
  			} elsif (!$self->add_task($arg)) {
  				# create a list of deployable files and only deploy those if specified
  
  				my $file = $self->resolve_file($arg);
  				push @files, $file;
  			}
  		}
  
  		if (@files) {
  			# if explicit files were specified, create a sub-branch to deploy just those
  			my $deployment_branch = $self->content_tracker->add_files_to_new_deployment_branch($self->task_branch, \@files);
  			$self->set_deployment_branch($deployment_branch);
  		}
  	}
  }
  
  sub run {
  	my ($self) = @_;
  
  	my $current_dir = getcwd;
  
  	my $env_name = $self->env->{name};
  
  	my @branches;
  	TASK:
  	my $task_branch = $self->task_branch;
  
  	my $ready = App::Task::Command::Ready->new(
  		destination_environment => $self->env->{name},
  		content_tracker         => $self->content_tracker,
  		deployment_branch       => $self->get_deployment_branch,
  	);
  	$ready->add_task($task_branch);
  
  	my $branch_name = $ready->run;
  	push(@branches, $branch_name);
  
  	# find out what's changed between the local task branch and remote env master
  	my @unpushed_files;
  	my @deployment_branches;
  	my $target_branch_name = $self->env->{branch_name};
  	$task_branch = $self->task_branch;
  
  	my $current_branch_name = $self->content_tracker->get_branch_name($task_branch);
  
  	# deploy the main task branch or a deployment branch if that was specified
  	my $deployment_branch_name = $self->get_deployment_branch || $current_branch_name;
  
  	my @files = $self->content_tracker->get_changed_files($task_branch, "origin/$target_branch_name", branch_name => $deployment_branch_name);
  	push(@unpushed_files, @files);
  
  	# add all of the files that have been changed on the branch if we're redeploying
  	if (App::Task::Config->get_option('redeploy')) {
  		my ($file_list, $err, $exit_status) = App::Task::Base->system_call("git diff --name-only origin/master...$env_name/$deployment_branch_name", ignore_exit_status => 1);
  		if (!$exit_status) {
  			chomp $file_list;
  
  			my @files = map { s/^\s*|\s*$//ms; $_ } split(/\n/, $file_list);
  			push(@unpushed_files, @files);
  		}
  	}
  
  	push @deployment_branches, $deployment_branch_name;
  
  	my $changed_file_count = scalar @unpushed_files;
  	if ($changed_file_count) {
  		print "$changed_file_count " . ($changed_file_count > 1 ? 'files' : 'file') . " to deploy to $env_name\n";
  	} else {
  		print "No changed files to deploy to $env_name";
  		print "\n\n";
  		return;
  	}
  
  	# quote our file lists just in case file names have spaces
  	my $remote_files = join(' ', map { "'$_'" } @unpushed_files);
  
  	my $original_branch = $self->content_tracker->get_current_branch;
  
  	# once we do the merge, everything else should use exception handling to make sure
  	my $temp_branch_exists = 0;
  	eval {
  		my %merged_branches;
  
  		my $temp_branch_name = "temp_deploy_${env_name}";
  		# checkout a copy of the remote master for copying/rsyncing
  		App::Task::Base->system_call("git checkout --track -b '$temp_branch_name' origin/$target_branch_name");
  		$temp_branch_exists = 1;
  
  		for my $deployment_branch_name (@deployment_branches) {
  			# ready should have already put the content here, so now we just need to merge the branch into master
  			if ($env_name eq 'integration') {
  				$self->content_tracker->safe_merge($deployment_branch_name, $env_name, 'integration', '', 'deploy');
  			} else {
  				$self->content_tracker->safe_merge("origin/$env_name-ready/$deployment_branch_name", $env_name, $temp_branch_name, '--ff-only', 'deploy');
  			}
  
  			$merged_branches{$deployment_branch_name} = 1;
  		}
  
  		# print diffstat of what we are deploying
  		my ($diffstat) = App::Task::Base->system_call("git diff --stat=120,100 'origin/$target_branch_name'..'$temp_branch_name'");
  		print "Deploying the following changes to $env_name:\n$diffstat\n";
  
  		# this is as far as we can go before we have to start entering passwords and changing stuff
  		if (!App::Task::Config->get_option('noconfirm')) {
  			print "Enter 'y' to continue, anything else to exit: ";
  			chomp(my $response = <STDIN>);
  			if (lc $response ne 'y') {
  				# make sure we're back in the original dir and branch
  				$self->return_to_original_dir;
  
  				App::Task::Base->system_call("git checkout $original_branch");
  				App::Task::Base->system_call("git branch -D 'temp_deploy_$env_name'");
  				exit;
  			}
  		}
  
  		# push changes back to env repository
  		App::Task::Base->system_call("git pull origin '$target_branch_name'");
  		App::Task::Base->system_call("git push origin 'temp_deploy_$env_name:$target_branch_name'");
  		print "Updated git $env_name branch\n";
  
  		# make sure we are where we started, and get rid of the temp deployment branch
  		# TODO: put in an END block so we can clean up after failure or ^c
  		App::Task::Base->system_call("git checkout $original_branch");
  		App::Task::Base->system_call("git branch -d 'temp_deploy_$env_name'");
  		$temp_branch_exists = 0;
  
  		my $current_dir = getcwd;
  
  		# finish the pull requests
  		my %deployed_branches;
  		for my $branch_name (@branches) {
  			$deployed_branches{$branch_name}++;
  		}
  
  		# TODO: run post-deploy hooks somewhere around here
  #		$self->run_hooks;
  
  		chomp( my ($deploy_sha) = App::Task::Base->system_call("git rev-parse HEAD") );
  
  		my $hooks_ok = App::Task::Hooks->run_hooks($self, 'post_deploy', {
  				TASK_DEPLOY_ENVIRONMENT => $env_name,
  				TASK_DEPLOY_SHA => $deploy_sha,
  		});
  
  		die "Failed to run hooks" unless $hooks_ok;
  
  		# when we're done with the deploy, merge down to dependent
  		# environments, if we are doing that for this branch
  		if ($self->env->{branch_name} eq App::Task::Config->config->{mainline_branch} and $self->env->{dependent_environment}) {
  
  			# do one remote update right before merging back down to avoid fast-forward issues
  			App::Task::Config->set_option('needs-update' => 1);
  			$self->content_tracker->update_remotes;
  
  			my $dependent_env_name = $self->env->{dependent_environment};
  			$self->merge_back_to_dependent_environments($env_name, $dependent_env_name);
  		}
  
  		# go back to where we started and make sure the integration refs are up-to-date
  		chdir $current_dir or highlighted_die "Couldn't chdir to: $current_dir";
  	};
  	if ($@) {
  		# make sure we're back in the original dir and branch
  		$self->return_to_original_dir;
  
  		App::Task::Base->system_call("git checkout $original_branch");
  		App::Task::Base->system_call("git branch -D 'temp_deploy_$env_name'") if $temp_branch_exists;
  
  		# and propagate the error
  		die $@;
  	} else {
  		print color 'green';
  		print "finished deploying to $env_name\n\n";
  		print color 'reset';
  	}
  }
  
  sub merge_back_to_dependent_environments {
  	my ($self, $top_level_env, $dependent_env_name) = @_;
  	my $top_level_env_branch = App::Task::Base->environments->{$top_level_env}{branch_name};
  	my $dependent_env_branch = App::Task::Base->environments->{$dependent_env_name}{branch_name};
  
  	# note that this should get called in an eval, so we can just die here on error
  
  	my $temp_branch_name = "temp_merge_${top_level_env}_back_to_${dependent_env_name}";
  	App::Task::Base->system_call("git checkout -b '$temp_branch_name' origin/$dependent_env_branch");
  
  	$self->content_tracker->safe_merge("origin/$top_level_env_branch", $dependent_env_name, "origin/$dependent_env_branch", '', '');
  
  	# push changes back to dependent env repository
  	App::Task::Base->system_call("git push origin '$temp_branch_name:$dependent_env_branch'");
  
  	# just get off of the branch so that we can delete it
  	App::Task::Base->system_call("git checkout master");
  	App::Task::Base->system_call("git branch -D '$temp_branch_name'");
  
  	print "Merged changes from $top_level_env back to $dependent_env_name\n";
  
  	if (my $next_dependent_env = App::Task::Base->environments->{$dependent_env_name}{dependent_environment}) {
  		$self->merge_back_to_dependent_environments($top_level_env, $next_dependent_env);
  	} else {
  		return;
  	}
  }
  
  no Moo;
  
  sub usage {
  	my ($self, $message) = @_;
  
  	print "$message\n\n" if $message;
  
  	print <<"END_USAGE";
  Usage: task deploy [-hn] [--again] environment <branch_name>
  
  Merge and deploy task branches
  
  Options:
  
      -h, --help       Show a brief help message and exit
      -n, --noconfirm  Don't show a confirmation message before doing the deploy
      --again          Ignore if a branch has already been deployed to an
                       environment and re-deploy again anyway. Basically this
                       will rerun your hooks for this environment without merging
                       anything
  END_USAGE
  
  	exit 1;
  }
  
  1;
APP_TASK_COMMAND_DEPLOY

$fatpacked{"App/Task/Command/Ready.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_READY';
  package App::Task::Command::Ready;
  use Moo;
  
  use Term::ANSIColor;
  use App::Task::Config;
  
  with 'App::Task::Command';
  
  App::Task::Config->register_command( ready => 'Pre-merge a task branch with an environment branch for later deployment' );
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	$self->parse_options(
  		'help|h'                => sub { $self->usage },
  	);
  
  	# get the env from the command line
  	$self->set_environment($args->{destination_environment});
  
  	if (scalar @ARGV and !$self->task_branch) {
  
  		my @files;
  		while (my $arg = pop @ARGV) {
  			if ($arg =~ /-deploy\d+$/ && $self->add_task($arg)) {
  				$self->set_deployment_branch($arg);
  			} elsif (!$self->add_task($arg)) {
  				# create a list of deployable files and only deploy those if specified
  				my $file = $self->resolve_file($arg);
  				push @files, $file;
  			}
  		}
  
  		if (@files) {
  			# if explicit files were specified, create a sub-branch to deploy just those
  			my $deployment_branch = $self->content_tracker->add_files_to_new_deployment_branch($self->task_branch, \@files);
  			$self->set_deployment_branch($deployment_branch);
  		}
  	}
  
  }
  
  sub run {
  	my ($self) = @_;
  
  	# if we were called directly by App::Task::Base, then this means the command was called directly and we should send notifications
  	# otherwise, we're operating as part of another command, so we shouldn't send out notifications about this specific operation
  	# this makse some major assumtions about the way that 'around' is implemnted in Moose. We shouldn't rely on this in the long run
  	my $is_final_command = (caller(4))[0] =~ /^App::Task::Base$/ ? 1 : 0;
  
  	my (@changed_files, @ready_tasks, $diff_stat);
  
  	my $env_name = $self->env->{name};
  	my ($remotes) = App::Task::Base->system_call("git remote");
  	my %remotes = map { $_ => 1 } split(/\n/, $remotes);
  	if (!exists $remotes{'origin'}) {
  		die color('red') . "You don't have a remote set up. Please re-clone the repository" . color('reset');
  	}
  
  	my $original_branch = $self->content_tracker->get_current_branch;
  	my $merge_commit_id;
  
  	my $repository_root = $self->content_tracker->get_repository_root;
  	my $task_branch = $self->task_branch;
  
  	my $branch_name = $self->content_tracker->get_branch_name($task_branch);
  
  	# ready the main task branch or a deployment branch if that was specified
  	my $deployment_branch_name = $self->get_deployment_branch || $branch_name;
  
  	my $deployed_envs = $self->content_tracker->get_deployed_envs($deployment_branch_name);
  
  	# deploy to the dependent env first if there is one
  	my $dependent_env = $self->env->{dependent_environment};
  	if (defined $dependent_env and !exists $deployed_envs->{$dependent_env}) {
  		my $dependent_deploy = App::Task::Command::Deploy->new(
  			destination_environment => $self->env->{dependent_environment},
  			content_tracker         => $self->content_tracker,
  			deployment_branch       => $self->get_deployment_branch,
  		);
  		$dependent_deploy->add_task($task_branch);
  		$dependent_deploy->run;
  	}
  
  	# make sure we are where we started
  	App::Task::Base->system_call("git checkout $original_branch");
  
  	my $remote_task_branch_name = '';
  	if ($env_name eq 'integration') {
  		($remote_task_branch_name) = map { /^\s*(origin\/$deployment_branch_name)$/ims ? $1 : ()} `git branch -r`;
  	} else {
  		($remote_task_branch_name) = map { /^\s*(origin\/$env_name-ready\/$deployment_branch_name)$/ims ? $1 : ()} `git branch -r`;
  	}
  
  	# create a temporary local branch to make sure your changes will apply
  	my $temp_branch_name = "temp_${env_name}_merge_$deployment_branch_name";
  	my $allow_ready = $self->env->{allow_ready};
  	eval {
  		my $diff_branch = $temp_branch_name;
  		my $env_branch_name = App::Task::Base->environments->{$env_name}{branch_name};
  
  		if ($remote_task_branch_name) {
  			# make a local copy of the remote task branch if it exists
  			App::Task::Base->system_call("git checkout -b $temp_branch_name $remote_task_branch_name");
  		} elsif ($allow_ready) {
  			# branch off the remote env branch if there isn't a remote task branch and we are
  			# pre-merging so that people deploying to higher envs won't have merge conflicts
  			App::Task::Base->system_call("git checkout -b $temp_branch_name origin/$env_branch_name");
  		} else {
  			# if we aren't pre-merging, then just use the branch we're pushing
  			App::Task::Base->system_call("git checkout -b $temp_branch_name $deployment_branch_name");
  			$diff_branch = "origin/$env_branch_name";
  		}
  
  		# get the list of files that will be changed for each task
  		@changed_files = $self->content_tracker->get_changed_files($task_branch, $diff_branch, branch_name => $deployment_branch_name);
  
  		if ($is_final_command) {
  			($diff_stat) = App::Task::Base->system_call("git diff -p --stat --color '$diff_branch'...'$deployment_branch_name'", ignore_exit_status => 1);
  		}
  
  		# merge branch into env branch, making sure the branch patch applies
  		# (it dies if it doesn't)
  		$self->content_tracker->safe_merge($deployment_branch_name, $env_name, $temp_branch_name, '--no-ff --log', $remote_task_branch_name ? 're-ready' : 'ready');
  
  		# merge the remote env branch into the temp branch to make sure that it applies
  		# (but we want the raw branch with no merge on integration, so skip this there)
  		if ($allow_ready) {
  			$self->content_tracker->safe_merge("origin/$env_branch_name", $env_name, $temp_branch_name, '--no-ff --log', $remote_task_branch_name ? 're-ready' : 'ready');
  		}
  
  		# get the commit id for the tip of the merged branch
  		chomp(($merge_commit_id) = App::Task::Base->system_call("git rev-parse '$temp_branch_name'"));
  
  		push(@ready_tasks, $task_branch);
  
  		# push your local version of the task branch to destination env remote
  		if ($env_name eq 'integration') {
  			App::Task::Base->system_call("git push origin 'HEAD:$deployment_branch_name'");
  		} else {
  			App::Task::Base->system_call("git push origin 'HEAD:$env_name-ready/$deployment_branch_name'");
  		}
  		App::Task::Base->system_call("git checkout $original_branch");
  		App::Task::Base->system_call("git branch -D $temp_branch_name");
  	};
  	if ($@) {
  		# make sure we clean up, even if we fail
  		App::Task::Base->system_call("git checkout $original_branch");
  		App::Task::Base->system_call("git branch -D $temp_branch_name", ignore_exit_status => 1);
  
  		# re-throw merge conflicts
  		App::Task::Base->instance->highlighted_die($@);
  	}
  
  	my $changed_file_count = scalar @changed_files;
  	if ($changed_file_count) {
  		print "\n$changed_file_count " . ($changed_file_count > 1 ? 'files' : 'file') . " ready for $env_name\n";
  	} else {
  		print "\nNo changed files to set as ready for $env_name\n";
  		return;
  	}
  
  	# list the files to be deployed
  	print join('', map { "\t$deployment_branch_name\t$_\n" } @changed_files);
  	print "\n";
  
  	print "ready for $env_name - commit id: $merge_commit_id\n";
  	my $github_url = App::Task::Config->config->{github_url};
  	my $env_branch_name = App::Task::Base->environments->{$env_name}{branch_name};
  	if ($github_url) {
  		print "View the full diff here: $github_url/compare/$env_branch_name...$merge_commit_id\n";
  	}
  
  	return $deployment_branch_name;
  }
  
  sub usage {
  	my ($self, $message) = @_;
  
  	print "$message\n\n" if $message;
  
  	print <<"END_USAGE";
  Usage: task ready [-hn] environment <branch_name>
  
  Pre-merge task branches and set them as ready for deployment without actually deploying them
  
  Options:
  
      -h, --help     Show a brief help message and exit
  END_USAGE
  
  	exit 1;
  }
  
  1;
APP_TASK_COMMAND_READY

$fatpacked{"App/Task/Command/Start.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_START';
  package App::Task::Command::Start;
  use Moo;
  
  use App::Task::Config;
  
  with 'App::Task::Command';
  
  App::Task::Config->register_command( start => 'Start work on a new or existing task branch' );
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	$self->parse_options(
  		'help|h'       => sub { $self->usage },
  	);
  
  	# take the last command line arg if it specifies a task
  	my $arg = shift @ARGV;
  	if ($arg) {
  		$self->task_branch($arg);
  	}
  
  	$self->{allow_branch_switch} = 1;
  
  	$self->usage("No feature branch name specified to start work on") if !$self->task_branch;
  }
  
  sub run {
  	my ($self) = @_;
  
  	$self->content_tracker->update_remotes;
  
  	if (my $branch = $self->task_branch) {
  		$self->create_task_branch($branch);
  	}
  }
  
  sub create_task_branch {
  	my ($self, $branch) = @_;
  
  	# get the branch name for the task
  	my $branch_name = $self->content_tracker->get_branch_name($branch);
  
  	$self->content_tracker->_create_branch($branch_name);
  }
  
  sub usage {
  	my ($self, $message) = @_;
  
  	print "$message\n\n" if $message;
  
  	print <<"END_USAGE";
  Usage: task start [-h] <branch_name>
  
  Properly starts a task branch from your mainline branch
  
  Options:
  
      -h, --help     Show a brief help message and exit
  
  Examples:
  
      task start feature/docs
  
      creates a branch feature/docs from origin/master
      or checks it out if someone else already created it
  END_USAGE
  
  	exit 1;
  }
  
  1;
APP_TASK_COMMAND_START

$fatpacked{"App/Task/Command/Status.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_STATUS';
  package App::Task::Command::Status;
  use Moo;
  
  use Types::Standard qw(HashRef ArrayRef);
  use Term::ANSIColor;
  use IO::Interactive qw( is_interactive );
  use App::Task::Config;
  
  with 'App::Task::Command';
  
  has 'envs'               => ( is => 'ro', isa => HashRef, default => sub { {} });
  has 'visited_commits'    => ( is => 'rw', isa => HashRef, default => sub { return {} } );
  has 'args'               => ( is => 'rw', isa => HashRef, default => sub { return {} } );
  has 'ordered_envs'       => ( is => 'lazy', isa => ArrayRef );
  has 'indent'             => ( is => 'rw', default => sub { 0 } );
  has 'columns'            => ( is => 'lazy' );
  
  $| = 1;
  
  App::Task::Config->register_command( status => 'View the status of a task branch' );
  
  sub _build_columns {
  	my $self = shift;
  	return unless is_interactive();
  	my ($wchar) = $ENV{COLUMNS} || 80;
  	return $wchar - 2;
  };
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	$self->args->{color}       = 1 if is_interactive();
  
  	$self->parse_options(
  		'help|h'            => sub { $self->usage },
  		'diff|p!'           => \$self->args->{diff},
  		'diff-options=s'    => \$self->args->{diff_options},
  		'log|l!'            => \$self->args->{log},
  		'log-options=s'     => \$self->args->{log_options},
  		'color|colour|c!'   => \$self->args->{color},
  		'all-commits!'      => \$self->args->{all_commits},
  		'name-only!'        => \$self->args->{name_only},
  	);
  
  	my @new_argv;
  
  	# if there isn't any task, default to the current branch
  	if (!scalar @ARGV) {
  		my $current_branch = $self->content_tracker->get_current_branch;
  		$self->add_task( $current_branch );
  	}
  	for my $arg (@ARGV) {
  		if (!$self->add_task($arg)) {
  			push(@new_argv, $arg);
  		}
  	}
  
  	if (scalar @new_argv) {
  		$self->abort("Unrecognized option: '@new_argv'");
  	}
  	$self->usage if !$self->task_branch;
  }
  
  sub _build_ordered_envs {
  	my $self = shift;
  
  	my $environments = App::Task::Base->environments;
  	my ($current_top_level_env) = map { $environments->{$_}{branch_name} eq App::Task::Config->config->{mainline_branch} ? $_ : () } keys %$environments;
  	my @ordered_envs;
  
  	# go through each environment from prod on down to wherever the dependency chain ends
  	# based on a starting point and each dependent environment
  	while ($current_top_level_env && defined $environments->{$current_top_level_env}) {
  		push(@ordered_envs, $current_top_level_env);
  		push(@ordered_envs, "ready for $current_top_level_env") if $environments->{$current_top_level_env}{allow_ready};
  		$current_top_level_env = $environments->{$current_top_level_env}{dependent_environment} || undef;
  	}
  	push(@ordered_envs, 'Un-merged changes');
  	return \@ordered_envs;
  }
  
  sub increase_indent {
  	my $self = shift;
  	$self->indent($self->indent() + 4);
  }
  
  sub decrease_indent {
  	my $self = shift;
  	$self->indent($self->indent() - 4);
  }
  
  sub print_indented {
  	my ($self, $text) = @_;
  	print " " x $self->indent(), $text, "\n";
  }
  
  sub get_status {
  	my ($self, $task_branch_name) = @_;
  
  	# If the task is merged to master, find a point on master *before* it was merged.
  	# Then the common ancestor of the branch tip and that point will be the point of divergence.
  	chomp(my ($merged_to_master) = App::Task::Base->system_call("git rev-list -n 1 origin/master ^$task_branch_name"));
  	my $master_before_merge = $merged_to_master ? "$merged_to_master^" : "origin/master";
  	chomp(my ($merge_base) = App::Task::Base->system_call("git merge-base $master_before_merge $task_branch_name"));
  
  	my $start = $merge_base;
  
  	my $definitive_branch = $task_branch_name;
  	my @branch_commits    = $self->get_rev_list($start, $definitive_branch);
  
  	# Defer to origin if the branch doesn't exist locally
  	unless (@branch_commits) {
  		$definitive_branch = "origin/$task_branch_name";
  		@branch_commits    = $self->get_rev_list($start, $definitive_branch);
  	}
  
  	my %env_commits = $self->get_env_commits(
  		start          => $start,
  		branch         => $task_branch_name,
  		branch_commits => \@branch_commits,
  	);
  
  	return (
  		env_commits     => \%env_commits,
  		branch_commits  => \@branch_commits,
  	);
  }
  
  # Build up the data structure of commits in each environment, and other data
  # return (
  #     prod => {
  #         same_as_prev_env  => 0|1,
  #         branch_tip        => 'ae4bdf32ab9247e8d2942aa75235239572fbba23',
  #         branch_start_ref  => '2942aa75235239572fbba23ae4bdf32ab9247e8d',
  #         abs_commits => {
  #             list => [ ... ],
  #             hash => { ... },
  #         },
  #         rel_commits => {
  #             list => [ ... ],
  #             hash => { ... },
  #         },
  #     },
  #     ...
  # );
  sub get_env_commits {
  	my ($self, %args) = @_;
  
  	die "start not specified" if !$args{start};
  	die "branch not specified" if !$args{branch};
  
  	my $branch = $args{branch};
  	my @envs = @{$self->ordered_envs};
  
  	my @branch_rev_list = $args{branch_commits}
  		? @{$args{branch_commits}}
  		: $self->get_rev_list($args{start}, $branch);
  
  	$self->die_no_commits($branch) unless (@branch_rev_list);
  
  	my %branch_rev_hash = map { $_ => 1 } @branch_rev_list;
  
  	my %env_commits;
  	my $prev_env;
  	for my $env (@envs) {
  		# Get the rev-list of the remote repository
  		my ($remote_branch, $repo) = $self->get_remote_branch_for_env($env, $branch);
  		$remote_branch = $repo ? "$repo/$remote_branch" : $remote_branch;
  
  		my $len = print_disappearing(msg => "Fetching rev-list for '$env'...");
  
  		# Record the existing commits for the environment
  		my %remote_rev_list = map {
  			exists $branch_rev_hash{$_} ? ($_ => 1) : ()
  		} $self->get_rev_list($args{start}, $remote_branch);
  
  		print_disappearing(len => $len);
  
  		$env_commits{$env} = {
  			abs_commits => { list => [], hash => {} },
  			rel_commits => { list => [], hash => {} },
  		};
  
  		# Generate a list and hash of all the commits in this environment
  		for my $commit (@branch_rev_list) {
  			if ($remote_rev_list{$commit}) {
  				push @{$env_commits{$env}->{abs_commits}->{list}}, $commit; # add to list
  				$env_commits{$env}->{abs_commits}->{hash}->{$commit} = 1;   # hashify that list
  			}
  		}
  
  		# Set the branch start, start ref, and tip for convenience
  		$env_commits{$env}->{branch_start_name} = $args{start};
  		chomp(my ($start_ref) = App::Task::Base->system_call(
  			"git show-ref $args{start}",
  			ignore_exit_status => 1,
  		));
  		# Revert back to start if show-ref failed
  		$start_ref ||= $args{start};
  
  		$env_commits{$env}->{branch_start_ref} = (split(/\s+/, $start_ref))[0];
  		$env_commits{$env}->{branch_tip} = $env_commits{$env}->{abs_commits}->{list}->[0] || '';
  
  		# Indicate if this environment is the same as the previous
  		if ($prev_env && $env_commits{$env}->{branch_tip} eq $env_commits{$prev_env}->{branch_tip}) {
  			$env_commits{$env}->{same_as_prev_env} = 1;
  		}
  
  		# Generate relative list of commits
  		for my $commit (@{$env_commits{$env}->{abs_commits}->{list}}) {
  			# Stop if we're at the previous branch tip already
  			# When there's no prev_env, relative = absolute, therefore don't break
  			my $prev_branch_tip = $prev_env && $env_commits{$prev_env}->{branch_tip};
  			if ($prev_env && $prev_branch_tip && $commit eq $prev_branch_tip) {
  				$prev_env = $env;
  				last;
  			}
  
  			push @{$env_commits{$env}->{rel_commits}->{list}}, $commit;
  			$env_commits{$env}->{rel_commits}->{hash}->{$commit} = 1;
  		}
  
  		$prev_env = $env;
  	}
  
  	return %env_commits;
  }
  
  # Die when there are no commits, and print an informative message about why
  sub die_no_commits {
  	my $self = shift;
  	my ($branch) = @_;
  
  	chomp(my ($stdout) = App::Task::Base->system_call("git branch -a"));
  	my @all_branches = grep { s/^..// } split("\n", $stdout);
  	my @branches = grep { m{(\w+/)*$branch} } @all_branches;
  	if (@branches) {
  		warn $self->print_color(['red'], "The branch: '$branch' exists on the repositories below, but has no commits."), "\n";
  		$self->increase_indent;
  		$self->print_indented($_) for @branches;
  		$self->decrease_indent;
  		die "\n";
  	} else {
  		die $self->print_color(['red'], "The branch: '$branch' does not exist locally, or on any remote."), "\n";
  	}
  }
  
  # Print a status line that gets erased when the event is done
  # usage:
  # my $len = print_disappearing(msg => "updating..."); # Print the status message
  # do_something()
  # print_disappearing(len => $len); # Erase the message from before
  sub print_disappearing {
  	my (%args) = @_;
  
  	return unless is_interactive();
  
  	if ($args{msg}) {
  		print $args{msg};
  		return length $args{msg};
  	} elsif ($args{len}) {
  		my $spaces = (' ') x $args{len};
  		print "\r$spaces\r";
  	}
  }
  
  sub get_branch_range {
  	my ($start, $end) = @_;
  	return $end ? "$start..$end" : $start;
  }
  
  # Get the rev-list of a given range
  # Returns a list of refs and a map of refs to 1
  sub get_rev_list {
  	my $self = shift;
  	my ($start, $end) = @_;
  	my $refspec = get_branch_range($start, $end);
  
  	my @cmd_rev_list = ('git rev-list --no-merges', $refspec);
  	my $cmd = join ' ', @cmd_rev_list;
  	my ($stdout, $stderr, $exit_status) = App::Task::Base->system_call(
  		$cmd,
  		ignore_exit_status => 1,
  	);
  	my @rev_list = split "\n", $stdout;
  
  	return @rev_list;
  }
  
  
  sub get_remote_branch_for_env {
  	my ($self, $env, $task_branch_name) = @_;
  	my ($target_branch_name, $remote);
  	my $final_env = $env;
  	if ($env =~ /^ready for (\w+)/) {
  		$target_branch_name = $task_branch_name;
  		$final_env = $1;
  		if ($final_env eq 'integration') {
  			$remote = 'origin';
  		} else {
  			$remote = "origin/$final_env-ready";
  		}
  	} elsif ($env eq 'Un-merged changes') {
  		$target_branch_name = $task_branch_name;
  		$remote = '';
  	} else {
  		$target_branch_name = App::Task::Base->environments->{$final_env}{branch_name};
  		$remote = "origin";
  	}
  	if ($target_branch_name eq 'master') {
  		$target_branch_name = App::Task::Base->environments->{$final_env}{branch_name};
  	}
  	return ($target_branch_name, $remote);
  }
  
  sub print_git_command {
  	my $self = shift;
  	my ($cmd) = @_;
  
  	my ($output, $error, $exit_status) = App::Task::Base->system_call($cmd);
  	my @lines = split(/\n/, $output);
  
  	if ($cmd =~ /--stat\b/) {
  		# Provide --name-only hint when files are shortened
  		if (grep { $_ =~ m{ \.\.\./} } @lines) {
  			push @lines, $self->print_color(['black'], " (specify --name-only to see full file names)");
  		}
  	}
  
  	$self->print_indented($_) for @lines;
  	print "\n";
  
  	return [$output, $error, $exit_status];
  }
  
  sub get_indented_screen_width {
  	my $self = shift;
  
  	return unless $self->columns;
  	return $self->columns - $self->indent;
  }
  
  sub make_git_stat_cmd {
  	my $self = shift;
  	my $w = $self->get_indented_screen_width;
  	return '--stat' unless $w;
  	return "--stat=$w,$w";
  }
  
  sub print_color {
  	my $self = shift;
  	my ($color_list, $string) = @_;
  	if ($self->args->{color}) {
  		return colored($color_list, $string);
  	} else {
  		return $string;
  	}
  }
  
  sub run {
  	my ($self) = @_;
  
  	if (my $branch = $self->task_branch) {
  		my $task_branch_name = $self->content_tracker->get_branch_name($branch);
  		my @deployment_branches = $self->content_tracker->get_all_deployment_branches( $branch );
  
  		for my $branch_name ($task_branch_name, @deployment_branches) {
  			my %status = $self->get_status($branch_name);
  
  			$self->print_status_info(
  				branch => $branch_name,
  				status => \%status,
  			);
  		}
  	}
  }
  
  sub print_status_info {
  	my $self = shift;
  	my %args = @_;
  
  	my $task_branch_name = $args{branch};
  
  	die "branch not specified"    if !$args{branch};
  	die "status not specified"    if !$args{status};
  
  	my $git_args = $self->args->{color} ? '--color' : '';
  
  	$self->print_indented($self->print_color(['bold'], "Deployment status for $task_branch_name:\n"));
  	$self->increase_indent;
  
  	my @envs = @{$self->ordered_envs};
  
  	# for each environment, in order, whatever that means
  	my $prev_env;
  	for my $env (@envs) {
  		my %env_commits = %{$args{status}->{env_commits}->{$env}};
  		my $commit_key = 'rel_commits';
  		my @commits = @{$env_commits{$commit_key}->{list} || []};
  
  		if (!scalar @commits || $env_commits{same_as_prev_env}) {
  			$prev_env = $env;
  			next;
  		}
  
  		# Get chronologically first and last commits (reversed in the rev-list)
  		my $commit_last  = $env_commits{branch_tip};
  		my $commit_first;
  		if ($prev_env && $commit_key eq 'rel_commits') {
  			$commit_first = $args{status}{env_commits}{$prev_env}{branch_tip}
  		}
  		$commit_first ||= $env_commits{branch_start_ref};
  		my $commit_range = "$commit_first..$commit_last";
  
  		$self->print_env_label($env);
  		$self->increase_indent;
  
  		if ($self->args->{log}) {
  			# Do --stat and --diff | -p with `git log` to display on a per-commit basis, and run fast
  			my @log_args = ('--no-merges');
  			push @log_args, $self->make_git_stat_cmd();
  			push @log_args, '-p'                       if $self->args->{diff};
  			push @log_args, '--name-only'              if $self->args->{name_only};
  
  			$self->print_git_command(sprintf(
  				"git log $git_args %s %s %s",
  				defined $self->args->{log_options} ? $self->args->{log_options} : '',
  				join(' ', @log_args),
  				$commit_range
  			));
  		} else {
  			# If --log wasn't specified, do --stat and --diff | -p compared to the child env branch tip
  			my $l = $self->print_color(['blue'],   "Branch tip:  ");
  			my $c = $self->print_color(['yellow'], $commit_last);
  			$self->print_indented("$l $c");
  
  			my $short_range = $commit_first eq $commit_last
  				? substr($commit_first, 0, 7)
  				: substr($commit_first, 0, 7) . '..' . substr($commit_last, 0, 7);
  			$self->print_indented(sprintf("%s %s (%d commit%s)",
  				$self->print_color(['blue'],   "Commit range:"),
  				$self->print_color(['yellow'], "$short_range"),
  				scalar @commits,
  				scalar @commits == 1 ? '' : 's',
  			));
  
  			if ($self->args->{all_commits}) {
  				$self->print_indented($self->print_color(['blue'],   "All commits:"));
  				$self->increase_indent;
  				for my $commit (@commits) {
  					$self->print_indented($self->print_color(['yellow'], $commit));
  				}
  				$self->decrease_indent;
  			}
  			print "\n";
  
  			my @diff_args;
  			push @diff_args, '--name-only'              if $self->args->{name_only};
  			push @diff_args, $self->make_git_stat_cmd();
  			push @diff_args, sprintf('-p %s', (defined $self->args->{diff_options} ? $self->args->{diff_options} : ''))
  				if $self->args->{diff};
  
  			# Diff against the child environment's previous branch tip
  			$self->print_git_command(sprintf(
  				"git diff $git_args %s %s",
  				join(' ', @diff_args),
  				$commit_range,
  			));
  		}
  		$self->decrease_indent;
  		$prev_env = $env;
  	}
  	$self->decrease_indent;
  }
  
  sub print_env_label {
  	my $self = shift;
  	my ($env) = @_;
  
  	my $env_label = "$env" ;
  	$self->print_indented($self->print_color(['bold green'], "$env_label:"));
  	if ($self->args->{log} || $self->args->{diff}) {
  		$self->print_indented($self->print_color(['bold green'], '-' x ($self->get_indented_screen_width || 80)));
  	}
  }
  
  sub abort {
  	my ($self, $message) = @_;
  	print color 'red';
  	print "$message\n";
  	print color 'reset';
  	exit;
  }
  
  
  no Moo;
  no Types::Standard;
  
  sub usage {
  	my ($self, $message) = @_;
  
  	print "$message\n\n" if $message;
  
  	print <<"END_USAGE";
  Usage: task status [-h] <branch_name>
  
  Get info about which environments files for a task have been pushed to. Checks
  the status of the current task branch if none is specified.
  
  The most current version of the file (on HEAD) always shows up in bold.
  
  Options:
  
      -h, --help               Show a brief help message and exit
      --all-commits            Print a list of commits affected for each
                               environment, rather than just the commit range. This
                               gives a complete list of commits, without the
                               verbosity of --log.
      -c, --color, --colour    Enable colored output. On by default. Off when the
                               terminal isn't interactive, but can be forced by
                               manually setting --color.
      --diff-options <options> Specifies extra options to pass to `git diff` when
                               -p or --diff are used.
      -l, --log                Print `git log` information for each environment.
                               Can be used with --stat and -p or --diff to print
                               stat and diff information for each log entry.
      --log-options <options>  Specifies extra options to pass to `git log` when
                               --log is used.
      --name-only              Print a list of files affected for each environment,
                               without the verbosity of --stat. Can also be used if
                               the files affected printed by --stat are
                               abbreviated, since --name-only will not abbreviate
                               file names.
      -p, --diff               Print `git diff` information for each environment.
                               This will show diffs for entire environments, or
                               per log entry if used with --log.
  END_USAGE
  
  	exit 1;
  }
  
  1;
APP_TASK_COMMAND_STATUS

$fatpacked{"App/Task/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_CONFIG';
  package App::Task::Config;
  use strict;
  use warnings;
  
  use YAML qw( LoadFile );
  
  my (%commands, %config_data);
  our %options;
  
  sub register_command {
  	my ($module, $name, $description) = @_;
  	if ($module eq __PACKAGE__) {
  		($module) = caller;
  	}
  	$commands{$name} = {
  		description => $description,
  		module      => $module,
  	};
  }
  
  sub command_list {
  	return sort keys %commands;
  }
  
  sub find_command {
  	my ($package, $name) = @_;
  	return $commands{$name};
  }
  
  sub get_option {
  	my ($package, $option_name) = @_;
  	return $options{$option_name};
  }
  
  sub set_option {
  	my ($package, $option_name, $value) = @_;
  	$options{$option_name} = $value;
  }
  
  sub configure {
  	my ($package, $config_file) = @_;
  	undef %config_data;
  
  	my ($relative_to_root) = `git rev-parse --show-cdup`;
  	chomp $relative_to_root;
  
  	if (!$config_file) {
  		$config_file = ($relative_to_root ? "$relative_to_root/" : '') . 'deployment.yaml';
  	}
  
  	if (-e $config_file && -r $config_file) {
  		my $repo_config = LoadFile $config_file or die "Couldn't load config file '$config_file";
  
  		$config_data{environments} = $repo_config->{environments};
  		$config_data{mainline_branch} = $repo_config->{mainline_branch} || 'master';
  		$config_data{github_url} = $repo_config->{github_url};
  		$config_data{hooks} = $repo_config->{hooks};
  	} else {
  		return "Can't read config file: $config_file";
  	}
  
  	$config_data{repo_root} = $relative_to_root || ".";
  
  	# validate the config file
  	for my $env (keys %{$config_data{environments}}) {
  		# add the environment name into the hashref so that we can know which env we're in without having to add that to the config file
  		$config_data{environments}{$env}{name} = $env;
  	}
  	return;
  }
  
  sub config {
  	return \%config_data;
  }
  
  1;
APP_TASK_CONFIG

$fatpacked{"App/Task/ContentTracker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_CONTENTTRACKER';
  package App::Task::ContentTracker;
  use Moo;
  
  use File::Spec::Functions qw( rel2abs abs2rel );
  use Cwd qw( getcwd );
  use Term::ANSIColor;
  use IO::Interactive qw( is_interactive );
  
  has 'current_branch' => (
  	is => 'rw',
  	lazy => 1,
  	builder => '_build_current_branch',
  	clearer => '_clear_current_branch',
  );
  
  has 'all_branches' => (
  	is => 'ro',
  	lazy => 1,
  	builder => '_build_all_branches',
  	clearer => '_clear_all_branches',
  );
  
  no Moo;
  
  sub get_repository_root {
  	my ($abs_top_level_dir) = App::Task::Base->system_call("git rev-parse --show-toplevel");
  	chomp $abs_top_level_dir;
  	return $abs_top_level_dir;
  }
  
  sub create_deployment_branch {
  	my ($self, $branch) = @_;
  
  	# get the branch name for the task so we can calculate the merge-base
  	my $task_branch_name = $self->get_branch_name($branch);
  
  	# create the deployment branch
  	my $deployment_branch_name = $self->get_next_deployment_branch_name($branch);
  
  	my $mainline_branch = App::Task::Config->config->{mainline_branch};
  	my ($merge_commit) = App::Task::Base->system_call("git merge-base $task_branch_name $mainline_branch", ignore_exit_status => 1);
  
  	$self->_create_branch($deployment_branch_name, $merge_commit);
  
  	return $deployment_branch_name;
  }
  
  sub _create_branch {
  	my ($self, $branch_name, $start_ref) = @_;
  
  	my $mainline_branch = App::Task::Config->config->{mainline_branch};
  	my @branches = @{$self->all_branches};
  
  	if (!$start_ref) {
  		if (scalar grep { /^remotes\/origin\/$mainline_branch/ims } @branches) {
  			$start_ref = "origin/$mainline_branch";
  		} else {
  			$start_ref = $mainline_branch;
  		}
  	}
  
  	# get the original branch (what we're currently on)
  	my $original_branch = $self->get_current_branch;
  	my $current_dir = getcwd;
  
  	if (scalar grep { /^\Q$branch_name/i } @branches) {
  		# check if the branch name exists
  		# and switch to it if it does
  		my ($output) = App::Task::Base->system_call("git checkout $branch_name", combine => 1);
  		print $output;
  	} elsif (scalar grep { /^remotes\/origin\/\Q$branch_name\E$/i } @branches) {
  		# if it exists on origin, then just check that out
  		my ($output) = App::Task::Base->system_call("git checkout --track -b $branch_name origin/$branch_name");
  		print $output;
  	} else {
  		# or create it if it doesn't
  		App::Task::Base->system_call("git checkout --no-track -b $branch_name $start_ref");
  
  		print "Created and switched to branch '$branch_name' from $start_ref\n";
  
  		# set upstream only for task branches off of the mainline
  		if ($start_ref eq "origin/$mainline_branch") {
  			App::Task::Base->system_call("git branch --set-upstream $branch_name $start_ref");
  		}
  	}
  
  	$self->_clear_all_branches;
  	$self->current_branch($branch_name);
  
  	return $branch_name;
  }
  
  sub add_files_to_new_deployment_branch {
  	my ($self, $branch, $files) = @_;
  	die "No branch specified to add files to" if !$branch;
  
  	# get the original branch (what we're currently on)
  	my $original_branch = $self->get_current_branch;
  	my $current_dir = getcwd;
  
  	# get the branch name for the task
  	my $branch_name = $self->create_deployment_branch($branch);
  
  	$self->_add_files_to_branch(
  		source_branch => $original_branch,
  		target_branch => $branch_name,
  		current_dir   => $current_dir,
  		files         => $files,
  	);
  
  	return $branch_name;
  }
  
  sub _add_files_to_branch {
  	my ($self, %args) = @_;
  
  	my $original_branch = $args{source_branch} or die 'no target branch';
  	my $branch_name     = $args{target_branch} or die 'no target branch';
  	my $current_dir     = $args{current_dir} || getcwd;
  	my @files = @{$args{files} || []};
  
  	# change into root dir
  	chdir $self->get_repository_root;
  
  	# merge each file existing on the original branch
  	my $file_list = join(' ', map { "'$_'" } @files);
  
  	# checkout the file to the branch
  	App::Task::Base->system_call("git checkout $original_branch $file_list");
  
  	# and make sure it's committed
  	# and don't bother to run tests since we won't handle it correctly if they fail
  	App::Task::Base->system_call("git commit -n -m \"Added files: $file_list to branch $branch_name from branch $original_branch\"", ignore_exit_status => 1);
  
  	# switch back to the original branch
  	App::Task::Base->system_call("git checkout $original_branch");
  
  	chdir $current_dir;
  
  	if ($original_branch ne $branch_name) {
  		print "Added the following " . (scalar(@files) == 1 ? 'file' : 'files'). " from branch '$original_branch' into branch '$branch_name': $file_list\n";
  	} else {
  		print((scalar(@files) == 1 ? 'File is' : 'Files are') . " already in branch '$branch_name': $file_list\n");
  	}
  }
  
  sub get_deployed_envs {
  	my ($self, $branch_name) = @_;
  
  	# find all the remote branches that contain the current tip of the branch
  	my ($remote_branches) = App::Task::Base->system_call("git branch -r --contains $branch_name");
  
  	my %env_names = map { $_ => 1 } keys %{App::Task::Base->environments};
  
  	my %deployed_envs;
  	for my $raw_branch (split("\n", $remote_branches)) {
  		my ($remote) = $raw_branch =~ / *\*? *origin\/(\w+)$/;
  
  		# skip branches that aren't master branches
  		next if !$remote;
  
  		# skip branches that aren't env remotes
  		next if !exists $env_names{$remote};
  
  		$deployed_envs{$remote} = 1;
  	}
  
  	return \%deployed_envs;
  }
  
  sub get_current_branch {
  	my ($self) = @_;
  	return $self->current_branch;
  }
  
  sub _build_current_branch {
  	my ($self) = @_;
  
  	my ($branches) = App::Task::Base->system_call("git branch");
  	my ($current_branch) = $branches =~ /^\* ([^\n]+)/ims;
  	return $current_branch;
  }
  
  sub _build_all_branches {
  	my ($self) = @_;
  
  	my ($branches) = App::Task::Base->system_call("git branch -a");
  	my @branches;
  	for my $branch (split /^/, $branches) {
  		chomp $branch;
  		$branch =~ s/^(\*?)[ \t]*(.*)[ \t]*$/$2/;
  		$self->current_branch($branch) if $1;
  		push @branches, $branch;
  	}
  
  	return \@branches;
  }
  
  sub unique_branches {
  	my ($self) = @_;
  
  	my (%branches, @branches);
  	for my $branch (@{$self->all_branches}) {
  		my $non_origin_branch = $branch;
  		$non_origin_branch =~ s/^remotes\/origin\///;
  		next if exists $branches{$non_origin_branch};
  
  		$branches{$non_origin_branch} = 1;
  		push @branches, $non_origin_branch;
  	}
  
  	return \@branches;
  }
  
  sub get_branches_by_prefix {
  	my ($self, $prefix) = @_;
  
  	my @branches = @{$self->unique_branches};
  	my @matches = grep { /^\Q$prefix/ } @branches;
  	return @matches;
  }
  
  sub get_branch_name {
  	my ($self, $branch) = @_;
  	if ($branch) {
  		my @existing_branches_matching = $self->get_branches_by_prefix($branch);
  		if (grep { $_ eq $branch } @existing_branches_matching) {
  			# if $branch *is* a branch name, assume that's what they meant, don't complain if there
  			# exist other branches with names that are suffixes of it :)
  			return $branch;
  		}
  
  		# Deploy branches don't count against us for ambiguity, we just want the non-deploy branches.
  		@existing_branches_matching = grep { !/[\/-]deploy\d+$/ } @existing_branches_matching;
  		if (@existing_branches_matching > 1) {
  			die "Ambiguous branch specified $branch:\n", join("\n", map "  $_", @existing_branches_matching);
  		}
  		if (@existing_branches_matching) {
  			return $existing_branches_matching[0];
  		}
  		return $branch;
  	} else {
  		return $self->get_current_branch;
  	}
  }
  
  sub get_next_deployment_branch_name {
  	my ($self, $branch) = @_;
  
  	my @existing = $self->get_all_deployment_branches($branch);
  	my $deployment_branch_count = 0;
  	for my $branch_name (@existing) {
  		if ($branch_name =~ /[\/-]deploy(\d+)$/i) {
  			$deployment_branch_count = $1 if $1 > $deployment_branch_count;
  		}
  	}
  
  	return "$branch-deploy" . ($deployment_branch_count + 1);
  }
  
  sub get_all_deployment_branches {
  	my ($self, $branch) = @_;
  	my @branches = @{ $self->unique_branches };
  	my %deployment_branches;
  	for my $branch_name (@branches) {
  		if ($branch_name =~ /^($branch[\/-]deploy(\d+))/ims) {
  			$deployment_branches{$2} = $1;
  		}
  	}
  	return map { $deployment_branches{$_} } sort { $a <=> $b } keys %deployment_branches;
  }
  
  # return the list of files that have changed between a task branch and an env branch
  sub get_changed_files {
  	my ($self, $branch, $commit_id, %options) = @_;
  
  	my $branch_name;
  	if ($options{branch_name}) {
  		$branch_name = $options{branch_name};
  	} else {
  		$branch_name = $self->get_branch_name($branch);
  	}
  
  	my ($file_list, $error, $exit_status) = App::Task::Base->system_call("git diff --name-only \$(git merge-base $branch_name $commit_id) $branch_name", ignore_exit_status => 1);
  	chomp $file_list;
  
  	my @files = map { s/^\s*|\s*$//ms; $_ } split(/\n/, $file_list);
  	return @files;
  }
  
  # merge a branch and recover from it if it fails
  sub safe_merge {
  	my ($self, $merge_branch_name, $env_name, $target_branch, $options, $action) = @_;
  	my $target_branch_name = App::Task::Base->environments->{$env_name}{branch_name};
  
  	# merge branch into env branch, making sure the branch patch applies
  #	print "git merge $options merge branch name: $merge_branch_name target_branch: $target_branch\n";
  
  	my ($merge_output, $merge_errors, $exit_status) = App::Task::Base->system_call("git merge $options $merge_branch_name", ignore_exit_status => 1);
  	if ($exit_status) {
  
  #		# print any lines that git rerere fixed for us
  #		while ($merge_output =~ /([^\n]*resolution[^\n]*)/ims) {
  #			print "$1\n";
  #		}
  
  		my @bad_files = $self->get_conflicted_files;
  
  #		# git rerere can record merge conflict resolutions and automatically commit them
  #		# so if there aren't any files, rerere probably fixed it?
  #		return if !scalar @bad_files;
  
  		my $remote_task_branch_exclude = '';
  		if ($action eq 're-ready') {
  			print "merging local branch $merge_branch_name into $env_name/$merge_branch_name failed\n";
  			$remote_task_branch_exclude = " ^$target_branch";
  		} elsif ($action eq 'ready') {
  			print "merging local branch $merge_branch_name into origin/$target_branch_name to create $merge_branch_name on $env_name failed\n";
  		} elsif ($action eq 'deploy') {
  			print "merging local branch $merge_branch_name into origin/$target_branch_name failed\n";
  		} else {
  			print "merging local branch $merge_branch_name into $target_branch failed\n";
  		}
  		print "See the entire problem through 'git diff ^origin/$target_branch_name$remote_task_branch_exclude $merge_branch_name'\n";
  		print "This probably means that another task that has been pushed to $env_name conflicts with branch $merge_branch_name. 'git blame' on conflicting files and git branch -r contains <commit_id> for lines with conflicts, should give you enough information to find out which task branch is conflicting. It is recommended to add one branch to the other and make one dependent on the other to make it so you won't have to fix conflicts at every environment deploy\n\n";
  		print "-----------------\n\n";
  
  		print `git diff`;
  
  		print "\n\nHow do you want to resolve this conflict?\n";
  
  		my $response = App::Task::Base->prompt(
  			s       => 'open a shell to fix the merge manually',
  			default => 'reset',
  		);
  
  		eval {
  			if ($response =~ /open a shell/i) {
  				print "Fix your conflict and commit\n";
  				print "Exit shell to finish the deployment\n";
  
  				# note: this is a bash shell inside of the command
  				# exiting the shell will continue the deployment normally
  				system('bash');
  			} else {
  				die "Exiting";
  			}
  
  			my @remaining_bad_files = $self->get_conflicted_files;
  			if (@remaining_bad_files) {
  				die "You didn't fix: @remaining_bad_files\n";
  			}
  			print "conflicts resolved\n";
  		};
  		if ($@) {
  			print "Resetting merge...\n";
  			App::Task::Base->system_call("git reset --merge");
  			# put us back where we started
  			die color('red') . "Can't continue after a failed merge to environment: $env_name\n$@\n" . color('reset');
  		}
  	}
  }
  
  # get a list of files with conflicts
  sub get_conflicted_files {
  	my $self = shift;
  	my $output = `git status -s`;
  	chomp $output;
  	my @files = split("\n",$output);
  
  	my $relative_to_root = `git rev-parse --show-cdup`;
  	chomp $relative_to_root;
  
  	my @conflicted_files;
  	for my $file (@files) {
  		if (my ($path) = $file =~ /^ *U\w+ *(.*)/) {
  			push @conflicted_files, "$relative_to_root$path";
  		}
  	}
  	return @conflicted_files;
  }
  
  sub update_remotes {
  	my ($self) = @_;
  
  	# do our best to only call 'git remote update' once when needed,
  	# since it's a pretty expensive operation and can slow everything down
  	if (App::Task::Config->get_option('needs-update')) {
  		my $msg = "Updating remote git repositories...";
  		print $msg if is_interactive();
  		App::Task::Base->system_call("git remote update --prune");
  		printf("\r%s\r", ' ' x length($msg)) if is_interactive();
  		App::Task::Config->set_option('needs-update' => 0);
  	}
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  B<App::Task::ContentTracker> - module to track branches and other content that should be grouped together
  
  =head1 SYNOPSIS
  
  [quick summary of what the module does]
  
  Usage example:
  
  =over 4
  
  	use App::Task::ContentTracker;
  
  	my $foo = App::Task::ContentTracker->new();
  	...
  
  =back
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item add_files_to_new_task
  
  add specified files to a brand new task
  
  =item get_branch_name
  
  =item get_changed_files
  
  =item get_current_branch
  
  =item get_deployed_envs
  
  =item get_repository_root
  
  =item get_local_branch_start
  
  =item safe_merge
  
  merge safely, meaning merge and if it fails, reset the merge and die
  
  =item get_shared_branch_name
  
  Returns the name of the branch if it has already been deployed to a shared environment
  
  =item add_files_to_new_deployment_branch
  
  add new files to a new deployment branch for individual file deployment
  
  =item create_deployment_branch
  
  create a deployment branch for deploying individual files
  
  =item get_next_deployment_branch_name
  
  return the next deployment branch name. Formatted like <branch-name>-deploy<number>
  
  =item get_all_deployment_branches
  
  return a list of all individual file deployment branches that exist for a task
  
  =item get_conflicted_files
  
  get list of conflicted files
  
  =cut
  
  =back
  
  =cut
APP_TASK_CONTENTTRACKER

$fatpacked{"App/Task/Hooks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_HOOKS';
  package App::Task::Hooks;
  use Moo;
  
  use App::Task::Config;
  
  sub default_env {
    my $config = App::Task::Config->config;
  
    return (
      TASK_REPO_ROOT => $config->{repo_root},
    );
  }
  
  sub find_hooks {
    my ($self, $command, $hook_name) = @_;
    my @hooks;
  
    my $hooks = $command->env->{hooks};
  
    if ($hooks && $hooks->{$hook_name}) {
      push @hooks, @{ $hooks->{$hook_name} };
    }
  
    my $global_hooks = App::Task::Config->config->{hooks};
    if ($global_hooks && $global_hooks->{$hook_name}) {
      push @hooks, @{ $global_hooks->{$hook_name} };
    }
  
    return @hooks;
  }
  
  sub run_hooks {
    my ($self, $command, $hook_name, $env) = @_;
  
    my @hooks = $self->find_hooks($command, $hook_name);
  
    {
      local %ENV = (
        %ENV,
        $self->default_env,
        %{ $env || {} },
      );
      for my $hook (@hooks) {
        my $ok = $self->run_hook($command, $hook_name, $hook);
        if (!$ok) {
          return;
        }
      }
    }
    return 1;
  }
  
  sub run_hook {
    my ($self, $command, $hook_name, $hook) = @_;
  
    my $root = App::Task::Config->config->{repo_root};
    my $hook_path = "$root/$hook";
  
    my $prelude = "Hook '$hook_path' for $hook_name";
  
    if (!-e $hook_path) {
      warn "$prelude doesn't exist, skipping";
      return 1;
    }
  
    if (!-x $hook_path) {
      warn "$prelude isn't executable, skipping";
      return 1;
    }
  
    my $system_ret = system($hook_path);
    if ($system_ret) {
      if ($? == -1) {
        warn "$prelude couldn't be executed: $!";
      } elsif ($? & 127) {
        warn "$prelude exited with signal ", ($? & 127);
      } else {
        warn "$prelude exited with nonzero status ", $? >> 8;
      }
      return 0;
    } else {
      return 1;
    }
  }
  
  1;
APP_TASK_HOOKS

$fatpacked{"Class/Method/Modifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_METHOD_MODIFIERS';
  package Class::Method::Modifiers;
  BEGIN {
    $Class::Method::Modifiers::AUTHORITY = 'cpan:SARTAK';
  }
  {
    $Class::Method::Modifiers::VERSION = '2.08';
  }
  # git description: v2.07-9-g9481a38
  
  use strict;
  use warnings;
  
  # work around https://rt.cpan.org/Ticket/Display.html?id=89173
  use base ('Exp'.'orter');
  
  our @EXPORT = qw(before after around);
  our @EXPORT_OK = (@EXPORT, qw(fresh install_modifier));
  our %EXPORT_TAGS = (
      moose => [qw(before after around)],
      all   => \@EXPORT_OK,
  );
  
  BEGIN {
    *_HAS_READONLY = $] >= 5.008 ? sub(){1} : sub(){0};
  }
  
  our %MODIFIER_CACHE;
  
  # for backward compatibility
  sub _install_modifier; # -w
  *_install_modifier = \&install_modifier;
  
  sub install_modifier {
      my $into  = shift;
      my $type  = shift;
      my $code  = pop;
      my @names = @_;
  
      @names = @{ $names[0] } if ref($names[0]) eq 'ARRAY';
  
      return _fresh($into, $code, @names) if $type eq 'fresh';
  
      for my $name (@names) {
          my $hit = $into->can($name) or do {
              require Carp;
              Carp::confess("The method '$name' is not found in the inheritance hierarchy for class $into");
          };
  
          my $qualified = $into.'::'.$name;
          my $cache = $MODIFIER_CACHE{$into}{$name} ||= {
              before => [],
              after  => [],
              around => [],
          };
  
          # this must be the first modifier we're installing
          if (!exists($cache->{"orig"})) {
              no strict 'refs';
  
              # grab the original method (or undef if the method is inherited)
              $cache->{"orig"} = *{$qualified}{CODE};
  
              # the "innermost" method, the one that "around" will ultimately wrap
              $cache->{"wrapped"} = $cache->{"orig"} || $hit; #sub {
              #    # we can't cache this, because new methods or modifiers may be
              #    # added between now and when this method is called
              #    for my $package (@{ mro::get_linear_isa($into) }) {
              #        next if $package eq $into;
              #        my $code = *{$package.'::'.$name}{CODE};
              #        goto $code if $code;
              #    }
              #    require Carp;
              #    Carp::confess("$qualified\::$name disappeared?");
              #};
          }
  
          # keep these lists in the order the modifiers are called
          if ($type eq 'after') {
              push @{ $cache->{$type} }, $code;
          }
          else {
              unshift @{ $cache->{$type} }, $code;
          }
  
          # wrap the method with another layer of around. much simpler than
          # the Moose equivalent. :)
          if ($type eq 'around') {
              my $method = $cache->{wrapped};
              my $attrs = _sub_attrs($code);
              # a bare "sub :lvalue {...}" will be parsed as a label and an
              # indirect method call. force it to be treated as an expression
              # using +
              $cache->{wrapped} = eval "package $into; +sub $attrs { \$code->(\$method, \@_); };";
          }
  
          # install our new method which dispatches the modifiers, but only
          # if a new type was added
          if (@{ $cache->{$type} } == 1) {
  
              # avoid these hash lookups every method invocation
              my $before  = $cache->{"before"};
              my $after   = $cache->{"after"};
  
              # this is a coderef that changes every new "around". so we need
              # to take a reference to it. better a deref than a hash lookup
              my $wrapped = \$cache->{"wrapped"};
  
              my $attrs = _sub_attrs($cache->{wrapped});
  
              my $generated = "package $into;\n";
              $generated .= "sub $name $attrs {";
  
              # before is easy, it doesn't affect the return value(s)
              if (@$before) {
                  $generated .= '
                      for my $method (@$before) {
                          $method->(@_);
                      }
                  ';
              }
  
              if (@$after) {
                  $generated .= '
                      my $ret;
                      if (wantarray) {
                          $ret = [$$wrapped->(@_)];
                          '.(_HAS_READONLY ? 'Internals::SvREADONLY(@$ret, 1);' : '').'
                      }
                      elsif (defined wantarray) {
                          $ret = \($$wrapped->(@_));
                      }
                      else {
                          $$wrapped->(@_);
                      }
  
                      for my $method (@$after) {
                          $method->(@_);
                      }
  
                      wantarray ? @$ret : $ret ? $$ret : ();
                  '
              }
              else {
                  $generated .= '$$wrapped->(@_);';
              }
  
              $generated .= '}';
  
              no strict 'refs';
              no warnings 'redefine';
              no warnings 'closure';
              eval $generated;
          };
      }
  }
  
  sub before {
      _install_modifier(scalar(caller), 'before', @_);
  }
  
  sub after {
      _install_modifier(scalar(caller), 'after', @_);
  }
  
  sub around {
      _install_modifier(scalar(caller), 'around', @_);
  }
  
  sub fresh {
      my $code = pop;
      my @names = @_;
  
      @names = @{ $names[0] } if ref($names[0]) eq 'ARRAY';
  
      _fresh(scalar(caller), $code, @names);
  }
  
  sub _fresh {
      my ($into, $code, @names) = @_;
  
      for my $name (@names) {
          if ($name !~ /\A [a-zA-Z_] [a-zA-Z0-9_]* \z/xms) {
              require Carp;
              Carp::confess("Invalid method name '$name'");
          }
          if ($into->can($name)) {
              require Carp;
              Carp::confess("Class $into already has a method named '$name'");
          }
  
          # We need to make sure that the installed method has its CvNAME in
          # the appropriate package; otherwise, it would be subject to
          # deletion if callers use namespace::autoclean.  If $code was
          # compiled in the target package, we can just install it directly;
          # otherwise, we'll need a different approach.  Using Sub::Name would
          # be fine in all cases, at the cost of introducing a dependency on
          # an XS-using, non-core module.  So instead we'll use string-eval to
          # create a new subroutine that wraps $code.
          if (_is_in_package($code, $into)) {
              no strict 'refs';
              *{"$into\::$name"} = $code;
          }
          else {
              no warnings 'closure'; # for 5.8.x
              my $attrs = _sub_attrs($code);
              eval "package $into; sub $name $attrs { \$code->(\@_) }";
          }
      }
  }
  
  sub _sub_attrs {
      my ($coderef) = @_;
      local *_sub = $coderef;
      local $@;
      (eval 'sub { _sub = 1 }') ? ':lvalue' : '';
  }
  
  sub _is_in_package {
      my ($coderef, $package) = @_;
      require B;
      my $cv = B::svref_2object($coderef);
      return $cv->GV->STASH->NAME eq $package;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Method::Modifiers - provides Moose-like method modifiers
  
  =head1 SYNOPSIS
  
      package Child;
      use parent 'Parent';
      use Class::Method::Modifiers;
  
      sub new_method { }
  
      before 'old_method' => sub {
          carp "old_method is deprecated, use new_method";
      };
  
      around 'other_method' => sub {
          my $orig = shift;
          my $ret = $orig->(@_);
          return $ret =~ /\d/ ? $ret : lc $ret;
      };
  
      after 'private', 'protected' => sub {
          debug "finished calling a dangerous method";
      };
  
      use Class::Method::Modifiers qw(fresh);
  
      fresh 'not_in_hierarchy' => sub {
          warn "freshly added method\n";
      };
  
  
  =head1 DESCRIPTION
  
  =for stopwords CLOS
  
  Method modifiers are a convenient feature from the CLOS (Common Lisp Object
  System) world.
  
  In its most basic form, a method modifier is just a method that calls
  C<< $self->SUPER::foo(@_) >>. I for one have trouble remembering that exact
  invocation, so my classes seldom re-dispatch to their base classes. Very bad!
  
  C<Class::Method::Modifiers> provides three modifiers: C<before>, C<around>, and
  C<after>. C<before> and C<after> are run just before and after the method they
  modify, but can not really affect that original method. C<around> is run in
  place of the original method, with a hook to easily call that original method.
  See the C<MODIFIERS> section for more details on how the particular modifiers
  work.
  
  One clear benefit of using C<Class::Method::Modifiers> is that you can define
  multiple modifiers in a single namespace. These separate modifiers don't need
  to know about each other. This makes top-down design easy. Have a base class
  that provides the skeleton methods of each operation, and have plugins modify
  those methods to flesh out the specifics.
  
  Parent classes need not know about C<Class::Method::Modifiers>. This means you
  should be able to modify methods in I<any> subclass. See
  L<Term::VT102::ZeroBased> for an example of subclassing with
  C<ClasS::Method::Modifiers>.
  
  In short, C<Class::Method::Modifiers> solves the problem of making sure you
  call C<< $self->SUPER::foo(@_) >>, and provides a cleaner interface for it.
  
  As of version 1.00, C<Class::Method::Modifiers> is faster in some cases than
  L<Moose>. See C<benchmark/method_modifiers.pl> in the L<Moose> distribution.
  
  C<Class::Method::Modifiers> also provides an additional "modifier" type,
  C<fresh>; see below.
  
  =head1 MODIFIERS
  
  =head2 before method(s) => sub { ... }
  
  C<before> is called before the method it is modifying. Its return value is
  totally ignored. It receives the same C<@_> as the method it is modifying
  would have received. You can modify the C<@_> the original method will receive
  by changing C<$_[0]> and friends (or by changing anything inside a reference).
  This is a feature!
  
  =head2 after method(s) => sub { ... }
  
  C<after> is called after the method it is modifying. Its return value is
  totally ignored. It receives the same C<@_> as the method it is modifying
  received, mostly. The original method can modify C<@_> (such as by changing
  C<$_[0]> or references) and C<after> will see the modified version. If you
  don't like this behavior, specify both a C<before> and C<after>, and copy the
  C<@_> during C<before> for C<after> to use.
  
  =head2 around method(s) => sub { ... }
  
  C<around> is called instead of the method it is modifying. The method you're
  overriding is passed in as the first argument (called C<$orig> by convention).
  Watch out for contextual return values of C<$orig>.
  
  You can use C<around> to:
  
  =over 4
  
  =item Pass C<$orig> a different C<@_>
  
      around 'method' => sub {
          my $orig = shift;
          my $self = shift;
          $orig->($self, reverse @_);
      };
  
  =item Munge the return value of C<$orig>
  
      around 'method' => sub {
          my $orig = shift;
          ucfirst $orig->(@_);
      };
  
  =item Avoid calling C<$orig> -- conditionally
  
      around 'method' => sub {
          my $orig = shift;
          return $orig->(@_) if time() % 2;
          return "no dice, captain";
      };
  
  =back
  
  =head2 fresh method(s) => sub { ... };
  
  Unlike the other modifiers, this does not modify an existing method.
  Ordinarily, C<fresh> merely installs the coderef as a method in the
  appropriate class; but if the class hierarchy already contains a method of
  the same name, an exception is thrown.  The idea of this "modifier" is to
  increase safety when subclassing.  Suppose you're writing a subclass of a
  class Some::Base, and adding a new method:
  
      package My::SubclassOf::C;
      use base 'Some::Base';
  
      sub foo { ... }
  
  If a later version of Some::Base also adds a new method named C<foo>, your
  method will shadow that method.  Alternatively, you can use C<fresh>
  to install the additional method into your subclass:
  
      package My::SubclassOf::C;
      use base 'Some::Base';
  
      use Class::Method::Modifiers 'fresh';
  
      fresh 'foo' => sub { ... };
  
  Now upgrading Some::Base to a version with a conflicting C<foo> method will
  cause an exception to be thrown; seeing that error will give you the
  opportunity to fix the problem (perhaps by picking a different method name
  in your subclass, or similar).
  
  Creating fresh methods with C<install_modifier> (see below) provides a way
  to get similar safety benefits when adding local monkeypatches to existing
  classes; see L<http://aaroncrane.co.uk/talks/monkey_patching_subclassing/>.
  
  For API compatibility reasons, this function is exported only when you ask
  for it specifically, or for C<:all>.
  
  =head2 install_modifier $package, $type, @names, sub { ... }
  
  C<install_modifier> is like C<before>, C<after>, C<around>, and C<fresh> but
  it also lets you dynamically select the modifier type ('before', 'after',
  'around', 'fresh')
  and package that the method modifiers are installed into. This expert-level
  function is exported only when you ask for it specifically, or for C<:all>.
  
  =head1 NOTES
  
  All three normal modifiers; C<before>, C<after>, and C<around>; are exported
  into your namespace by default. You may C<use Class::Method::Modifiers ()> to
  avoid thrashing your namespace. I may steal more features from L<Moose>, namely
  C<super>, C<override>, C<inner>, C<augment>, and whatever the L<Moose> folks
  come up with next.
  
  Note that the syntax and semantics for these modifiers is directly borrowed
  from L<Moose> (the implementations, however, are not).
  
  L<Class::Trigger> shares a few similarities with C<Class::Method::Modifiers>,
  and they even have some overlap in purpose -- both can be used to implement
  highly pluggable applications. The difference is that L<Class::Trigger>
  provides a mechanism for easily letting parent classes to invoke hooks defined
  by other code. C<Class::Method::Modifiers> provides a way of
  overriding/augmenting methods safely, and the parent class need not know about
  it.
  
  =head2 :lvalue METHODS
  
  When adding C<before> or C<after> modifiers, the wrapper method will be
  an lvalue method if the wrapped sub is, and assigning to the method
  will propagate to the wrapped method as expected.  For C<around>
  modifiers, it is the modifier sub that determines if the wrapper
  method is an lvalue method.
  
  =head1 CAVEATS
  
  It is erroneous to modify a method that doesn't exist in your class's
  inheritance hierarchy. If this occurs, an exception will be thrown when
  the modifier is defined.
  
  It doesn't yet play well with C<caller>. There are some C<TODO> tests for this.
  Don't get your hopes up though!
  
  Applying modifiers to array lvalue methods is not fully supported. Attempting
  to assign to an array lvalue method that has an C<after> modifier applied will
  result in an error.  Array lvalue methods are not well supported by perl in
  general, and should be avoided.
  
  =head1 VERSION
  
  =for stopwords reimplementation
  
  This module was bumped to 1.00 following a complete reimplementation, to
  indicate breaking backwards compatibility. The "guard" modifier was removed,
  and the internals are completely different.
  
  The new version is a few times faster with half the code. It's now even faster
  than Moose.
  
  Any code that just used modifiers should not change in behavior, except to
  become more correct. And, of course, faster. :)
  
  =head1 SEE ALSO
  
  L<Class::Method::Modifiers::Fast>
  L<Moose>, L<Class::Trigger>, L<Class::MOP::Method::Wrapped>, L<MRO::Compat>,
  CLOS
  
  =head1 AUTHOR
  
  Shawn M Moore, C<sartak@gmail.com>
  
  =head1 ACKNOWLEDGEMENTS
  
  =for stopwords Stevan
  
  Thanks to Stevan Little for L<Moose>, I would never have known about
  method modifiers otherwise.
  
  Thanks to Matt Trout and Stevan Little for their advice.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2009 Shawn M Moore.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
CLASS_METHOD_MODIFIERS

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.12';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Devel/TypeTiny/Perl56Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL56COMPAT';
  package Devel::TypeTiny::Perl56Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  
  #### B doesn't provide perlstring() in 5.6. Monkey patch it.
  
  use B ();
  
  unless (exists &B::perlstring)
  {
  	my $d;
  	*B::perlstring = sub {
  		no warnings 'uninitialized';
  		require Data::Dumper;
  		$d ||= 'Data::Dumper'->new([])->Indent(0)->Purity(0)->Pad('')->Useqq(1)->Terse(1)->Freezer('')->Toaster('');
  		my $perlstring = $d->Values([''.shift])->Dump;
  		($perlstring =~ /^"/) ? $perlstring : qq["$perlstring"];
  	};
  }
  
  push @B::EXPORT_OK, 'perlstring';
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl56Compat - shims to allow Type::Tiny to run on Perl 5.6.x
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<B> to export a
  C<perlstring> function, as this was only added in Perl 5.8.0.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL56COMPAT

$fatpacked{"Devel/TypeTiny/Perl58Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL58COMPAT';
  package Devel::TypeTiny::Perl58Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  
  #### re doesn't provide is_regexp in Perl < 5.10
  
  eval 'require re';
  
  unless (exists &re::is_regexp)
  {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object($_[0])->MAGIC->TYPE eq 'r' };
  	};
  }
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl58Compat - shims to allow Type::Tiny to run on Perl 5.8.x
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<re> to provide a
  C<is_regexp> function, as this was only added in Perl 5.9.5.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL58COMPAT

$fatpacked{"Error/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY';
  package Error::TypeTiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::VERSION   = '0.034';
  }
  
  use overload
  	q[""]    => sub { $_[0]->to_string },
  	q[bool]  => sub { 1 },
  	fallback => 1,
  ;
  
  our %CarpInternal;
  $CarpInternal{$_}++ for qw(
  	Eval::TypeTiny
  	Eval::TypeTiny::Sandbox
  	Exporter::Tiny
  	Test::TypeTiny
  	Type::Coercion
  	Type::Coercion::Union
  	Error::TypeTiny
  	Type::Library
  	Type::Params
  	Type::Registry
  	Types::Standard
  	Types::Standard::_Stringable
  	Types::TypeTiny
  	Type::Tiny
  	Type::Tiny::Class
  	Type::Tiny::Duck
  	Type::Tiny::Enum
  	Type::Tiny::Intersection
  	Type::Tiny::Role
  	Type::Tiny::Union
  	Type::Utils
  );
  
  sub new
  {
  	my $class = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	return bless \%params, $class;
  }
  
  sub throw
  {
  	my $class = shift;
  	
  	my ($level, @caller, %ctxt) = 0;
  	while (
  		defined scalar caller($level) and $CarpInternal{scalar caller($level)}
  	) { $level++ };
  	if ( ((caller($level - 1))[1]||"") =~ /^parameter validation for '(.+?)'$/ )
  	{
  		my ($pkg, $func) = ($1 =~ m{^(.+)::(\w+)$});
  		$level++ if caller($level) eq ($pkg||"");
  	}
  	@ctxt{qw/ package file line /} = caller($level);
  	
  	my $stack = undef;
  	if (our $StackTrace)
  	{
  		require Devel::StackTrace;
  		$stack = "Devel::StackTrace"->new(
  			ignore_package => [ keys %CarpInternal ],
  		);
  	}
  	
  	die(
  		our $LastError = $class->new(
  			context     => \%ctxt,
  			stack_trace => $stack,
  			@_,
  		)
  	);
  }
  
  sub message     { $_[0]{message} ||= $_[0]->_build_message };
  sub context     { $_[0]{context} };
  sub stack_trace { $_[0]{stack_trace} };
  
  sub to_string
  {
  	my $e = shift;
  	my $c = $e->context;
  	my $m = $e->message;
  	
  	$m =~ /\n\z/s ? $m :
  	$c            ? sprintf("%s at %s line %s.\n", $m, $c->{file}||'file?', $c->{line}||'NaN') :
  	sprintf("%s\n", $m);
  }
  
  sub _build_message
  {
  	return 'An exception has occurred';
  }
  
  sub croak
  {
  	my ($fmt, @args) = @_;
  	@_ = (
  		__PACKAGE__,
  		message => sprintf($fmt, @args),
  	);
  	goto \&throw;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny - exceptions for Type::Tiny and friends
  
  =head1 SYNOPSIS
  
     use Data::Dumper;
     use Try::Tiny;
     use Types::Standard qw(Str);
     
     try {
        Str->assert_valid(undef);
     }
     catch {
        my $exception = shift;
        warn "Encountered Error: $exception";
        warn Dumper($exception->explain)
           if $exception->isa("Error::TypeTiny::Assertion");
     };
  
  =head1 DESCRIPTION
  
  When Type::Tiny and its related modules encounter an error, they throw an
  exception object. These exception objects inherit from Error::TypeTiny.
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< throw(%attributes) >>
  
  Constructs an exception and passes it to C<die>.
  
  Automatically populates C<context> and C<stack_trace> if appropriate.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<message>
  
  The error message.
  
  =item C<context>
  
  Hashref containing the package, file and line that generated the error.
  
  =item C<stack_trace>
  
  A more complete stack trace. This feature requires L<Devel::StackTrace>;
  use the C<< $StackTrace >> package variable to switch it on.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<to_string>
  
  Returns the message, followed by the context if it is set.
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< Error::TypeTiny::croak($format, @args) >>
  
  Functional-style shortcut to C<throw> method. Takes an C<sprintf>-style
  format string and optional arguments to construct the C<message>.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to call C<to_string>.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< %Error::TypeTiny::CarpInternal >>
  
  Serves a similar purpose to C<< %Carp::CarpInternal >>.
  
  =item C<< $Error::TypeTiny::StackTrace >>
  
  Boolean to toggle stack trace generation.
  
  =item C<< $Error::TypeTiny::LastError >>
  
  A reference to the last exception object thrown.
  
  =back
  
  =head1 CAVEATS
  
  Although Error::TypeTiny objects are thrown for errors produced by
  Type::Tiny, that doesn't mean every time you use Type::Tiny you'll get
  Error::TypeTinys whenever you want.
  
  For example, if you use a Type::Tiny type constraint in a Moose attribute,
  Moose will not call the constraint's C<assert_valid> method (which throws
  an exception). Instead it will call C<check> and C<get_message> (which do
  not), and will C<confess> an error message of its own. (The C<< $LastError >>
  package variable may save your bacon.)
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>,
  L<Error::TypeTiny::WrongNumberOfParameters>.
  
  L<Try::Tiny>, L<Try::Tiny::ByClass>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY

$fatpacked{"Error/TypeTiny/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_ASSERTION';
  package Error::TypeTiny::Assertion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Error::TypeTiny::Assertion::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Assertion::VERSION   = '0.034';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub type               { $_[0]{type} };
  sub value              { $_[0]{value} };
  sub varname            { $_[0]{varname} ||= '$_' };
  sub attribute_step     { $_[0]{attribute_step} };
  sub attribute_name     { $_[0]{attribute_name} };
  
  sub has_type           { defined $_[0]{type} }; # sic
  sub has_attribute_step { exists $_[0]{attribute_step} };
  sub has_attribute_name { exists $_[0]{attribute_name} };
  
  sub new
  {
  	my $class = shift;
  	my $self  = $class->SUPER::new(@_);
  	
  	if (ref $Method::Generate::Accessor::CurrentAttribute)
  	{
  		require B;
  		my %d = %{$Method::Generate::Accessor::CurrentAttribute};
  		$self->{attribute_name} = $d{name} if defined $d{name};
  		$self->{attribute_step} = $d{step} if defined $d{step};
  		
  		if (defined $d{init_arg})
  		{
  			$self->{varname} = sprintf('$args->{%s}', B::perlstring($d{init_arg}));
  		}
  		elsif (defined $d{name})
  		{
  			$self->{varname} = sprintf('$self->{%s}', B::perlstring($d{name}));
  		}
  	}
  	
  	return $self;
  }
  
  sub message
  {
  	my $e = shift;
  	$e->varname eq '$_'
  		? $e->SUPER::message
  		: sprintf('%s (in %s)', $e->SUPER::message, $e->varname);
  }
  
  sub _build_message
  {
  	my $e = shift;
  	$e->has_type
  		? sprintf('%s did not pass type constraint "%s"', Type::Tiny::_dd($e->value), $e->type)
  		: sprintf('%s did not pass type constraint', Type::Tiny::_dd($e->value))
  }
  
  *to_string = sub
  {
  	my $e = shift;
  	my $msg = $e->message;
  	
  	my $c = $e->context;
  	$msg .= sprintf(" at %s line %s", $c->{file}||'file?', $c->{line}||'NaN') if $c;
  	
  	my $explain = $e->explain;
  	return $msg unless @{ $explain || [] };
  	
  	$msg .= "\n";
  	for my $line (@$explain) {
  		$msg .= "    $line\n";
  	}
  	
  	return $msg;
  } if $] >= 5.008;
  
  sub explain
  {
  	my $e = shift;
  	return undef unless $e->has_type;
  	$e->type->validate_explain($e->value, $e->varname);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Assertion - exception when a value fails a type constraint
  
  =head1 DESCRIPTION
  
  This exception is thrown when a value fails a type constraint assertion.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type>
  
  The type constraint that was checked against. Weakened links are involved,
  so this may end up being C<undef>.
  
  =item C<value>
  
  The value that was tested.
  
  =item C<varname>
  
  The name of the variable that was checked, if known. Defaults to C<< '$_' >>.
  
  =item C<attribute_name>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will tell you which attribute (if
  your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =item C<attribute_step>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will contain either C<< "isa check" >>
  or C<< "coercion" >> to indicate which went wrong (if your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_type>, C<has_attribute_name>, C<has_attribute_step>
  
  Predicate methods.
  
  =item C<message>
  
  Overridden to add C<varname> to the message if defined.
  
  =item C<explain>
  
  Attempts to explain why the value did not pass the type constraint. Returns
  an arrayref of strings providing step-by-step reasoning; or returns undef if
  no explanation is possible.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_ASSERTION

$fatpacked{"Error/TypeTiny/Compilation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_COMPILATION';
  package Error::TypeTiny::Compilation;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::Compilation::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Compilation::VERSION   = '0.034';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub code        { $_[0]{code} };
  sub environment { $_[0]{environment} ||= {} };
  sub errstr      { $_[0]{errstr} };
  
  sub _build_message
  {
  	my $self = shift;
  	sprintf("Failed to compile source because: %s", $self->errstr);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Compilation - exception for Eval::TypeTiny
  
  =head1 DESCRIPTION
  
  Thrown when compiling a closure fails. Common causes are problems with
  inlined type constraints, and syntax errors when coercions are given as
  strings of Perl code.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<code>
  
  The Perl source code being compiled.
  
  =item C<environment>
  
  Hashref of variables being closed over.
  
  =item C<errstr>
  
  Error message from Perl compiler.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_COMPILATION

$fatpacked{"Error/TypeTiny/WrongNumberOfParameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS';
  package Error::TypeTiny::WrongNumberOfParameters;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::WrongNumberOfParameters::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::WrongNumberOfParameters::VERSION   = '0.034';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub minimum    { $_[0]{minimum} };
  sub maximum    { $_[0]{maximum} };
  sub got        { $_[0]{got} };
  
  sub has_minimum { exists $_[0]{minimum} };
  sub has_maximum { exists $_[0]{maximum} };
  
  sub _build_message
  {
  	my $e = shift;
  	if ($e->has_minimum and $e->has_maximum and $e->minimum == $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	elsif ($e->has_minimum and $e->has_maximum and $e->minimum < $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d to %d",
  			$e->got,
  			$e->minimum,
  			$e->maximum,
  		);
  	}
  	elsif ($e->has_minimum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected at least %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	else
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d",
  			$e->got,
  		);
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::WrongNumberOfParameters - exception for Type::Params
  
  =head1 DESCRIPTION
  
  Thrown when a Type::Params compiled check is called with the wrong number
  of parameters.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<minimum>
  
  The minimum expected number of parameters.
  
  =item C<maximum>
  
  The maximum expected number of parameters.
  
  =item C<got>
  
  The number of parameters actually passed to the compiled check.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_minimum>, C<has_maximum>
  
  Predicate methods.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS

$fatpacked{"Eval/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_TYPETINY';
  package Eval::TypeTiny;
  
  use strict;
  
  BEGIN {
  	*HAS_LEXICAL_SUBS = ($] >= 5.018) ? sub(){!!1} : sub(){!!0};
  };
  
  {
  	my $hlv;
  	sub HAS_LEXICAL_VARS () {
  		$hlv = !! eval { require Devel::LexAlias } unless defined $hlv;
  		return $hlv;
  	}
  }
  
  sub _clean_eval
  {
  	local $@;
  	local $SIG{__DIE__};
  	my $r = eval $_[0];
  	my $e = $@;
  	return ($r, $e);
  }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  our @EXPORT    = qw( eval_closure );
  our @EXPORT_OK = qw( HAS_LEXICAL_SUBS HAS_LEXICAL_VARS );
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  use warnings;
  
  sub eval_closure
  {
  	my (%args) = @_;
  	my $src    = ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source};
  	
  	$args{alias}  = 0 unless defined $args{alias};
  	$args{line}   = 1 unless defined $args{line};
  	$args{description} =~ s/[^\w .:-\[\]\(\)\{\}\']//g if defined $args{description};
  	$src = qq{#line $args{line} "$args{description}"\n$src} if defined $args{description} && !($^P & 0x10);
  	$args{environment} ||= {};
  	
  #	for my $k (sort keys %{$args{environment}})
  #	{
  #		next if $k =~ /^\$/ && ref($args{environment}{$k}) =~ /^(SCALAR|REF)$/;
  #		next if $k =~ /^\@/ && ref($args{environment}{$k}) eq q(ARRAY);
  #		next if $k =~ /^\%/ && ref($args{environment}{$k}) eq q(HASH);
  #		
  #		require Error::TypeTiny;
  #		Error::TypeTiny::croak("Expected a variable name and ref; got %s => %s", $k, $args{environment}{$k});
  #	}
  	
  	my $sandpkg   = 'Eval::TypeTiny::Sandbox';
  	my $alias     = exists($args{alias}) ? $args{alias} : 0;
  	my @keys      = sort keys %{$args{environment}};
  	my $i         = 0;
  	my $source    = join "\n" => (
  		"package $sandpkg;",
  		"sub {",
  		map(_make_lexical_assignment($_, $i++, $alias), @keys),
  		$src,
  		"}",
  	);
  	
  	_manufacture_ties() if $alias && !HAS_LEXICAL_VARS;
  	
  	my ($compiler, $e) = _clean_eval($source);
  	if ($e)
  	{
  		chomp $e;
  		require Error::TypeTiny::Compilation;
  		"Error::TypeTiny::Compilation"->throw(
  			code        => (ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source}),
  			errstr      => $e,
  			environment => $args{environment},
  		);
  	}
  	
  	my $code = $compiler->(@{$args{environment}}{@keys});
  	undef($compiler);
  
  	if ($alias && HAS_LEXICAL_VARS) {
  		Devel::LexAlias::lexalias($code, $_, $args{environment}{$_}) for grep !/^\&/, @keys;
  	}
  	
  	return $code;
  }
  
  my $tmp;
  sub _make_lexical_assignment
  {
  	my ($key, $index, $alias) = @_;
  	my $name = substr($key, 1);
  	
  	if (HAS_LEXICAL_SUBS and $key =~ /^\&/) {
  		$tmp++;
  		my $tmpname = '$__LEXICAL_SUB__'.$tmp;
  		return
  			"no warnings 'experimental::lexical_subs';".
  			"use feature 'lexical_subs';".
  			"my $tmpname = \$_[$index];".
  			"my sub $name { goto $tmpname };";
  	}
  	
  	if (!$alias) {
  		my $sigil = substr($key, 0, 1);
  		return "my $key = $sigil\{ \$_[$index] };";
  	}
  	elsif (HAS_LEXICAL_VARS) {
  		return "my $key;";
  	}
  	else {
  		my $tieclass = {
  			'@' => 'Eval::TypeTiny::_TieArray',
  			'%' => 'Eval::TypeTiny::_TieHash',
  			'$' => 'Eval::TypeTiny::_TieScalar',
  		}->{ substr($key, 0, 1) };
  		
  		return sprintf(
  			'tie(my(%s), "%s", $_[%d]);',
  			$key,
  			$tieclass,
  			$index,
  		);
  	}
  }
  
  { my $tie; sub _manufacture_ties { $tie ||= eval <<'FALLBACK'; } }
  no warnings qw(void once uninitialized numeric);
  
  {
  	package #
  		Eval::TypeTiny::_TieArray;
  	require Tie::Array;
  	our @ISA = qw( Tie::StdArray );
  	sub TIEARRAY {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(@$self) and return tied(@$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(@$self) and tied(@$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied @{$_[0]} },
  		q[""]    => sub { '' . tied @{$_[0]} },
  		q[0+]    => sub { 0  + tied @{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieHash;
  	require Tie::Hash;
  	our @ISA = qw( Tie::StdHash );
  	sub TIEHASH {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(%$self) and return tied(%$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(%$self) and tied(%$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied %{$_[0]} },
  		q[""]    => sub { '' . tied %{$_[0]} },
  		q[0+]    => sub { 0  + tied %{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieScalar;
  	require Tie::Scalar;
  	our @ISA = qw( Tie::StdScalar );
  	sub TIESCALAR {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied($$self) and return tied($$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied($$self) and tied($$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied ${$_[0]} },
  		q[""]    => sub { '' . tied ${$_[0]} },
  		q[0+]    => sub { 0  + tied ${$_[0]} },
  		fallback => 1,
  	;
  }
  
  1;
  FALLBACK
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Eval::TypeTiny - utility to evaluate a string of Perl code in a clean environment
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  =head2 Functions
  
  This module exports one function, which works much like the similarly named
  function from L<Eval::Closure>:
  
  =over
  
  =item C<< eval_closure(source => $source, environment => \%env, %opt) >>
  
  =back
  
  =head2 Constants
  
  The following constants may be exported, but are not by default.
  
  =over
  
  =item C<< HAS_LEXICAL_SUBS >>
  
  Boolean indicating whether Eval::TypeTiny has support for lexical subs.
  (This feature requires Perl 5.18.)
  
  =item C<< HAS_LEXICAL_VARS >>
  
  Don't worry; closing over lexical variables in the closures is always
  supported! However, if this constant is true, it means that
  L<Devel::LexAlias> is available, which makes them slightly faster than
  the fallback solution which uses tied variables. (This only makes any
  difference when the C<< alias => 1 >> option is used.)
  
  =back
  
  =head1 EVALUATION ENVIRONMENT
  
  The evaluation is performed in the presence of L<strict>, but the absence of
  L<warnings>. (This is different to L<Eval::Closure> which enables warnings for
  compiled closures.)
  
  The L<feature> pragma is not active in the evaluation environment, so the
  following will not work:
  
     use feature qw(say);
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { say for @_ }',
     );
     $say_all->("Hello", "World");
  
  The L<feature> pragma does not "carry over" into the stringy eval. It is
  of course possible to import pragmas into the evaluated string as part of the
  string itself:
  
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { use feature qw(say); say for @_ }',
     );
     $say_all->("Hello", "World");
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Eval::Closure>, L<Error::TypeTiny::Compilation>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EVAL_TYPETINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.030';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  
  sub import
  {
  	my $class       = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	my @args        = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts        = mkopt(\@args);
  	
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	my @want;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		$name =~ /^[:-](.+)$/
  			? push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts))
  			: push(@want, $opt);
  	}
  	
  	$class->_exporter_validate_opts($global_opts);
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	
  	for my $wanted (@want)
  	{
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  # Called once per import, passed the "global" import options. Expected to
  # validate the import options and carp or croak if there are problems. Can
  # also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts
  {
  	1;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return map [$_ => $value], $tags->{$name}->($class, @_)
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return map [$_ => $value], @{$tags->{$name}}
  		if exists $tags->{$name};
  	
  	return map [$_ => $value], @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"}
  		if $name eq 'all';
  	
  	return map [$_ => $value], @{"$class\::EXPORT"}
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	_croak("Could not find sub '$name' to export in package '$class'");
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name = $value->{-as} || $name;
  	unless (ref($name) eq q(SCALAR))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return $installer->($globals, [$name, $sym]) if $installer;
  	return ($$name = $sym)                       if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym)               if ref($into) eq q(HASH);
  	
  	require B;
  	for (grep ref, $into->can($name))
  	{
  		my $stash = B::svref_2object($_)->STASH;
  		next unless $stash->can("NAME");
  		$stash->NAME eq $into
  			and _croak("Refusing to overwrite local sub '$name' with export from $class");
  	}
  	
  	no strict qw(refs);
  	*{"$into\::$name"} = $sym;
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { my $n = shift; ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installler >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  Exporter::Tiny performs most of its internal duties (including resolution
  of tag names to sub names, resolution of sub names to coderefs, and
  installation of coderefs into the target package) as method calls, which
  means they can be overridden to provide interesting behaviour.
  
  =head2 Utility Functions
  
  These are really for internal use, but can be exported if you need them.
  
  =over
  
  =item C<< mkopt(\@array) >>
  
  Similar to C<mkopt> from L<Data::OptList>. It doesn't support all the
  fancy options that Data::OptList does (C<moniker>, C<require_unique>,
  C<must_be> and C<name_test>) but runs about 50% faster.
  
  =item C<< mkopt_hash(\@array) >>
  
  Similar to C<mkopt_hash> from L<Data::OptList>. See also C<mkopt>.
  
  =back
  
  =head1 TIPS AND TRICKS IMPORTING FROM EXPORTER::TINY
  
  For the purposes of this discussion we'll assume we have a module called
  C<< MyUtils >> which exports one function, C<< frobnicate >>. C<< MyUtils >>
  inherits from Exporter::Tiny.
  
  Many of these tricks may seem familiar from L<Sub::Exporter>. That is
  intentional. Exporter::Tiny doesn't attempt to provide every feature of
  Sub::Exporter, but where it does it usually uses a fairly similar API.
  
  =head2 Basic importing
  
     # import "frobnicate" function
     use MyUtils "frobnicate";
  
     # import all functions that MyUtils offers
     use MyUtils -all;
  
  =head2 Renaming imported functions
  
     # call it "frob"
     use MyUtils "frobnicate" => { -as => "frob" };
  
     # call it "my_frobnicate"
     use MyUtils "frobnicate" => { -prefix => "my_" };
  
     # call it "frobnicate_util"
     use MyUtils "frobnicate" => { -suffix => "_util" };
  
     # import it twice with two different names
     use MyUtils
        "frobnicate" => { -as => "frob" },
        "frobnicate" => { -as => "frbnct" };
  
  =head2 Lexical subs
  
     {
        use Sub::Exporter::Lexical lexical_installer => { -as => "lex" };
        use MyUtils { installer => lex }, "frobnicate";
        
        frobnicate(...);  # ok
     }
     
     frobnicate(...);  # not ok
  
  =head2 Import functions into another package
  
     use MyUtils { into => "OtherPkg" }, "frobnicate";
     
     OtherPkg::frobincate(...);
  
  =head2 Import functions into a scalar
  
     my $func;
     use MyUtils "frobnicate" => { -as => \$func };
     
     $func->(...);
  
  =head2 Import functions into a hash
  
  OK, Sub::Exporter doesn't do this...
  
     my %funcs;
     use MyUtils { into => \%funcs }, "frobnicate";
     
     $funcs{frobnicate}->(...);
  
  =head1 TIPS AND TRICKS EXPORTING USING EXPORTER::TINY
  
  Simple configuration works the same as L<Exporter>; inherit from this module,
  and use the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables to list subs to export.
  
  =head2 Generators
  
  Exporter::Tiny has always allowed exported subs to be generated (like
  L<Sub::Exporter>), but until version 0.025 did not have an especially nice
  API for it.
  
  Now, it's easy. If you want to generate a sub C<foo> to export, list it in
  C<< @EXPORT >> or C<< @EXPORT_OK >> as usual, and then simply give your
  exporter module a class method called C<< _generate_foo >>.
  
     push @EXPORT_OK, 'foo';
     
     sub _generate_foo {
        my $class = shift;
        my ($name, $args, $globals) = @_;
        
        return sub {
           ...;
        }
     }
  
  You can also generate tags:
  
     my %constants = (FOO => 1, BAR => 2);
     use constant \%constants;
     
     $EXPORT_TAGS{constants} = sub {
        my $class = shift;
        my ($name, $args, $globals) = @_;
        
        return keys(%constants);
     };
  
  =head2 Overriding Internals
  
  An important difference between L<Exporter> and Exporter::Tiny is that
  the latter calls all its internal functions as I<< class methods >>. This
  means that your subclass can I<< override them >> to alter their behaviour.
  
  The following methods are available to be overridden. Despite being named
  with a leading underscore, they are considered public methods. (The underscore
  is there to avoid accidentally colliding with any of your own function names.)
  
  =over
  
  =item C<< _exporter_validate_opts($globals) >>
  
  This method is called once each time C<import> is called. It is passed a
  reference to the global options hash. (That is, the optional leading hashref
  in the C<use> statement, where the C<into> and C<installer> options can be
  provided.)
  
  You may use this method to munge the global options, or validate them,
  throwing an exception or printing a warning.
  
  The default implementation does nothing interesting.
  
  =item C<< _exporter_expand_tag($name, $args, $globals) >>
  
  This method is called to expand an import tag (e.g. C<< ":constants" >>).
  It is passed the tag name (minus the leading ":"), an optional hashref
  of options (like C<< { -prefix => "foo_" } >>), and the global options
  hashref.
  
  It is expected to return a list of ($name, $args) arrayref pairs. These
  names can be sub names to export, or further tag names (which must have
  their ":"). If returning tag names, be careful to avoid creating a tag
  expansion loop!
  
  The default implementation uses C<< %EXPORT_TAGS >> to expand tags, and
  provides fallbacks for the C<< :default >> and C<< :all >> tags.
  
  =item C<< _exporter_expand_sub($name, $args, $globals) >>
  
  This method is called to translate a sub name to a hash of name => coderef
  pairs for exporting to the caller. In general, this would just be a hash with
  one key and one value, but, for example, L<Type::Library> overrides this
  method so that C<< "+Foo" >> gets expanded to:
  
     (
        Foo         => sub { $type },
        is_Foo      => sub { $type->check(@_) },
        to_Foo      => sub { $type->assert_coerce(@_) },
        assert_Foo  => sub { $type->assert_return(@_) },
     )
  
  The default implementation checks that the name is allowed to be exported
  (using the C<_exporter_permitted_regexp> method), gets the coderef using
  the generator if there is one (or by calling C<< can >> on your exporter
  otherwise) and calls C<_exporter_fail> if it's unable to generate or
  retrieve a coderef.
  
  =item C<< _exporter_permitted_regexp($globals) >>
  
  This method is called to retrieve a regexp for validating the names of
  exportable subs. If a sub doesn't match the regexp, then the default
  implementation of C<_exporter_expand_sub> will refuse to export it. (Of
  course, you may override the default C<_exporter_expand_sub>.)
  
  The default implementation of this method assembles the regexp from
  C<< @EXPORT >> and C<< @EXPORT_OK >>.
  
  =item C<< _exporter_fail($name, $args, $globals) >>
  
  Called by C<_exporter_expand_sub> if it can't find a coderef to export.
  
  The default implementation just throws an exception. But you could emit
  a warning instead, or just ignore the failed export.
  
  If you don't throw an exception then you should be aware that this
  method is called in list context, and any list it returns will be treated
  as an C<_exporter_expand_sub>-style hash of names and coderefs for
  export.
  
  =item C<< _exporter_install_sub($name, $args, $globals, $coderef) >>
  
  This method actually installs the exported sub into its new destination.
  Its return value is ignored.
  
  The default implementation handles sub renaming (i.e. the C<< -as >>,
  C<< -prefix >> and C<< -suffix >> functions. This method does a lot of
  stuff; if you need to override it, it's probably a good idea to just
  pre-process the arguments and then call the super method rather than
  trying to handle all of it yourself.
  
  =back
  
  =head1 HISTORY
  
  L<Type::Library> had a bunch of custom exporting code which poked coderefs
  into its caller's stash. It needed this to be something more powerful than
  most exporters so that it could switch between exporting Moose, Mouse and
  Moo-compatible objects on request. L<Sub::Exporter> would have been capable,
  but had too many dependencies for the Type::Tiny project.
  
  Meanwhile L<Type::Utils>, L<Types::TypeTiny> and L<Test::TypeTiny> each
  used the venerable L<Exporter.pm|Exporter>. However, this meant they were
  unable to use the features like L<Sub::Exporter>-style function renaming
  which I'd built into Type::Library:
  
     ## import "Str" but rename it to "String".
     use Types::Standard "Str" => { -as => "String" };
  
  And so I decided to factor out code that could be shared by all Type-Tiny's
  exporters into a single place: L<Exporter::TypeTiny>.
  
  As of version 0.026, L<Exporter::TypeTiny> was also made available as
  L<Exporter::Tiny>, distributed independently on CPAN. CHOCOLATEBOY had
  convinced me that it was mature enough to live a life of its own.
  
  As of version 0.030, Type-Tiny depends on Exporter::Tiny and
  L<Exporter::TypeTiny> is being phased out.
  
  =head1 OBLIGATORY EXPORTER COMPARISON
  
  Exporting is unlikely to be your application's performance bottleneck, but
  nonetheless here are some comparisons.
  
  B<< Comparative sizes according to L<Devel::SizeMe>: >>
  
     Exporter                     217.1Kb
     Sub::Exporter::Progressive   263.2Kb
     Exporter::Tiny               267.7Kb
     Exporter + Exporter::Heavy   281.5Kb
     Exporter::Renaming           406.2Kb
     Sub::Exporter                701.0Kb
  
  B<< Performance exporting a single sub: >>
  
                Rate     SubExp    ExpTiny SubExpProg      ExpPM
  SubExp      2489/s         --       -56%       -85%       -88%
  ExpTiny     5635/s       126%         --       -67%       -72%
  SubExpProg 16905/s       579%       200%         --       -16%
  ExpPM      20097/s       707%       257%        19%         --
  
  (Exporter::Renaming globally changes the behaviour of Exporter.pm, so could
  not be included in the same benchmarks.)
  
  B<< (Non-Core) Dependencies: >>
  
     Exporter                    -1
     Exporter::Renaming           0
     Exporter::Tiny               0
     Sub::Exporter::Progressive   0
     Sub::Exporter                3
  
  B<< Features: >>
  
                                        ExpPM   ExpTiny SubExp  SubExpProg
   Can export code symbols............. Yes     Yes     Yes     Yes      
   Can export non-code symbols......... Yes                              
   Groups/tags......................... Yes     Yes     Yes     Yes      
   Config avoids package variables.....                 Yes              
   Allows renaming of subs.............         Yes     Yes     Maybe    
   Install code into scalar refs.......         Yes     Yes     Maybe    
   Can be passed an "into" parameter...         Yes     Yes     Maybe    
   Can be passed an "installer" sub....         Yes     Yes     Maybe    
   Supports generators.................         Yes     Yes              
   Sane API for generators.............         Yes     Yes              
  
  (Certain Sub::Exporter::Progressive features are only available if
  Sub::Exporter is installed.)
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  L<Exporter::TypeTiny>,
  L<Sub::Exporter>,
  L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"Exporter/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TYPETINY';
  package Exporter::TypeTiny;
  require Exporter::Tiny;
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  our @ISA       = 'Exporter::Tiny';
  our @EXPORT_OK = qw| mkopt mkopt_hash _croak |;
  *import        = \&Exporter::Tiny::import;
  *mkopt         = \&Exporter::Tiny::mkopt;
  *mkopt_hash    = \&Exporter::Tiny::mkopt_hash;
  *_croak        = \&Exporter::Tiny::_croak;
  1;
EXPORTER_TYPETINY

$fatpacked{"File/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_TEMP';
  package File::Temp;
  # ABSTRACT: return name and handle of a temporary file safely
  our $VERSION = '0.2304'; # VERSION
  
  
  # Toolchain targets v5.8.1, but we'll try to support back to v5.6 anyway.
  # It might be possible to make this v5.5, but many v5.6isms are creeping
  # into the code and tests.
  use 5.006;
  use strict;
  use Carp;
  use File::Spec 0.8;
  use Cwd ();
  use File::Path 2.06 qw/ rmtree /;
  use Fcntl 1.03;
  use IO::Seekable;               # For SEEK_*
  use Errno;
  use Scalar::Util 'refaddr';
  require VMS::Stdio if $^O eq 'VMS';
  
  # pre-emptively load Carp::Heavy. If we don't when we run out of file
  # handles and attempt to call croak() we get an error message telling
  # us that Carp::Heavy won't load rather than an error telling us we
  # have run out of file handles. We either preload croak() or we
  # switch the calls to croak from _gettemp() to use die.
  eval { require Carp::Heavy; };
  
  # Need the Symbol package if we are running older perl
  require Symbol if $] < 5.006;
  
  ### For the OO interface
  use parent 0.221 qw/ IO::Handle IO::Seekable /;
  use overload '""' => "STRINGIFY", '0+' => "NUMIFY",
    fallback => 1;
  
  # use 'our' on v5.6.0
  use vars qw(@EXPORT_OK %EXPORT_TAGS $DEBUG $KEEP_ALL);
  
  $DEBUG = 0;
  $KEEP_ALL = 0;
  
  # We are exporting functions
  
  use Exporter 5.57 'import';   # 5.57 lets us import 'import'
  
  # Export list - to allow fine tuning of export table
  
  @EXPORT_OK = qw{
                   tempfile
                   tempdir
                   tmpnam
                   tmpfile
                   mktemp
                   mkstemp
                   mkstemps
                   mkdtemp
                   unlink0
                   cleanup
                   SEEK_SET
                   SEEK_CUR
                   SEEK_END
               };
  
  # Groups of functions for export
  
  %EXPORT_TAGS = (
                  'POSIX' => [qw/ tmpnam tmpfile /],
                  'mktemp' => [qw/ mktemp mkstemp mkstemps mkdtemp/],
                  'seekable' => [qw/ SEEK_SET SEEK_CUR SEEK_END /],
                 );
  
  # add contents of these tags to @EXPORT
  Exporter::export_tags('POSIX','mktemp','seekable');
  
  # This is a list of characters that can be used in random filenames
  
  my @CHARS = (qw/ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                   a b c d e f g h i j k l m n o p q r s t u v w x y z
                   0 1 2 3 4 5 6 7 8 9 _
                 /);
  
  # Maximum number of tries to make a temp file before failing
  
  use constant MAX_TRIES => 1000;
  
  # Minimum number of X characters that should be in a template
  use constant MINX => 4;
  
  # Default template when no template supplied
  
  use constant TEMPXXX => 'X' x 10;
  
  # Constants for the security level
  
  use constant STANDARD => 0;
  use constant MEDIUM   => 1;
  use constant HIGH     => 2;
  
  # OPENFLAGS. If we defined the flag to use with Sysopen here this gives
  # us an optimisation when many temporary files are requested
  
  my $OPENFLAGS = O_CREAT | O_EXCL | O_RDWR;
  my $LOCKFLAG;
  
  unless ($^O eq 'MacOS') {
    for my $oflag (qw/ NOFOLLOW BINARY LARGEFILE NOINHERIT /) {
      my ($bit, $func) = (0, "Fcntl::O_" . $oflag);
      no strict 'refs';
      $OPENFLAGS |= $bit if eval {
        # Make sure that redefined die handlers do not cause problems
        # e.g. CGI::Carp
        local $SIG{__DIE__} = sub {};
        local $SIG{__WARN__} = sub {};
        $bit = &$func();
        1;
      };
    }
    # Special case O_EXLOCK
    $LOCKFLAG = eval {
      local $SIG{__DIE__} = sub {};
      local $SIG{__WARN__} = sub {};
      &Fcntl::O_EXLOCK();
    };
  }
  
  # On some systems the O_TEMPORARY flag can be used to tell the OS
  # to automatically remove the file when it is closed. This is fine
  # in most cases but not if tempfile is called with UNLINK=>0 and
  # the filename is requested -- in the case where the filename is to
  # be passed to another routine. This happens on windows. We overcome
  # this by using a second open flags variable
  
  my $OPENTEMPFLAGS = $OPENFLAGS;
  unless ($^O eq 'MacOS') {
    for my $oflag (qw/ TEMPORARY /) {
      my ($bit, $func) = (0, "Fcntl::O_" . $oflag);
      local($@);
      no strict 'refs';
      $OPENTEMPFLAGS |= $bit if eval {
        # Make sure that redefined die handlers do not cause problems
        # e.g. CGI::Carp
        local $SIG{__DIE__} = sub {};
        local $SIG{__WARN__} = sub {};
        $bit = &$func();
        1;
      };
    }
  }
  
  # Private hash tracking which files have been created by each process id via the OO interface
  my %FILES_CREATED_BY_OBJECT;
  
  # INTERNAL ROUTINES - not to be used outside of package
  
  # Generic routine for getting a temporary filename
  # modelled on OpenBSD _gettemp() in mktemp.c
  
  # The template must contain X's that are to be replaced
  # with the random values
  
  #  Arguments:
  
  #  TEMPLATE   - string containing the XXXXX's that is converted
  #           to a random filename and opened if required
  
  # Optionally, a hash can also be supplied containing specific options
  #   "open" => if true open the temp file, else just return the name
  #             default is 0
  #   "mkdir"=> if true, we are creating a temp directory rather than tempfile
  #             default is 0
  #   "suffixlen" => number of characters at end of PATH to be ignored.
  #                  default is 0.
  #   "unlink_on_close" => indicates that, if possible,  the OS should remove
  #                        the file as soon as it is closed. Usually indicates
  #                        use of the O_TEMPORARY flag to sysopen.
  #                        Usually irrelevant on unix
  #   "use_exlock" => Indicates that O_EXLOCK should be used. Default is true.
  
  # Optionally a reference to a scalar can be passed into the function
  # On error this will be used to store the reason for the error
  #   "ErrStr"  => \$errstr
  
  # "open" and "mkdir" can not both be true
  # "unlink_on_close" is not used when "mkdir" is true.
  
  # The default options are equivalent to mktemp().
  
  # Returns:
  #   filehandle - open file handle (if called with doopen=1, else undef)
  #   temp name  - name of the temp file or directory
  
  # For example:
  #   ($fh, $name) = _gettemp($template, "open" => 1);
  
  # for the current version, failures are associated with
  # stored in an error string and returned to give the reason whilst debugging
  # This routine is not called by any external function
  sub _gettemp {
  
    croak 'Usage: ($fh, $name) = _gettemp($template, OPTIONS);'
      unless scalar(@_) >= 1;
  
    # the internal error string - expect it to be overridden
    # Need this in case the caller decides not to supply us a value
    # need an anonymous scalar
    my $tempErrStr;
  
    # Default options
    my %options = (
                   "open" => 0,
                   "mkdir" => 0,
                   "suffixlen" => 0,
                   "unlink_on_close" => 0,
                   "use_exlock" => 1,
                   "ErrStr" => \$tempErrStr,
                  );
  
    # Read the template
    my $template = shift;
    if (ref($template)) {
      # Use a warning here since we have not yet merged ErrStr
      carp "File::Temp::_gettemp: template must not be a reference";
      return ();
    }
  
    # Check that the number of entries on stack are even
    if (scalar(@_) % 2 != 0) {
      # Use a warning here since we have not yet merged ErrStr
      carp "File::Temp::_gettemp: Must have even number of options";
      return ();
    }
  
    # Read the options and merge with defaults
    %options = (%options, @_)  if @_;
  
    # Make sure the error string is set to undef
    ${$options{ErrStr}} = undef;
  
    # Can not open the file and make a directory in a single call
    if ($options{"open"} && $options{"mkdir"}) {
      ${$options{ErrStr}} = "doopen and domkdir can not both be true\n";
      return ();
    }
  
    # Find the start of the end of the  Xs (position of last X)
    # Substr starts from 0
    my $start = length($template) - 1 - $options{"suffixlen"};
  
    # Check that we have at least MINX x X (e.g. 'XXXX") at the end of the string
    # (taking suffixlen into account). Any fewer is insecure.
  
    # Do it using substr - no reason to use a pattern match since
    # we know where we are looking and what we are looking for
  
    if (substr($template, $start - MINX + 1, MINX) ne 'X' x MINX) {
      ${$options{ErrStr}} = "The template must end with at least ".
        MINX . " 'X' characters\n";
      return ();
    }
  
    # Replace all the X at the end of the substring with a
    # random character or just all the XX at the end of a full string.
    # Do it as an if, since the suffix adjusts which section to replace
    # and suffixlen=0 returns nothing if used in the substr directly
    # and generate a full path from the template
  
    my $path = _replace_XX($template, $options{"suffixlen"});
  
  
    # Split the path into constituent parts - eventually we need to check
    # whether the directory exists
    # We need to know whether we are making a temp directory
    # or a tempfile
  
    my ($volume, $directories, $file);
    my $parent;                   # parent directory
    if ($options{"mkdir"}) {
      # There is no filename at the end
      ($volume, $directories, $file) = File::Spec->splitpath( $path, 1);
  
      # The parent is then $directories without the last directory
      # Split the directory and put it back together again
      my @dirs = File::Spec->splitdir($directories);
  
      # If @dirs only has one entry (i.e. the directory template) that means
      # we are in the current directory
      if ($#dirs == 0) {
        $parent = File::Spec->curdir;
      } else {
  
        if ($^O eq 'VMS') {     # need volume to avoid relative dir spec
          $parent = File::Spec->catdir($volume, @dirs[0..$#dirs-1]);
          $parent = 'sys$disk:[]' if $parent eq '';
        } else {
  
          # Put it back together without the last one
          $parent = File::Spec->catdir(@dirs[0..$#dirs-1]);
  
          # ...and attach the volume (no filename)
          $parent = File::Spec->catpath($volume, $parent, '');
        }
  
      }
  
    } else {
  
      # Get rid of the last filename (use File::Basename for this?)
      ($volume, $directories, $file) = File::Spec->splitpath( $path );
  
      # Join up without the file part
      $parent = File::Spec->catpath($volume,$directories,'');
  
      # If $parent is empty replace with curdir
      $parent = File::Spec->curdir
        unless $directories ne '';
  
    }
  
    # Check that the parent directories exist
    # Do this even for the case where we are simply returning a name
    # not a file -- no point returning a name that includes a directory
    # that does not exist or is not writable
  
    unless (-e $parent) {
      ${$options{ErrStr}} = "Parent directory ($parent) does not exist";
      return ();
    }
    unless (-d $parent) {
      ${$options{ErrStr}} = "Parent directory ($parent) is not a directory";
      return ();
    }
  
    # Check the stickiness of the directory and chown giveaway if required
    # If the directory is world writable the sticky bit
    # must be set
  
    if (File::Temp->safe_level == MEDIUM) {
      my $safeerr;
      unless (_is_safe($parent,\$safeerr)) {
        ${$options{ErrStr}} = "Parent directory ($parent) is not safe ($safeerr)";
        return ();
      }
    } elsif (File::Temp->safe_level == HIGH) {
      my $safeerr;
      unless (_is_verysafe($parent, \$safeerr)) {
        ${$options{ErrStr}} = "Parent directory ($parent) is not safe ($safeerr)";
        return ();
      }
    }
  
  
    # Now try MAX_TRIES time to open the file
    for (my $i = 0; $i < MAX_TRIES; $i++) {
  
      # Try to open the file if requested
      if ($options{"open"}) {
        my $fh;
  
        # If we are running before perl5.6.0 we can not auto-vivify
        if ($] < 5.006) {
          $fh = &Symbol::gensym;
        }
  
        # Try to make sure this will be marked close-on-exec
        # XXX: Win32 doesn't respect this, nor the proper fcntl,
        #      but may have O_NOINHERIT. This may or may not be in Fcntl.
        local $^F = 2;
  
        # Attempt to open the file
        my $open_success = undef;
        if ( $^O eq 'VMS' and $options{"unlink_on_close"} && !$KEEP_ALL) {
          # make it auto delete on close by setting FAB$V_DLT bit
          $fh = VMS::Stdio::vmssysopen($path, $OPENFLAGS, 0600, 'fop=dlt');
          $open_success = $fh;
        } else {
          my $flags = ( ($options{"unlink_on_close"} && !$KEEP_ALL) ?
                        $OPENTEMPFLAGS :
                        $OPENFLAGS );
          $flags |= $LOCKFLAG if (defined $LOCKFLAG && $options{use_exlock});
          $open_success = sysopen($fh, $path, $flags, 0600);
        }
        if ( $open_success ) {
  
          # in case of odd umask force rw
          chmod(0600, $path);
  
          # Opened successfully - return file handle and name
          return ($fh, $path);
  
        } else {
  
          # Error opening file - abort with error
          # if the reason was anything but EEXIST
          unless ($!{EEXIST}) {
            ${$options{ErrStr}} = "Could not create temp file $path: $!";
            return ();
          }
  
          # Loop round for another try
  
        }
      } elsif ($options{"mkdir"}) {
  
        # Open the temp directory
        if (mkdir( $path, 0700)) {
          # in case of odd umask
          chmod(0700, $path);
  
          return undef, $path;
        } else {
  
          # Abort with error if the reason for failure was anything
          # except EEXIST
          unless ($!{EEXIST}) {
            ${$options{ErrStr}} = "Could not create directory $path: $!";
            return ();
          }
  
          # Loop round for another try
  
        }
  
      } else {
  
        # Return true if the file can not be found
        # Directory has been checked previously
  
        return (undef, $path) unless -e $path;
  
        # Try again until MAX_TRIES
  
      }
  
      # Did not successfully open the tempfile/dir
      # so try again with a different set of random letters
      # No point in trying to increment unless we have only
      # 1 X say and the randomness could come up with the same
      # file MAX_TRIES in a row.
  
      # Store current attempt - in principal this implies that the
      # 3rd time around the open attempt that the first temp file
      # name could be generated again. Probably should store each
      # attempt and make sure that none are repeated
  
      my $original = $path;
      my $counter = 0;            # Stop infinite loop
      my $MAX_GUESS = 50;
  
      do {
  
        # Generate new name from original template
        $path = _replace_XX($template, $options{"suffixlen"});
  
        $counter++;
  
      } until ($path ne $original || $counter > $MAX_GUESS);
  
      # Check for out of control looping
      if ($counter > $MAX_GUESS) {
        ${$options{ErrStr}} = "Tried to get a new temp name different to the previous value $MAX_GUESS times.\nSomething wrong with template?? ($template)";
        return ();
      }
  
    }
  
    # If we get here, we have run out of tries
    ${ $options{ErrStr} } = "Have exceeded the maximum number of attempts ("
      . MAX_TRIES . ") to open temp file/dir";
  
    return ();
  
  }
  
  # Internal routine to replace the XXXX... with random characters
  # This has to be done by _gettemp() every time it fails to
  # open a temp file/dir
  
  # Arguments:  $template (the template with XXX),
  #             $ignore   (number of characters at end to ignore)
  
  # Returns:    modified template
  
  sub _replace_XX {
  
    croak 'Usage: _replace_XX($template, $ignore)'
      unless scalar(@_) == 2;
  
    my ($path, $ignore) = @_;
  
    # Do it as an if, since the suffix adjusts which section to replace
    # and suffixlen=0 returns nothing if used in the substr directly
    # Alternatively, could simply set $ignore to length($path)-1
    # Don't want to always use substr when not required though.
    my $end = ( $] >= 5.006 ? "\\z" : "\\Z" );
  
    if ($ignore) {
      substr($path, 0, - $ignore) =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge;
    } else {
      $path =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge;
    }
    return $path;
  }
  
  # Internal routine to force a temp file to be writable after
  # it is created so that we can unlink it. Windows seems to occasionally
  # force a file to be readonly when written to certain temp locations
  sub _force_writable {
    my $file = shift;
    chmod 0600, $file;
  }
  
  
  # internal routine to check to see if the directory is safe
  # First checks to see if the directory is not owned by the
  # current user or root. Then checks to see if anyone else
  # can write to the directory and if so, checks to see if
  # it has the sticky bit set
  
  # Will not work on systems that do not support sticky bit
  
  #Args:  directory path to check
  #       Optionally: reference to scalar to contain error message
  # Returns true if the path is safe and false otherwise.
  # Returns undef if can not even run stat() on the path
  
  # This routine based on version written by Tom Christiansen
  
  # Presumably, by the time we actually attempt to create the
  # file or directory in this directory, it may not be safe
  # anymore... Have to run _is_safe directly after the open.
  
  sub _is_safe {
  
    my $path = shift;
    my $err_ref = shift;
  
    # Stat path
    my @info = stat($path);
    unless (scalar(@info)) {
      $$err_ref = "stat(path) returned no values";
      return 0;
    }
    ;
    return 1 if $^O eq 'VMS';     # owner delete control at file level
  
    # Check to see whether owner is neither superuser (or a system uid) nor me
    # Use the effective uid from the $> variable
    # UID is in [4]
    if ($info[4] > File::Temp->top_system_uid() && $info[4] != $>) {
  
      Carp::cluck(sprintf "uid=$info[4] topuid=%s euid=$> path='$path'",
                  File::Temp->top_system_uid());
  
      $$err_ref = "Directory owned neither by root nor the current user"
        if ref($err_ref);
      return 0;
    }
  
    # check whether group or other can write file
    # use 066 to detect either reading or writing
    # use 022 to check writability
    # Do it with S_IWOTH and S_IWGRP for portability (maybe)
    # mode is in info[2]
    if (($info[2] & &Fcntl::S_IWGRP) ||  # Is group writable?
        ($info[2] & &Fcntl::S_IWOTH) ) { # Is world writable?
      # Must be a directory
      unless (-d $path) {
        $$err_ref = "Path ($path) is not a directory"
          if ref($err_ref);
        return 0;
      }
      # Must have sticky bit set
      unless (-k $path) {
        $$err_ref = "Sticky bit not set on $path when dir is group|world writable"
          if ref($err_ref);
        return 0;
      }
    }
  
    return 1;
  }
  
  # Internal routine to check whether a directory is safe
  # for temp files. Safer than _is_safe since it checks for
  # the possibility of chown giveaway and if that is a possibility
  # checks each directory in the path to see if it is safe (with _is_safe)
  
  # If _PC_CHOWN_RESTRICTED is not set, does the full test of each
  # directory anyway.
  
  # Takes optional second arg as scalar ref to error reason
  
  sub _is_verysafe {
  
    # Need POSIX - but only want to bother if really necessary due to overhead
    require POSIX;
  
    my $path = shift;
    print "_is_verysafe testing $path\n" if $DEBUG;
    return 1 if $^O eq 'VMS';     # owner delete control at file level
  
    my $err_ref = shift;
  
    # Should Get the value of _PC_CHOWN_RESTRICTED if it is defined
    # and If it is not there do the extensive test
    local($@);
    my $chown_restricted;
    $chown_restricted = &POSIX::_PC_CHOWN_RESTRICTED()
      if eval { &POSIX::_PC_CHOWN_RESTRICTED(); 1};
  
    # If chown_resticted is set to some value we should test it
    if (defined $chown_restricted) {
  
      # Return if the current directory is safe
      return _is_safe($path,$err_ref) if POSIX::sysconf( $chown_restricted );
  
    }
  
    # To reach this point either, the _PC_CHOWN_RESTRICTED symbol
    # was not available or the symbol was there but chown giveaway
    # is allowed. Either way, we now have to test the entire tree for
    # safety.
  
    # Convert path to an absolute directory if required
    unless (File::Spec->file_name_is_absolute($path)) {
      $path = File::Spec->rel2abs($path);
    }
  
    # Split directory into components - assume no file
    my ($volume, $directories, undef) = File::Spec->splitpath( $path, 1);
  
    # Slightly less efficient than having a function in File::Spec
    # to chop off the end of a directory or even a function that
    # can handle ../ in a directory tree
    # Sometimes splitdir() returns a blank at the end
    # so we will probably check the bottom directory twice in some cases
    my @dirs = File::Spec->splitdir($directories);
  
    # Concatenate one less directory each time around
    foreach my $pos (0.. $#dirs) {
      # Get a directory name
      my $dir = File::Spec->catpath($volume,
                                    File::Spec->catdir(@dirs[0.. $#dirs - $pos]),
                                    ''
                                   );
  
      print "TESTING DIR $dir\n" if $DEBUG;
  
      # Check the directory
      return 0 unless _is_safe($dir,$err_ref);
  
    }
  
    return 1;
  }
  
  
  
  # internal routine to determine whether unlink works on this
  # platform for files that are currently open.
  # Returns true if we can, false otherwise.
  
  # Currently WinNT, OS/2 and VMS can not unlink an opened file
  # On VMS this is because the O_EXCL flag is used to open the
  # temporary file. Currently I do not know enough about the issues
  # on VMS to decide whether O_EXCL is a requirement.
  
  sub _can_unlink_opened_file {
  
    if (grep { $^O eq $_ } qw/MSWin32 os2 VMS dos MacOS haiku/) {
      return 0;
    } else {
      return 1;
    }
  
  }
  
  # internal routine to decide which security levels are allowed
  # see safe_level() for more information on this
  
  # Controls whether the supplied security level is allowed
  
  #   $cando = _can_do_level( $level )
  
  sub _can_do_level {
  
    # Get security level
    my $level = shift;
  
    # Always have to be able to do STANDARD
    return 1 if $level == STANDARD;
  
    # Currently, the systems that can do HIGH or MEDIUM are identical
    if ( $^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'cygwin' || $^O eq 'dos' || $^O eq 'MacOS' || $^O eq 'mpeix') {
      return 0;
    } else {
      return 1;
    }
  
  }
  
  # This routine sets up a deferred unlinking of a specified
  # filename and filehandle. It is used in the following cases:
  #  - Called by unlink0 if an opened file can not be unlinked
  #  - Called by tempfile() if files are to be removed on shutdown
  #  - Called by tempdir() if directories are to be removed on shutdown
  
  # Arguments:
  #   _deferred_unlink( $fh, $fname, $isdir );
  #
  #   - filehandle (so that it can be explicitly closed if open
  #   - filename   (the thing we want to remove)
  #   - isdir      (flag to indicate that we are being given a directory)
  #                 [and hence no filehandle]
  
  # Status is not referred to since all the magic is done with an END block
  
  {
    # Will set up two lexical variables to contain all the files to be
    # removed. One array for files, another for directories They will
    # only exist in this block.
  
    #  This means we only have to set up a single END block to remove
    #  all files. 
  
    # in order to prevent child processes inadvertently deleting the parent
    # temp files we use a hash to store the temp files and directories
    # created by a particular process id.
  
    # %files_to_unlink contains values that are references to an array of
    # array references containing the filehandle and filename associated with
    # the temp file.
    my (%files_to_unlink, %dirs_to_unlink);
  
    # Set up an end block to use these arrays
    END {
      local($., $@, $!, $^E, $?);
      cleanup(at_exit => 1);
    }
  
    # Cleanup function. Always triggered on END (with at_exit => 1) but
    # can be invoked manually.
    sub cleanup {
      my %h = @_;
      my $at_exit = delete $h{at_exit};
      $at_exit = 0 if not defined $at_exit;
      { my @k = sort keys %h; die "unrecognized parameters: @k" if @k }
  
      if (!$KEEP_ALL) {
        # Files
        my @files = (exists $files_to_unlink{$$} ?
                     @{ $files_to_unlink{$$} } : () );
        foreach my $file (@files) {
          # close the filehandle without checking its state
          # in order to make real sure that this is closed
          # if its already closed then I don't care about the answer
          # probably a better way to do this
          close($file->[0]);      # file handle is [0]
  
          if (-f $file->[1]) {       # file name is [1]
            _force_writable( $file->[1] ); # for windows
            unlink $file->[1] or warn "Error removing ".$file->[1];
          }
        }
        # Dirs
        my @dirs = (exists $dirs_to_unlink{$$} ?
                    @{ $dirs_to_unlink{$$} } : () );
        my ($cwd, $cwd_to_remove);
        foreach my $dir (@dirs) {
          if (-d $dir) {
            # Some versions of rmtree will abort if you attempt to remove
            # the directory you are sitting in. For automatic cleanup
            # at program exit, we avoid this by chdir()ing out of the way
            # first. If not at program exit, it's best not to mess with the
            # current directory, so just let it fail with a warning.
            if ($at_exit) {
              $cwd = Cwd::abs_path(File::Spec->curdir) if not defined $cwd;
              my $abs = Cwd::abs_path($dir);
              if ($abs eq $cwd) {
                $cwd_to_remove = $dir;
                next;
              }
            }
            eval { rmtree($dir, $DEBUG, 0); };
            warn $@ if ($@ && $^W);
          }
        }
  
        if (defined $cwd_to_remove) {
          # We do need to clean up the current directory, and everything
          # else is done, so get out of there and remove it.
          chdir $cwd_to_remove or die "cannot chdir to $cwd_to_remove: $!";
          my $updir = File::Spec->updir;
          chdir $updir or die "cannot chdir to $updir: $!";
          eval { rmtree($cwd_to_remove, $DEBUG, 0); };
          warn $@ if ($@ && $^W);
        }
  
        # clear the arrays
        @{ $files_to_unlink{$$} } = ()
          if exists $files_to_unlink{$$};
        @{ $dirs_to_unlink{$$} } = ()
          if exists $dirs_to_unlink{$$};
      }
    }
  
  
    # This is the sub called to register a file for deferred unlinking
    # This could simply store the input parameters and defer everything
    # until the END block. For now we do a bit of checking at this
    # point in order to make sure that (1) we have a file/dir to delete
    # and (2) we have been called with the correct arguments.
    sub _deferred_unlink {
  
      croak 'Usage:  _deferred_unlink($fh, $fname, $isdir)'
        unless scalar(@_) == 3;
  
      my ($fh, $fname, $isdir) = @_;
  
      warn "Setting up deferred removal of $fname\n"
        if $DEBUG;
  
      # make sure we save the absolute path for later cleanup
      # OK to untaint because we only ever use this internally
      # as a file path, never interpolating into the shell
      $fname = Cwd::abs_path($fname);
      ($fname) = $fname =~ /^(.*)$/;
  
      # If we have a directory, check that it is a directory
      if ($isdir) {
  
        if (-d $fname) {
  
          # Directory exists so store it
          # first on VMS turn []foo into [.foo] for rmtree
          $fname = VMS::Filespec::vmspath($fname) if $^O eq 'VMS';
          $dirs_to_unlink{$$} = [] 
            unless exists $dirs_to_unlink{$$};
          push (@{ $dirs_to_unlink{$$} }, $fname);
  
        } else {
          carp "Request to remove directory $fname could not be completed since it does not exist!\n" if $^W;
        }
  
      } else {
  
        if (-f $fname) {
  
          # file exists so store handle and name for later removal
          $files_to_unlink{$$} = []
            unless exists $files_to_unlink{$$};
          push(@{ $files_to_unlink{$$} }, [$fh, $fname]);
  
        } else {
          carp "Request to remove file $fname could not be completed since it is not there!\n" if $^W;
        }
  
      }
  
    }
  
  
  }
  
  # normalize argument keys to upper case and do consistent handling
  # of leading template vs TEMPLATE
  sub _parse_args {
    my $leading_template = (scalar(@_) % 2 == 1 ? shift(@_) : '' );
    my %args = @_;
    %args = map { uc($_), $args{$_} } keys %args;
  
    # template (store it in an array so that it will
    # disappear from the arg list of tempfile)
    my @template = (
      exists $args{TEMPLATE}  ? $args{TEMPLATE} :
      $leading_template       ? $leading_template : ()
    );
    delete $args{TEMPLATE};
  
    return( \@template, \%args );
  }
  
  
  sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
  
    my ($maybe_template, $args) = _parse_args(@_);
  
    # see if they are unlinking (defaulting to yes)
    my $unlink = (exists $args->{UNLINK} ? $args->{UNLINK} : 1 );
    delete $args->{UNLINK};
  
    # Protect OPEN
    delete $args->{OPEN};
  
    # Open the file and retain file handle and file name
    my ($fh, $path) = tempfile( @$maybe_template, %$args );
  
    print "Tmp: $fh - $path\n" if $DEBUG;
  
    # Store the filename in the scalar slot
    ${*$fh} = $path;
  
    # Cache the filename by pid so that the destructor can decide whether to remove it
    $FILES_CREATED_BY_OBJECT{$$}{$path} = 1;
  
    # Store unlink information in hash slot (plus other constructor info)
    %{*$fh} = %$args;
  
    # create the object
    bless $fh, $class;
  
    # final method-based configuration
    $fh->unlink_on_destroy( $unlink );
  
    return $fh;
  }
  
  
  sub newdir {
    my $self = shift;
  
    my ($maybe_template, $args) = _parse_args(@_);
  
    # handle CLEANUP without passing CLEANUP to tempdir
    my $cleanup = (exists $args->{CLEANUP} ? $args->{CLEANUP} : 1 );
    delete $args->{CLEANUP};
  
    my $tempdir = tempdir( @$maybe_template, %$args);
  
    # get a safe absolute path for cleanup, just like
    # happens in _deferred_unlink
    my $real_dir = Cwd::abs_path( $tempdir );
    ($real_dir) = $real_dir =~ /^(.*)$/;
  
    return bless { DIRNAME => $tempdir,
                   REALNAME => $real_dir,
                   CLEANUP => $cleanup,
                   LAUNCHPID => $$,
                 }, "File::Temp::Dir";
  }
  
  
  sub filename {
    my $self = shift;
    return ${*$self};
  }
  
  sub STRINGIFY {
    my $self = shift;
    return $self->filename;
  }
  
  # For reference, can't use '0+'=>\&Scalar::Util::refaddr directly because
  # refaddr() demands one parameter only, whereas overload.pm calls with three
  # even for unary operations like '0+'.
  sub NUMIFY {
    return refaddr($_[0]);
  }
  
  
  sub unlink_on_destroy {
    my $self = shift;
    if (@_) {
      ${*$self}{UNLINK} = shift;
    }
    return ${*$self}{UNLINK};
  }
  
  
  sub DESTROY {
    local($., $@, $!, $^E, $?);
    my $self = shift;
  
    # Make sure we always remove the file from the global hash
    # on destruction. This prevents the hash from growing uncontrollably
    # and post-destruction there is no reason to know about the file.
    my $file = $self->filename;
    my $was_created_by_proc;
    if (exists $FILES_CREATED_BY_OBJECT{$$}{$file}) {
      $was_created_by_proc = 1;
      delete $FILES_CREATED_BY_OBJECT{$$}{$file};
    }
  
    if (${*$self}{UNLINK} && !$KEEP_ALL) {
      print "# --------->   Unlinking $self\n" if $DEBUG;
  
      # only delete if this process created it
      return unless $was_created_by_proc;
  
      # The unlink1 may fail if the file has been closed
      # by the caller. This leaves us with the decision
      # of whether to refuse to remove the file or simply
      # do an unlink without test. Seems to be silly
      # to do this when we are trying to be careful
      # about security
      _force_writable( $file ); # for windows
      unlink1( $self, $file )
        or unlink($file);
    }
  }
  
  
  sub tempfile {
    if ( @_ && $_[0] eq 'File::Temp' ) {
        croak "'tempfile' can't be called as a method";
    }
    # Can not check for argument count since we can have any
    # number of args
  
    # Default options
    my %options = (
                   "DIR"    => undef, # Directory prefix
                   "SUFFIX" => '',    # Template suffix
                   "UNLINK" => 0,     # Do not unlink file on exit
                   "OPEN"   => 1,     # Open file
                   "TMPDIR" => 0, # Place tempfile in tempdir if template specified
                   "EXLOCK" => 1, # Open file with O_EXLOCK
                  );
  
    # Check to see whether we have an odd or even number of arguments
    my ($maybe_template, $args) = _parse_args(@_);
    my $template = @$maybe_template ? $maybe_template->[0] : undef;
  
    # Read the options and merge with defaults
    %options = (%options, %$args);
  
    # First decision is whether or not to open the file
    if (! $options{"OPEN"}) {
  
      warn "tempfile(): temporary filename requested but not opened.\nPossibly unsafe, consider using tempfile() with OPEN set to true\n"
        if $^W;
  
    }
  
    if ($options{"DIR"} and $^O eq 'VMS') {
  
      # on VMS turn []foo into [.foo] for concatenation
      $options{"DIR"} = VMS::Filespec::vmspath($options{"DIR"});
    }
  
    # Construct the template
  
    # Have a choice of trying to work around the mkstemp/mktemp/tmpnam etc
    # functions or simply constructing a template and using _gettemp()
    # explicitly. Go for the latter
  
    # First generate a template if not defined and prefix the directory
    # If no template must prefix the temp directory
    if (defined $template) {
      # End up with current directory if neither DIR not TMPDIR are set
      if ($options{"DIR"}) {
  
        $template = File::Spec->catfile($options{"DIR"}, $template);
  
      } elsif ($options{TMPDIR}) {
  
        $template = File::Spec->catfile(File::Spec->tmpdir, $template );
  
      }
  
    } else {
  
      if ($options{"DIR"}) {
  
        $template = File::Spec->catfile($options{"DIR"}, TEMPXXX);
  
      } else {
  
        $template = File::Spec->catfile(File::Spec->tmpdir, TEMPXXX);
  
      }
  
    }
  
    # Now add a suffix
    $template .= $options{"SUFFIX"};
  
    # Determine whether we should tell _gettemp to unlink the file
    # On unix this is irrelevant and can be worked out after the file is
    # opened (simply by unlinking the open filehandle). On Windows or VMS
    # we have to indicate temporary-ness when we open the file. In general
    # we only want a true temporary file if we are returning just the
    # filehandle - if the user wants the filename they probably do not
    # want the file to disappear as soon as they close it (which may be
    # important if they want a child process to use the file)
    # For this reason, tie unlink_on_close to the return context regardless
    # of OS.
    my $unlink_on_close = ( wantarray ? 0 : 1);
  
    # Create the file
    my ($fh, $path, $errstr);
    croak "Error in tempfile() using template $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => $options{'OPEN'},
                                      "mkdir"=> 0 ,
                                      "unlink_on_close" => $unlink_on_close,
                                      "suffixlen" => length($options{'SUFFIX'}),
                                      "ErrStr" => \$errstr,
                                      "use_exlock" => $options{EXLOCK},
                                     ) );
  
    # Set up an exit handler that can do whatever is right for the
    # system. This removes files at exit when requested explicitly or when
    # system is asked to unlink_on_close but is unable to do so because
    # of OS limitations.
    # The latter should be achieved by using a tied filehandle.
    # Do not check return status since this is all done with END blocks.
    _deferred_unlink($fh, $path, 0) if $options{"UNLINK"};
  
    # Return
    if (wantarray()) {
  
      if ($options{'OPEN'}) {
        return ($fh, $path);
      } else {
        return (undef, $path);
      }
  
    } else {
  
      # Unlink the file. It is up to unlink0 to decide what to do with
      # this (whether to unlink now or to defer until later)
      unlink0($fh, $path) or croak "Error unlinking file $path using unlink0";
  
      # Return just the filehandle.
      return $fh;
    }
  
  
  }
  
  
  # '
  
  sub tempdir  {
    if ( @_ && $_[0] eq 'File::Temp' ) {
        croak "'tempdir' can't be called as a method";
    }
  
    # Can not check for argument count since we can have any
    # number of args
  
    # Default options
    my %options = (
                   "CLEANUP"    => 0, # Remove directory on exit
                   "DIR"        => '', # Root directory
                   "TMPDIR"     => 0,  # Use tempdir with template
                  );
  
    # Check to see whether we have an odd or even number of arguments
    my ($maybe_template, $args) = _parse_args(@_);
    my $template = @$maybe_template ? $maybe_template->[0] : undef;
  
    # Read the options and merge with defaults
    %options = (%options, %$args);
  
    # Modify or generate the template
  
    # Deal with the DIR and TMPDIR options
    if (defined $template) {
  
      # Need to strip directory path if using DIR or TMPDIR
      if ($options{'TMPDIR'} || $options{'DIR'}) {
  
        # Strip parent directory from the filename
        #
        # There is no filename at the end
        $template = VMS::Filespec::vmspath($template) if $^O eq 'VMS';
        my ($volume, $directories, undef) = File::Spec->splitpath( $template, 1);
  
        # Last directory is then our template
        $template = (File::Spec->splitdir($directories))[-1];
  
        # Prepend the supplied directory or temp dir
        if ($options{"DIR"}) {
  
          $template = File::Spec->catdir($options{"DIR"}, $template);
  
        } elsif ($options{TMPDIR}) {
  
          # Prepend tmpdir
          $template = File::Spec->catdir(File::Spec->tmpdir, $template);
  
        }
  
      }
  
    } else {
  
      if ($options{"DIR"}) {
  
        $template = File::Spec->catdir($options{"DIR"}, TEMPXXX);
  
      } else {
  
        $template = File::Spec->catdir(File::Spec->tmpdir, TEMPXXX);
  
      }
  
    }
  
    # Create the directory
    my $tempdir;
    my $suffixlen = 0;
    if ($^O eq 'VMS') {           # dir names can end in delimiters
      $template =~ m/([\.\]:>]+)$/;
      $suffixlen = length($1);
    }
    if ( ($^O eq 'MacOS') && (substr($template, -1) eq ':') ) {
      # dir name has a trailing ':'
      ++$suffixlen;
    }
  
    my $errstr;
    croak "Error in tempdir() using $template: $errstr"
      unless ((undef, $tempdir) = _gettemp($template,
                                           "open" => 0,
                                           "mkdir"=> 1 ,
                                           "suffixlen" => $suffixlen,
                                           "ErrStr" => \$errstr,
                                          ) );
  
    # Install exit handler; must be dynamic to get lexical
    if ( $options{'CLEANUP'} && -d $tempdir) {
      _deferred_unlink(undef, $tempdir, 1);
    }
  
    # Return the dir name
    return $tempdir;
  
  }
  
  
  
  
  sub mkstemp {
  
    croak "Usage: mkstemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
  
    my ($fh, $path, $errstr);
    croak "Error in mkstemp using $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => 1,
                                      "mkdir"=> 0 ,
                                      "suffixlen" => 0,
                                      "ErrStr" => \$errstr,
                                     ) );
  
    if (wantarray()) {
      return ($fh, $path);
    } else {
      return $fh;
    }
  
  }
  
  
  
  sub mkstemps {
  
    croak "Usage: mkstemps(template, suffix)"
      if scalar(@_) != 2;
  
  
    my $template = shift;
    my $suffix   = shift;
  
    $template .= $suffix;
  
    my ($fh, $path, $errstr);
    croak "Error in mkstemps using $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => 1,
                                      "mkdir"=> 0 ,
                                      "suffixlen" => length($suffix),
                                      "ErrStr" => \$errstr,
                                     ) );
  
    if (wantarray()) {
      return ($fh, $path);
    } else {
      return $fh;
    }
  
  }
  
  
  #' # for emacs
  
  sub mkdtemp {
  
    croak "Usage: mkdtemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
    my $suffixlen = 0;
    if ($^O eq 'VMS') {           # dir names can end in delimiters
      $template =~ m/([\.\]:>]+)$/;
      $suffixlen = length($1);
    }
    if ( ($^O eq 'MacOS') && (substr($template, -1) eq ':') ) {
      # dir name has a trailing ':'
      ++$suffixlen;
    }
    my ($junk, $tmpdir, $errstr);
    croak "Error creating temp directory from template $template\: $errstr"
      unless (($junk, $tmpdir) = _gettemp($template,
                                          "open" => 0,
                                          "mkdir"=> 1 ,
                                          "suffixlen" => $suffixlen,
                                          "ErrStr" => \$errstr,
                                         ) );
  
    return $tmpdir;
  
  }
  
  
  sub mktemp {
  
    croak "Usage: mktemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
  
    my ($tmpname, $junk, $errstr);
    croak "Error getting name to temp file from template $template: $errstr"
      unless (($junk, $tmpname) = _gettemp($template,
                                           "open" => 0,
                                           "mkdir"=> 0 ,
                                           "suffixlen" => 0,
                                           "ErrStr" => \$errstr,
                                          ) );
  
    return $tmpname;
  }
  
  
  sub tmpnam {
  
    # Retrieve the temporary directory name
    my $tmpdir = File::Spec->tmpdir;
  
    croak "Error temporary directory is not writable"
      if $tmpdir eq '';
  
    # Use a ten character template and append to tmpdir
    my $template = File::Spec->catfile($tmpdir, TEMPXXX);
  
    if (wantarray() ) {
      return mkstemp($template);
    } else {
      return mktemp($template);
    }
  
  }
  
  
  sub tmpfile {
  
    # Simply call tmpnam() in a list context
    my ($fh, $file) = tmpnam();
  
    # Make sure file is removed when filehandle is closed
    # This will fail on NFS
    unlink0($fh, $file)
      or return undef;
  
    return $fh;
  
  }
  
  
  sub tempnam {
  
    croak 'Usage tempnam($dir, $prefix)' unless scalar(@_) == 2;
  
    my ($dir, $prefix) = @_;
  
    # Add a string to the prefix
    $prefix .= 'XXXXXXXX';
  
    # Concatenate the directory to the file
    my $template = File::Spec->catfile($dir, $prefix);
  
    return mktemp($template);
  
  }
  
  
  sub unlink0 {
  
    croak 'Usage: unlink0(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    cmpstat($fh, $path) or return 0;
  
    # attempt remove the file (does not work on some platforms)
    if (_can_unlink_opened_file()) {
  
      # return early (Without unlink) if we have been instructed to retain files.
      return 1 if $KEEP_ALL;
  
      # XXX: do *not* call this on a directory; possible race
      #      resulting in recursive removal
      croak "unlink0: $path has become a directory!" if -d $path;
      unlink($path) or return 0;
  
      # Stat the filehandle
      my @fh = stat $fh;
  
      print "Link count = $fh[3] \n" if $DEBUG;
  
      # Make sure that the link count is zero
      # - Cygwin provides deferred unlinking, however,
      #   on Win9x the link count remains 1
      # On NFS the link count may still be 1 but we can't know that
      # we are on NFS.  Since we can't be sure, we'll defer it
  
      return 1 if $fh[3] == 0 || $^O eq 'cygwin';
    }
    # fall-through if we can't unlink now
    _deferred_unlink($fh, $path, 0);
    return 1;
  }
  
  
  sub cmpstat {
  
    croak 'Usage: cmpstat(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    warn "Comparing stat\n"
      if $DEBUG;
  
    # Stat the filehandle - which may be closed if someone has manually
    # closed the file. Can not turn off warnings without using $^W
    # unless we upgrade to 5.006 minimum requirement
    my @fh;
    {
      local ($^W) = 0;
      @fh = stat $fh;
    }
    return unless @fh;
  
    if ($fh[3] > 1 && $^W) {
      carp "unlink0: fstat found too many links; SB=@fh" if $^W;
    }
  
    # Stat the path
    my @path = stat $path;
  
    unless (@path) {
      carp "unlink0: $path is gone already" if $^W;
      return;
    }
  
    # this is no longer a file, but may be a directory, or worse
    unless (-f $path) {
      confess "panic: $path is no longer a file: SB=@fh";
    }
  
    # Do comparison of each member of the array
    # On WinNT dev and rdev seem to be different
    # depending on whether it is a file or a handle.
    # Cannot simply compare all members of the stat return
    # Select the ones we can use
    my @okstat = (0..$#fh);       # Use all by default
    if ($^O eq 'MSWin32') {
      @okstat = (1,2,3,4,5,7,8,9,10);
    } elsif ($^O eq 'os2') {
      @okstat = (0, 2..$#fh);
    } elsif ($^O eq 'VMS') {      # device and file ID are sufficient
      @okstat = (0, 1);
    } elsif ($^O eq 'dos') {
      @okstat = (0,2..7,11..$#fh);
    } elsif ($^O eq 'mpeix') {
      @okstat = (0..4,8..10);
    }
  
    # Now compare each entry explicitly by number
    for (@okstat) {
      print "Comparing: $_ : $fh[$_] and $path[$_]\n" if $DEBUG;
      # Use eq rather than == since rdev, blksize, and blocks (6, 11,
      # and 12) will be '' on platforms that do not support them.  This
      # is fine since we are only comparing integers.
      unless ($fh[$_] eq $path[$_]) {
        warn "Did not match $_ element of stat\n" if $DEBUG;
        return 0;
      }
    }
  
    return 1;
  }
  
  
  sub unlink1 {
    croak 'Usage: unlink1(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    cmpstat($fh, $path) or return 0;
  
    # Close the file
    close( $fh ) or return 0;
  
    # Make sure the file is writable (for windows)
    _force_writable( $path );
  
    # return early (without unlink) if we have been instructed to retain files.
    return 1 if $KEEP_ALL;
  
    # remove the file
    return unlink($path);
  }
  
  
  {
    # protect from using the variable itself
    my $LEVEL = STANDARD;
    sub safe_level {
      my $self = shift;
      if (@_) {
        my $level = shift;
        if (($level != STANDARD) && ($level != MEDIUM) && ($level != HIGH)) {
          carp "safe_level: Specified level ($level) not STANDARD, MEDIUM or HIGH - ignoring\n" if $^W;
        } else {
          # Don't allow this on perl 5.005 or earlier
          if ($] < 5.006 && $level != STANDARD) {
            # Cant do MEDIUM or HIGH checks
            croak "Currently requires perl 5.006 or newer to do the safe checks";
          }
          # Check that we are allowed to change level
          # Silently ignore if we can not.
          $LEVEL = $level if _can_do_level($level);
        }
      }
      return $LEVEL;
    }
  }
  
  
  {
    my $TopSystemUID = 10;
    $TopSystemUID = 197108 if $^O eq 'interix'; # "Administrator"
    sub top_system_uid {
      my $self = shift;
      if (@_) {
        my $newuid = shift;
        croak "top_system_uid: UIDs should be numeric"
          unless $newuid =~ /^\d+$/s;
        $TopSystemUID = $newuid;
      }
      return $TopSystemUID;
    }
  }
  
  
  package File::Temp::Dir;
  
  use File::Path qw/ rmtree /;
  use strict;
  use overload '""' => "STRINGIFY",
    '0+' => \&File::Temp::NUMIFY,
    fallback => 1;
  
  # private class specifically to support tempdir objects
  # created by File::Temp->newdir
  
  # ostensibly the same method interface as File::Temp but without
  # inheriting all the IO::Seekable methods and other cruft
  
  # Read-only - returns the name of the temp directory
  
  sub dirname {
    my $self = shift;
    return $self->{DIRNAME};
  }
  
  sub STRINGIFY {
    my $self = shift;
    return $self->dirname;
  }
  
  sub unlink_on_destroy {
    my $self = shift;
    if (@_) {
      $self->{CLEANUP} = shift;
    }
    return $self->{CLEANUP};
  }
  
  sub DESTROY {
    my $self = shift;
    local($., $@, $!, $^E, $?);
    if ($self->unlink_on_destroy && 
        $$ == $self->{LAUNCHPID} && !$File::Temp::KEEP_ALL) {
      if (-d $self->{REALNAME}) {
        # Some versions of rmtree will abort if you attempt to remove
        # the directory you are sitting in. We protect that and turn it
        # into a warning. We do this because this occurs during object
        # destruction and so can not be caught by the user.
        eval { rmtree($self->{REALNAME}, $File::Temp::DEBUG, 0); };
        warn $@ if ($@ && $^W);
      }
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  File::Temp - return name and handle of a temporary file safely
  
  =head1 VERSION
  
  version 0.2304
  
  =head1 SYNOPSIS
  
    use File::Temp qw/ tempfile tempdir /;
  
    $fh = tempfile();
    ($fh, $filename) = tempfile();
  
    ($fh, $filename) = tempfile( $template, DIR => $dir);
    ($fh, $filename) = tempfile( $template, SUFFIX => '.dat');
    ($fh, $filename) = tempfile( $template, TMPDIR => 1 );
  
    binmode( $fh, ":utf8" );
  
    $dir = tempdir( CLEANUP => 1 );
    ($fh, $filename) = tempfile( DIR => $dir );
  
  Object interface:
  
    require File::Temp;
    use File::Temp ();
    use File::Temp qw/ :seekable /;
  
    $fh = File::Temp->new();
    $fname = $fh->filename;
  
    $fh = File::Temp->new(TEMPLATE => $template);
    $fname = $fh->filename;
  
    $tmp = File::Temp->new( UNLINK => 0, SUFFIX => '.dat' );
    print $tmp "Some data\n";
    print "Filename is $tmp\n";
    $tmp->seek( 0, SEEK_END );
  
  The following interfaces are provided for compatibility with
  existing APIs. They should not be used in new code.
  
  MkTemp family:
  
    use File::Temp qw/ :mktemp  /;
  
    ($fh, $file) = mkstemp( "tmpfileXXXXX" );
    ($fh, $file) = mkstemps( "tmpfileXXXXXX", $suffix);
  
    $tmpdir = mkdtemp( $template );
  
    $unopened_file = mktemp( $template );
  
  POSIX functions:
  
    use File::Temp qw/ :POSIX /;
  
    $file = tmpnam();
    $fh = tmpfile();
  
    ($fh, $file) = tmpnam();
  
  Compatibility functions:
  
    $unopened_file = File::Temp::tempnam( $dir, $pfx );
  
  =head1 DESCRIPTION
  
  C<File::Temp> can be used to create and open temporary files in a safe
  way.  There is both a function interface and an object-oriented
  interface.  The File::Temp constructor or the tempfile() function can
  be used to return the name and the open filehandle of a temporary
  file.  The tempdir() function can be used to create a temporary
  directory.
  
  The security aspect of temporary file creation is emphasized such that
  a filehandle and filename are returned together.  This helps guarantee
  that a race condition can not occur where the temporary file is
  created by another process between checking for the existence of the
  file and its opening.  Additional security levels are provided to
  check, for example, that the sticky bit is set on world writable
  directories.  See L<"safe_level"> for more information.
  
  For compatibility with popular C library functions, Perl implementations of
  the mkstemp() family of functions are provided. These are, mkstemp(),
  mkstemps(), mkdtemp() and mktemp().
  
  Additionally, implementations of the standard L<POSIX|POSIX>
  tmpnam() and tmpfile() functions are provided if required.
  
  Implementations of mktemp(), tmpnam(), and tempnam() are provided,
  but should be used with caution since they return only a filename
  that was valid when function was called, so cannot guarantee
  that the file will not exist by the time the caller opens the filename.
  
  Filehandles returned by these functions support the seekable methods.
  
  =begin __INTERNALS
  
  =head1 PORTABILITY
  
  This section is at the top in order to provide easier access to
  porters.  It is not expected to be rendered by a standard pod
  formatting tool. Please skip straight to the SYNOPSIS section if you
  are not trying to port this module to a new platform.
  
  This module is designed to be portable across operating systems and it
  currently supports Unix, VMS, DOS, OS/2, Windows and Mac OS
  (Classic). When porting to a new OS there are generally three main
  issues that have to be solved:
  =over 4
  
  =item *
  
  Can the OS unlink an open file? If it can not then the
  C<_can_unlink_opened_file> method should be modified.
  
  =item *
  
  Are the return values from C<stat> reliable? By default all the
  return values from C<stat> are compared when unlinking a temporary
  file using the filename and the handle. Operating systems other than
  unix do not always have valid entries in all fields. If utility function
  C<File::Temp::unlink0> fails then the C<stat> comparison should be
  modified accordingly.
  
  =item *
  
  Security. Systems that can not support a test for the sticky bit
  on a directory can not use the MEDIUM and HIGH security tests.
  The C<_can_do_level> method should be modified accordingly.
  
  =back
  
  =end __INTERNALS
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  This is the primary interface for interacting with
  C<File::Temp>. Using the OO interface a temporary file can be created
  when the object is constructed and the file can be removed when the
  object is no longer required.
  
  Note that there is no method to obtain the filehandle from the
  C<File::Temp> object. The object itself acts as a filehandle.  The object
  isa C<IO::Handle> and isa C<IO::Seekable> so all those methods are
  available.
  
  Also, the object is configured such that it stringifies to the name of the
  temporary file and so can be compared to a filename directly.  It numifies
  to the C<refaddr> the same as other handles and so can be compared to other
  handles with C<==>.
  
      $fh eq $filename       # as a string
      $fh != \*STDOUT        # as a number
  
  =over 4
  
  =item B<new>
  
  Create a temporary file object.
  
    my $tmp = File::Temp->new();
  
  by default the object is constructed as if C<tempfile>
  was called without options, but with the additional behaviour
  that the temporary file is removed by the object destructor
  if UNLINK is set to true (the default).
  
  Supported arguments are the same as for C<tempfile>: UNLINK
  (defaulting to true), DIR, EXLOCK and SUFFIX. Additionally, the filename
  template is specified using the TEMPLATE option. The OPEN option
  is not supported (the file is always opened).
  
   $tmp = File::Temp->new( TEMPLATE => 'tempXXXXX',
                          DIR => 'mydir',
                          SUFFIX => '.dat');
  
  Arguments are case insensitive.
  
  Can call croak() if an error occurs.
  
  =item B<newdir>
  
  Create a temporary directory using an object oriented interface.
  
    $dir = File::Temp->newdir();
  
  By default the directory is deleted when the object goes out of scope.
  
  Supports the same options as the C<tempdir> function. Note that directories
  created with this method default to CLEANUP => 1.
  
    $dir = File::Temp->newdir( $template, %options );
  
  A template may be specified either with a leading template or
  with a TEMPLATE argument.
  
  =item B<filename>
  
  Return the name of the temporary file associated with this object
  (if the object was created using the "new" constructor).
  
    $filename = $tmp->filename;
  
  This method is called automatically when the object is used as
  a string.
  
  =item B<dirname>
  
  Return the name of the temporary directory associated with this
  object (if the object was created using the "newdir" constructor).
  
    $dirname = $tmpdir->dirname;
  
  This method is called automatically when the object is used in string context.
  
  =item B<unlink_on_destroy>
  
  Control whether the file is unlinked when the object goes out of scope.
  The file is removed if this value is true and $KEEP_ALL is not.
  
   $fh->unlink_on_destroy( 1 );
  
  Default is for the file to be removed.
  
  =item B<DESTROY>
  
  When the object goes out of scope, the destructor is called. This
  destructor will attempt to unlink the file (using L<unlink1|"unlink1">)
  if the constructor was called with UNLINK set to 1 (the default state
  if UNLINK is not specified).
  
  No error is given if the unlink fails.
  
  If the object has been passed to a child process during a fork, the
  file will be deleted when the object goes out of scope in the parent.
  
  For a temporary directory object the directory will be removed unless
  the CLEANUP argument was used in the constructor (and set to false) or
  C<unlink_on_destroy> was modified after creation.  Note that if a temp
  directory is your current directory, it cannot be removed - a warning
  will be given in this case.  C<chdir()> out of the directory before
  letting the object go out of scope.
  
  If the global variable $KEEP_ALL is true, the file or directory
  will not be removed.
  
  =back
  
  =head1 FUNCTIONS
  
  This section describes the recommended interface for generating
  temporary files and directories.
  
  =over 4
  
  =item B<tempfile>
  
  This is the basic function to generate temporary files.
  The behaviour of the file can be changed using various options:
  
    $fh = tempfile();
    ($fh, $filename) = tempfile();
  
  Create a temporary file in  the directory specified for temporary
  files, as specified by the tmpdir() function in L<File::Spec>.
  
    ($fh, $filename) = tempfile($template);
  
  Create a temporary file in the current directory using the supplied
  template.  Trailing `X' characters are replaced with random letters to
  generate the filename.  At least four `X' characters must be present
  at the end of the template.
  
    ($fh, $filename) = tempfile($template, SUFFIX => $suffix)
  
  Same as previously, except that a suffix is added to the template
  after the `X' translation.  Useful for ensuring that a temporary
  filename has a particular extension when needed by other applications.
  But see the WARNING at the end.
  
    ($fh, $filename) = tempfile($template, DIR => $dir);
  
  Translates the template as before except that a directory name
  is specified.
  
    ($fh, $filename) = tempfile($template, TMPDIR => 1);
  
  Equivalent to specifying a DIR of "File::Spec->tmpdir", writing the file
  into the same temporary directory as would be used if no template was
  specified at all.
  
    ($fh, $filename) = tempfile($template, UNLINK => 1);
  
  Return the filename and filehandle as before except that the file is
  automatically removed when the program exits (dependent on
  $KEEP_ALL). Default is for the file to be removed if a file handle is
  requested and to be kept if the filename is requested. In a scalar
  context (where no filename is returned) the file is always deleted
  either (depending on the operating system) on exit or when it is
  closed (unless $KEEP_ALL is true when the temp file is created).
  
  Use the object-oriented interface if fine-grained control of when
  a file is removed is required.
  
  If the template is not specified, a template is always
  automatically generated. This temporary file is placed in tmpdir()
  (L<File::Spec>) unless a directory is specified explicitly with the
  DIR option.
  
    $fh = tempfile( DIR => $dir );
  
  If called in scalar context, only the filehandle is returned and the
  file will automatically be deleted when closed on operating systems
  that support this (see the description of tmpfile() elsewhere in this
  document).  This is the preferred mode of operation, as if you only
  have a filehandle, you can never create a race condition by fumbling
  with the filename. On systems that can not unlink an open file or can
  not mark a file as temporary when it is opened (for example, Windows
  NT uses the C<O_TEMPORARY> flag) the file is marked for deletion when
  the program ends (equivalent to setting UNLINK to 1). The C<UNLINK>
  flag is ignored if present.
  
    (undef, $filename) = tempfile($template, OPEN => 0);
  
  This will return the filename based on the template but
  will not open this file.  Cannot be used in conjunction with
  UNLINK set to true. Default is to always open the file
  to protect from possible race conditions. A warning is issued
  if warnings are turned on. Consider using the tmpnam()
  and mktemp() functions described elsewhere in this document
  if opening the file is not required.
  
  If the operating system supports it (for example BSD derived systems), the 
  filehandle will be opened with O_EXLOCK (open with exclusive file lock). 
  This can sometimes cause problems if the intention is to pass the filename 
  to another system that expects to take an exclusive lock itself (such as 
  DBD::SQLite) whilst ensuring that the tempfile is not reused. In this 
  situation the "EXLOCK" option can be passed to tempfile. By default EXLOCK 
  will be true (this retains compatibility with earlier releases).
  
    ($fh, $filename) = tempfile($template, EXLOCK => 0);
  
  Options can be combined as required.
  
  Will croak() if there is an error.
  
  =item B<tempdir>
  
  This is the recommended interface for creation of temporary
  directories.  By default the directory will not be removed on exit
  (that is, it won't be temporary; this behaviour can not be changed
  because of issues with backwards compatibility). To enable removal
  either use the CLEANUP option which will trigger removal on program
  exit, or consider using the "newdir" method in the object interface which
  will allow the directory to be cleaned up when the object goes out of
  scope.
  
  The behaviour of the function depends on the arguments:
  
    $tempdir = tempdir();
  
  Create a directory in tmpdir() (see L<File::Spec|File::Spec>).
  
    $tempdir = tempdir( $template );
  
  Create a directory from the supplied template. This template is
  similar to that described for tempfile(). `X' characters at the end
  of the template are replaced with random letters to construct the
  directory name. At least four `X' characters must be in the template.
  
    $tempdir = tempdir ( DIR => $dir );
  
  Specifies the directory to use for the temporary directory.
  The temporary directory name is derived from an internal template.
  
    $tempdir = tempdir ( $template, DIR => $dir );
  
  Prepend the supplied directory name to the template. The template
  should not include parent directory specifications itself. Any parent
  directory specifications are removed from the template before
  prepending the supplied directory.
  
    $tempdir = tempdir ( $template, TMPDIR => 1 );
  
  Using the supplied template, create the temporary directory in
  a standard location for temporary files. Equivalent to doing
  
    $tempdir = tempdir ( $template, DIR => File::Spec->tmpdir);
  
  but shorter. Parent directory specifications are stripped from the
  template itself. The C<TMPDIR> option is ignored if C<DIR> is set
  explicitly.  Additionally, C<TMPDIR> is implied if neither a template
  nor a directory are supplied.
  
    $tempdir = tempdir( $template, CLEANUP => 1);
  
  Create a temporary directory using the supplied template, but
  attempt to remove it (and all files inside it) when the program
  exits. Note that an attempt will be made to remove all files from
  the directory even if they were not created by this module (otherwise
  why ask to clean it up?). The directory removal is made with
  the rmtree() function from the L<File::Path|File::Path> module.
  Of course, if the template is not specified, the temporary directory
  will be created in tmpdir() and will also be removed at program exit.
  
  Will croak() if there is an error.
  
  =back
  
  =head1 MKTEMP FUNCTIONS
  
  The following functions are Perl implementations of the
  mktemp() family of temp file generation system calls.
  
  =over 4
  
  =item B<mkstemp>
  
  Given a template, returns a filehandle to the temporary file and the name
  of the file.
  
    ($fh, $name) = mkstemp( $template );
  
  In scalar context, just the filehandle is returned.
  
  The template may be any filename with some number of X's appended
  to it, for example F</tmp/temp.XXXX>. The trailing X's are replaced
  with unique alphanumeric combinations.
  
  Will croak() if there is an error.
  
  =item B<mkstemps>
  
  Similar to mkstemp(), except that an extra argument can be supplied
  with a suffix to be appended to the template.
  
    ($fh, $name) = mkstemps( $template, $suffix );
  
  For example a template of C<testXXXXXX> and suffix of C<.dat>
  would generate a file similar to F<testhGji_w.dat>.
  
  Returns just the filehandle alone when called in scalar context.
  
  Will croak() if there is an error.
  
  =item B<mkdtemp>
  
  Create a directory from a template. The template must end in
  X's that are replaced by the routine.
  
    $tmpdir_name = mkdtemp($template);
  
  Returns the name of the temporary directory created.
  
  Directory must be removed by the caller.
  
  Will croak() if there is an error.
  
  =item B<mktemp>
  
  Returns a valid temporary filename but does not guarantee
  that the file will not be opened by someone else.
  
    $unopened_file = mktemp($template);
  
  Template is the same as that required by mkstemp().
  
  Will croak() if there is an error.
  
  =back
  
  =head1 POSIX FUNCTIONS
  
  This section describes the re-implementation of the tmpnam()
  and tmpfile() functions described in L<POSIX>
  using the mkstemp() from this module.
  
  Unlike the L<POSIX|POSIX> implementations, the directory used
  for the temporary file is not specified in a system include
  file (C<P_tmpdir>) but simply depends on the choice of tmpdir()
  returned by L<File::Spec|File::Spec>. On some implementations this
  location can be set using the C<TMPDIR> environment variable, which
  may not be secure.
  If this is a problem, simply use mkstemp() and specify a template.
  
  =over 4
  
  =item B<tmpnam>
  
  When called in scalar context, returns the full name (including path)
  of a temporary file (uses mktemp()). The only check is that the file does
  not already exist, but there is no guarantee that that condition will
  continue to apply.
  
    $file = tmpnam();
  
  When called in list context, a filehandle to the open file and
  a filename are returned. This is achieved by calling mkstemp()
  after constructing a suitable template.
  
    ($fh, $file) = tmpnam();
  
  If possible, this form should be used to prevent possible
  race conditions.
  
  See L<File::Spec/tmpdir> for information on the choice of temporary
  directory for a particular operating system.
  
  Will croak() if there is an error.
  
  =item B<tmpfile>
  
  Returns the filehandle of a temporary file.
  
    $fh = tmpfile();
  
  The file is removed when the filehandle is closed or when the program
  exits. No access to the filename is provided.
  
  If the temporary file can not be created undef is returned.
  Currently this command will probably not work when the temporary
  directory is on an NFS file system.
  
  Will croak() if there is an error.
  
  =back
  
  =head1 ADDITIONAL FUNCTIONS
  
  These functions are provided for backwards compatibility
  with common tempfile generation C library functions.
  
  They are not exported and must be addressed using the full package
  name.
  
  =over 4
  
  =item B<tempnam>
  
  Return the name of a temporary file in the specified directory
  using a prefix. The file is guaranteed not to exist at the time
  the function was called, but such guarantees are good for one
  clock tick only.  Always use the proper form of C<sysopen>
  with C<O_CREAT | O_EXCL> if you must open such a filename.
  
    $filename = File::Temp::tempnam( $dir, $prefix );
  
  Equivalent to running mktemp() with $dir/$prefixXXXXXXXX
  (using unix file convention as an example)
  
  Because this function uses mktemp(), it can suffer from race conditions.
  
  Will croak() if there is an error.
  
  =back
  
  =head1 UTILITY FUNCTIONS
  
  Useful functions for dealing with the filehandle and filename.
  
  =over 4
  
  =item B<unlink0>
  
  Given an open filehandle and the associated filename, make a safe
  unlink. This is achieved by first checking that the filename and
  filehandle initially point to the same file and that the number of
  links to the file is 1 (all fields returned by stat() are compared).
  Then the filename is unlinked and the filehandle checked once again to
  verify that the number of links on that file is now 0.  This is the
  closest you can come to making sure that the filename unlinked was the
  same as the file whose descriptor you hold.
  
    unlink0($fh, $path)
       or die "Error unlinking file $path safely";
  
  Returns false on error but croaks() if there is a security
  anomaly. The filehandle is not closed since on some occasions this is
  not required.
  
  On some platforms, for example Windows NT, it is not possible to
  unlink an open file (the file must be closed first). On those
  platforms, the actual unlinking is deferred until the program ends and
  good status is returned. A check is still performed to make sure that
  the filehandle and filename are pointing to the same thing (but not at
  the time the end block is executed since the deferred removal may not
  have access to the filehandle).
  
  Additionally, on Windows NT not all the fields returned by stat() can
  be compared. For example, the C<dev> and C<rdev> fields seem to be
  different.  Also, it seems that the size of the file returned by stat()
  does not always agree, with C<stat(FH)> being more accurate than
  C<stat(filename)>, presumably because of caching issues even when
  using autoflush (this is usually overcome by waiting a while after
  writing to the tempfile before attempting to C<unlink0> it).
  
  Finally, on NFS file systems the link count of the file handle does
  not always go to zero immediately after unlinking. Currently, this
  command is expected to fail on NFS disks.
  
  This function is disabled if the global variable $KEEP_ALL is true
  and an unlink on open file is supported. If the unlink is to be deferred
  to the END block, the file is still registered for removal.
  
  This function should not be called if you are using the object oriented
  interface since the it will interfere with the object destructor deleting
  the file.
  
  =item B<cmpstat>
  
  Compare C<stat> of filehandle with C<stat> of provided filename.  This
  can be used to check that the filename and filehandle initially point
  to the same file and that the number of links to the file is 1 (all
  fields returned by stat() are compared).
  
    cmpstat($fh, $path)
       or die "Error comparing handle with file";
  
  Returns false if the stat information differs or if the link count is
  greater than 1. Calls croak if there is a security anomaly.
  
  On certain platforms, for example Windows, not all the fields returned by stat()
  can be compared. For example, the C<dev> and C<rdev> fields seem to be
  different in Windows.  Also, it seems that the size of the file
  returned by stat() does not always agree, with C<stat(FH)> being more
  accurate than C<stat(filename)>, presumably because of caching issues
  even when using autoflush (this is usually overcome by waiting a while
  after writing to the tempfile before attempting to C<unlink0> it).
  
  Not exported by default.
  
  =item B<unlink1>
  
  Similar to C<unlink0> except after file comparison using cmpstat, the
  filehandle is closed prior to attempting to unlink the file. This
  allows the file to be removed without using an END block, but does
  mean that the post-unlink comparison of the filehandle state provided
  by C<unlink0> is not available.
  
    unlink1($fh, $path)
       or die "Error closing and unlinking file";
  
  Usually called from the object destructor when using the OO interface.
  
  Not exported by default.
  
  This function is disabled if the global variable $KEEP_ALL is true.
  
  Can call croak() if there is a security anomaly during the stat()
  comparison.
  
  =item B<cleanup>
  
  Calling this function will cause any temp files or temp directories
  that are registered for removal to be removed. This happens automatically
  when the process exits but can be triggered manually if the caller is sure
  that none of the temp files are required. This method can be registered as
  an Apache callback.
  
  Note that if a temp directory is your current directory, it cannot be
  removed.  C<chdir()> out of the directory first before calling
  C<cleanup()>. (For the cleanup at program exit when the CLEANUP flag
  is set, this happens automatically.)
  
  On OSes where temp files are automatically removed when the temp file
  is closed, calling this function will have no effect other than to remove
  temporary directories (which may include temporary files).
  
    File::Temp::cleanup();
  
  Not exported by default.
  
  =back
  
  =head1 PACKAGE VARIABLES
  
  These functions control the global state of the package.
  
  =over 4
  
  =item B<safe_level>
  
  Controls the lengths to which the module will go to check the safety of the
  temporary file or directory before proceeding.
  Options are:
  
  =over 8
  
  =item STANDARD
  
  Do the basic security measures to ensure the directory exists and is
  writable, that temporary files are opened only if they do not already
  exist, and that possible race conditions are avoided.  Finally the
  L<unlink0|"unlink0"> function is used to remove files safely.
  
  =item MEDIUM
  
  In addition to the STANDARD security, the output directory is checked
  to make sure that it is owned either by root or the user running the
  program. If the directory is writable by group or by other, it is then
  checked to make sure that the sticky bit is set.
  
  Will not work on platforms that do not support the C<-k> test
  for sticky bit.
  
  =item HIGH
  
  In addition to the MEDIUM security checks, also check for the
  possibility of ``chown() giveaway'' using the L<POSIX|POSIX>
  sysconf() function. If this is a possibility, each directory in the
  path is checked in turn for safeness, recursively walking back to the
  root directory.
  
  For platforms that do not support the L<POSIX|POSIX>
  C<_PC_CHOWN_RESTRICTED> symbol (for example, Windows NT) it is
  assumed that ``chown() giveaway'' is possible and the recursive test
  is performed.
  
  =back
  
  The level can be changed as follows:
  
    File::Temp->safe_level( File::Temp::HIGH );
  
  The level constants are not exported by the module.
  
  Currently, you must be running at least perl v5.6.0 in order to
  run with MEDIUM or HIGH security. This is simply because the
  safety tests use functions from L<Fcntl|Fcntl> that are not
  available in older versions of perl. The problem is that the version
  number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though
  they are different versions.
  
  On systems that do not support the HIGH or MEDIUM safety levels
  (for example Win NT or OS/2) any attempt to change the level will
  be ignored. The decision to ignore rather than raise an exception
  allows portable programs to be written with high security in mind
  for the systems that can support this without those programs failing
  on systems where the extra tests are irrelevant.
  
  If you really need to see whether the change has been accepted
  simply examine the return value of C<safe_level>.
  
    $newlevel = File::Temp->safe_level( File::Temp::HIGH );
    die "Could not change to high security"
        if $newlevel != File::Temp::HIGH;
  
  =item TopSystemUID
  
  This is the highest UID on the current system that refers to a root
  UID. This is used to make sure that the temporary directory is
  owned by a system UID (C<root>, C<bin>, C<sys> etc) rather than
  simply by root.
  
  This is required since on many unix systems C</tmp> is not owned
  by root.
  
  Default is to assume that any UID less than or equal to 10 is a root
  UID.
  
    File::Temp->top_system_uid(10);
    my $topid = File::Temp->top_system_uid;
  
  This value can be adjusted to reduce security checking if required.
  The value is only relevant when C<safe_level> is set to MEDIUM or higher.
  
  =item B<$KEEP_ALL>
  
  Controls whether temporary files and directories should be retained
  regardless of any instructions in the program to remove them
  automatically.  This is useful for debugging but should not be used in
  production code.
  
    $File::Temp::KEEP_ALL = 1;
  
  Default is for files to be removed as requested by the caller.
  
  In some cases, files will only be retained if this variable is true
  when the file is created. This means that you can not create a temporary
  file, set this variable and expect the temp file to still be around
  when the program exits.
  
  =item B<$DEBUG>
  
  Controls whether debugging messages should be enabled.
  
    $File::Temp::DEBUG = 1;
  
  Default is for debugging mode to be disabled.
  
  =back
  
  =head1 WARNING
  
  For maximum security, endeavour always to avoid ever looking at,
  touching, or even imputing the existence of the filename.  You do not
  know that that filename is connected to the same file as the handle
  you have, and attempts to check this can only trigger more race
  conditions.  It's far more secure to use the filehandle alone and
  dispense with the filename altogether.
  
  If you need to pass the handle to something that expects a filename
  then on a unix system you can use C<"/dev/fd/" . fileno($fh)> for
  arbitrary programs. Perl code that uses the 2-argument version of
  C<< open >> can be passed C<< "+<=&" . fileno($fh) >>. Otherwise you
  will need to pass the filename. You will have to clear the
  close-on-exec bit on that file descriptor before passing it to another
  process.
  
      use Fcntl qw/F_SETFD F_GETFD/;
      fcntl($tmpfh, F_SETFD, 0)
          or die "Can't clear close-on-exec flag on temp fh: $!\n";
  
  =head2 Temporary files and NFS
  
  Some problems are associated with using temporary files that reside
  on NFS file systems and it is recommended that a local filesystem
  is used whenever possible. Some of the security tests will most probably
  fail when the temp file is not local. Additionally, be aware that
  the performance of I/O operations over NFS will not be as good as for
  a local disk.
  
  =head2 Forking
  
  In some cases files created by File::Temp are removed from within an
  END block. Since END blocks are triggered when a child process exits
  (unless C<POSIX::_exit()> is used by the child) File::Temp takes care
  to only remove those temp files created by a particular process ID. This
  means that a child will not attempt to remove temp files created by the
  parent process.
  
  If you are forking many processes in parallel that are all creating
  temporary files, you may need to reset the random number seed using
  srand(EXPR) in each child else all the children will attempt to walk
  through the same set of random file names and may well cause
  themselves to give up if they exceed the number of retry attempts.
  
  =head2 Directory removal
  
  Note that if you have chdir'ed into the temporary directory and it is
  subsequently cleaned up (either in the END block or as part of object
  destruction), then you will get a warning from File::Path::rmtree().
  
  =head2 Taint mode
  
  If you need to run code under taint mode, updating to the latest
  L<File::Spec> is highly recommended.
  
  =head2 BINMODE
  
  The file returned by File::Temp will have been opened in binary mode
  if such a mode is available. If that is not correct, use the C<binmode()>
  function to change the mode of the filehandle.
  
  Note that you can modify the encoding of a file opened by File::Temp
  also by using C<binmode()>.
  
  =head1 HISTORY
  
  Originally began life in May 1999 as an XS interface to the system
  mkstemp() function. In March 2000, the OpenBSD mkstemp() code was
  translated to Perl for total control of the code's
  security checking, to ensure the presence of the function regardless of
  operating system and to help with portability. The module was shipped
  as a standard part of perl from v5.6.1.
  
  Thanks to Tom Christiansen for suggesting that this module
  should be written and providing ideas for code improvements and
  security enhancements.
  
  =head1 SEE ALSO
  
  L<POSIX/tmpnam>, L<POSIX/tmpfile>, L<File::Spec>, L<File::Path>
  
  See L<IO::File> and L<File::MkTemp>, L<Apache::TempFile> for
  different implementations of temporary file handling.
  
  See L<File::Tempdir> for an alternative object-oriented wrapper for
  the C<tempdir> function.
  
  =for Pod::Coverage STRINGIFY NUMIFY top_system_uid
  
  # vim: ts=2 sts=2 sw=2 et:
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<http://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/Perl-Toolchain-Gang/File-Temp>
  
    git clone https://github.com/Perl-Toolchain-Gang/File-Temp.git
  
  =head1 AUTHOR
  
  Tim Jenness <tjenness@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Ben Tilly <btilly@gmail.com>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Ed Avis <eda@linux01.wcl.local>
  
  =item *
  
  James E. Keenan <jkeen@verizon.net>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Kevin Ryde <user42@zip.com.au>
  
  =item *
  
  Olivier Mengue <dolmen@cpan.org>
  
  =item *
  
  Peter John Acklam <pjacklam@online.no>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Tim Jenness and the UK Particle Physics and Astronomy Research Council.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_TEMP

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Tue Oct  1 08:25:52 2013
  # Update Count    : 1651
  # Status          : Released
  
  ################ Module Preamble ################
  
  package Getopt::Long;
  
  use 5.004;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION        =  2.42;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.42";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT => "[-+]?[0-9_]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: (@$argv)",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( (defined ($cb = $linkage{'<>'})) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( $bundling && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt) if $ignorecase;
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0) ;#unless $mand;
  	$optarg = 0 unless $type eq 's';
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	# [-]NN[.NN][eNN]
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR;
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a scalar reference as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> (or C<@$libfiles>) would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  would set all three.
  
  Getopt::Long supports two levels of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The first level of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  would set C<a>, C<v> and C<x>, but
  
      --vax
  
  would set C<vax>.
  
  The second level of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> would set the option C<vax>.
  
  When any level of bundling is enabled, option values may be inserted
  in the bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  fully compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  Options that are unknown, ambiguous or supplied with an invalid option
  value are passed through in C<@ARGV> instead of being flagged as
  errors. This makes it possible to write wrapper scripts that process
  only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at
  the first unrecognized option, or non-option, whichever comes first.
  However, if C<permute> is enabled instead, results can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2013 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"IO/CaptureOutput.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_CAPTUREOUTPUT';
  # $Id: CaptureOutput.pm,v 1.3 2005/03/25 12:44:14 simonflack Exp $
  package IO::CaptureOutput;
  use strict;
  use vars qw/$VERSION @ISA @EXPORT_OK %EXPORT_TAGS $CarpLevel/;
  use Exporter;
  use Carp qw/croak/;
  @ISA = 'Exporter';
  @EXPORT_OK = qw/capture capture_exec qxx capture_exec_combined qxy/;
  %EXPORT_TAGS = (all => \@EXPORT_OK);
  $VERSION = '1.1102';
  $VERSION = eval $VERSION; ## no critic
  $CarpLevel = 0; # help capture report errors at the right level
  
  sub _capture (&@) { ## no critic
      my ($code, $output, $error, $output_file, $error_file) = @_;
  
      # check for valid combinations of input
      {
        local $Carp::CarpLevel = 1;
        my $error = _validate($output, $error, $output_file, $error_file);
        croak $error if $error;
      }
  
      # if either $output or $error are defined, then we need a variable for 
      # results; otherwise we only capture to files and don't waste memory
      if ( defined $output || defined $error ) {
        for ($output, $error) {
            $_ = \do { my $s; $s = ''} unless ref $_;
            $$_ = '' if $_ != \undef && !defined($$_);
        }
      }
  
      # merge if same refs for $output and $error or if both are undef -- 
      # i.e. capture \&foo, undef, undef, $merged_file
      # this means capturing into separate files *requires* at least one
      # capture variable
      my $should_merge = 
        (defined $error && defined $output && $output == $error) || 
        ( !defined $output && !defined $error ) || 
        0;
  
      my ($capture_out, $capture_err);
  
      # undef means capture anonymously; anything other than \undef means 
      # capture to that ref; \undef means skip capture
      if ( !defined $output || $output != \undef ) { 
          $capture_out = IO::CaptureOutput::_proxy->new(
              'STDOUT', $output, undef, $output_file
          );
      }
      if ( !defined $error || $error != \undef ) { 
          $capture_err = IO::CaptureOutput::_proxy->new(
              'STDERR', $error, ($should_merge ? 'STDOUT' : undef), $error_file
          );
      }
  
      # now that output capture is setup, call the subroutine
      # results get read when IO::CaptureOutput::_proxy objects go out of scope
      &$code();
  }
  
  # Extra indirection for symmetry with capture_exec, etc.  Gets error reporting
  # to the right level
  sub capture (&@) { ## no critic
      return &_capture; 
  }
  
  sub capture_exec {
      my @args = @_;
      my ($output, $error);
      my $exit = _capture sub { system _shell_quote(@args) }, \$output, \$error;
      my $success = ($exit == 0 ) ? 1 : 0 ;
      $? = $exit;
      return wantarray ? ($output, $error, $success, $exit) : $output;
  }
  
  *qxx = \&capture_exec;
  
  sub capture_exec_combined {
      my @args = @_;
      my $output;
      my $exit = _capture sub { system _shell_quote(@args) }, \$output, \$output;
      my $success = ($exit == 0 ) ? 1 : 0 ;
      $? = $exit;
      return wantarray ? ($output, $success, $exit) : $output;
  }
  
  *qxy = \&capture_exec_combined;
  
  # extra quoting required on Win32 systems
  *_shell_quote = ($^O =~ /MSWin32/) ? \&_shell_quote_win32 : sub {@_};
  sub _shell_quote_win32 {
      my @args;
      for (@_) {
          if (/[ \"]/) { # TODO: check if ^ requires escaping
              (my $escaped = $_) =~ s/([\"])/\\$1/g;
              push @args, '"' . $escaped . '"';
              next;
          }
          push @args, $_
      }
      return @args;
  }
  
  # detect errors and return an error message or empty string;
  sub _validate {
      my ($output, $error, $output_file, $error_file) = @_;
  
      # default to "ok"
      my $msg = q{};
  
      # \$out, \$out, $outfile, $errfile
      if (    defined $output && defined $error  
          &&  defined $output_file && defined $error_file
          &&  $output == $error
          &&  $output != \undef
          &&  $output_file ne $error_file
      ) {
        $msg = "Merged STDOUT and STDERR, but specified different output and error files";
      }
      # undef, undef, $outfile, $errfile
      elsif ( !defined $output && !defined $error  
          &&  defined $output_file && defined $error_file
          &&  $output_file ne $error_file
      ) {
        $msg = "Merged STDOUT and STDERR, but specified different output and error files";
      }
  
      return $msg;
  }
  
  # Captures everything printed to a filehandle for the lifetime of the object
  # and then transfers it to a scalar reference
  package IO::CaptureOutput::_proxy;
  use File::Temp 'tempfile';
  use File::Basename qw/basename/;
  use Symbol qw/gensym qualify qualify_to_ref/;
  use Carp;
  
  sub _is_wperl { $^O eq 'MSWin32' && basename($^X) eq 'wperl.exe' }
  
  sub new {
      my $class = shift;
      my ($orig_fh, $capture_var, $merge_fh, $capture_file) = @_;
      $orig_fh       = qualify($orig_fh);         # e.g. main::STDOUT
      my $fhref = qualify_to_ref($orig_fh);  # e.g. \*STDOUT
  
      # Duplicate the filehandle
      my $saved_fh;
      {
          no strict 'refs'; ## no critic - needed for 5.005
          if ( defined fileno($orig_fh) && ! _is_wperl() ) {
              $saved_fh = gensym;
              open $saved_fh, ">&$orig_fh" or croak "Can't redirect <$orig_fh> - $!";
          }
      }
  
      # Create replacement filehandle if not merging
      my ($newio_fh, $newio_file);
      if ( ! $merge_fh ) {
          $newio_fh = gensym;
          if ($capture_file) {
              $newio_file = $capture_file;
          } else {
              (undef, $newio_file) = tempfile;
          }
          open $newio_fh, "+>$newio_file" or croak "Can't write temp file for $orig_fh - $!";
      }
      else {
          $newio_fh = qualify($merge_fh);
      }
  
      # Redirect (or merge)
      {
          no strict 'refs'; ## no critic -- needed for 5.005
          open $fhref, ">&".fileno($newio_fh) or croak "Can't redirect $orig_fh - $!";
      }
  
      bless [$$, $orig_fh, $saved_fh, $capture_var, $newio_fh, $newio_file, $capture_file], $class;
  }
  
  sub DESTROY {
      my $self = shift;
  
      my ($pid, $orig_fh, $saved_fh, $capture_var, $newio_fh, 
        $newio_file, $capture_file) = @$self;
      return unless $pid eq $$; # only cleanup in the process that is capturing
  
      # restore the original filehandle
      my $fh_ref = Symbol::qualify_to_ref($orig_fh);
      select((select ($fh_ref), $|=1)[0]);
      if (defined $saved_fh) {
          open $fh_ref, ">&". fileno($saved_fh) or croak "Can't restore $orig_fh - $!";
      }
      else {
          close $fh_ref;
      }
  
      # transfer captured data to the scalar reference if we didn't merge
      # $newio_file is undef if this file handle is merged to another
      if (ref $capture_var && $newio_file) {
          # some versions of perl complain about reading from fd 1 or 2
          # which could happen if STDOUT and STDERR were closed when $newio
          # was opened, so we just squelch warnings here and continue
          local $^W; 
          seek $newio_fh, 0, 0;
          $$capture_var = do {local $/; <$newio_fh>};
      }
      close $newio_fh if $newio_file;
  
      # Cleanup
      return unless defined $newio_file && -e $newio_file;
      return if $capture_file; # the "temp" file was explicitly named
      unlink $newio_file or carp "Couldn't remove temp file '$newio_file' - $!";
  }
  
  1;
  
  __END__
  
  =pod
  
  =begin wikidoc
  
  = NAME
  
  IO::CaptureOutput - capture STDOUT and STDERR from Perl code, subprocesses or XS
  
  = VERSION
  
  This documentation describes version %%VERSION%%.
  
  = SYNOPSIS
  
      use IO::CaptureOutput qw(capture qxx qxy);
  
      # STDOUT and STDERR separately
      capture { noisy_sub(@args) } \$stdout, \$stderr;
  
      # STDOUT and STDERR together
      capture { noisy_sub(@args) } \$combined, \$combined;
  
      # STDOUT and STDERR from external command
      ($stdout, $stderr, $success) = qxx( @cmd );
  
      # STDOUT and STDERR together from external command
      ($combined, $success) = qxy( @cmd );
  
  = DESCRIPTION
  
  This module provides routines for capturing STDOUT and STDERR from perl 
  subroutines, forked system calls (e.g. {system()}, {fork()}) and from 
  XS or C modules.
  
  = FUNCTIONS
  
  The following functions will be exported on demand.
  
  == capture()
  
      capture \&subroutine, \$stdout, \$stderr;
  
  Captures everything printed to {STDOUT} and {STDERR} for the duration of
  {&subroutine}. {$stdout} and {$stderr} are optional scalars that will contain
  {STDOUT} and {STDERR} respectively. 
  
  {capture()} uses a code prototype so the first argument can be specified directly within 
  brackets if desired.
  
      # shorthand with prototype
      capture { print __PACKAGE__ } \$stdout, \$stderr;
  
  Returns the return value(s) of {&subroutine}. The sub is called in the same
  context as {capture()} was called e.g.:
  
      @rv = capture { wantarray } ; # returns true
      $rv = capture { wantarray } ; # returns defined, but not true
      capture { wantarray };       # void, returns undef
  
  {capture()} is able to capture output from subprocesses and C code, which
  traditional {tie()} methods of output capture are unable to do.
  
  *Note:* {capture()} will only capture output that has been written or flushed
  to the filehandle.
  
  If the two scalar references refer to the same scalar, then {STDERR} will be
  merged to {STDOUT} before capturing and the scalar will hold the combined
  output of both.
  
      capture \&subroutine, \$combined, \$combined;
  
  Normally, {capture()} uses anonymous, temporary files for capturing output.
  If desired, specific file names may be provided instead as additional options.
  
      capture \&subroutine, \$stdout, \$stderr, $out_file, $err_file;
  
  Files provided will be clobbered, overwriting any previous data, but
  will persist after the call to {capture()} for inspection or other manipulation.
  
  By default, when no references are provided to hold STDOUT or STDERR, output
  is captured and silently discarded.
  
      # Capture STDOUT, discard STDERR
      capture \&subroutine, \$stdout;
  
      # Discard STDOUT, capture STDERR
      capture \&subroutine, undef, \$stderr;
  
  However, even when using {undef}, output can be captured to specific files.
  
      # Capture STDOUT to a specific file, discard STDERR
      capture \&subroutine, \$stdout, undef, $outfile;
  
      # Discard STDOUT, capture STDERR to a specific file
      capture \&subroutine, undef, \$stderr, undef, $err_file;
  
      # Discard both, capture merged output to a specific file
      capture \&subroutine, undef, undef, $mergedfile;
  
  It is a fatal error to merge STDOUT and STDERR and request separate, specific
  files for capture.
  
      # ERROR:
      capture \&subroutine, \$stdout, \$stdout, $out_file, $err_file;
      capture \&subroutine, undef, undef, $out_file, $err_file;
  
  If either STDOUT or STDERR should be passed through to the terminal instead of
  captured, provide a reference to undef -- {\undef} -- instead of a capture
  variable.
  
      # Capture STDOUT, display STDERR
      capture \&subroutine, \$stdout, \undef;
  
      # Display STDOUT, capture STDERR
      capture \&subroutine, \undef, \$stderr;
  
  == capture_exec()
  
      ($stdout, $stderr, $success, $exit_code) = capture_exec(@args);
  
  Captures and returns the output from {system(@args)}. In scalar context,
  {capture_exec()} will return what was printed to {STDOUT}. In list context,
  it returns what was printed to {STDOUT} and {STDERR} as well as a success
  flag and the exit value.
  
      $stdout = capture_exec('perl', '-e', 'print "hello world"');
  
      ($stdout, $stderr, $success, $exit_code) = 
          capture_exec('perl', '-e', 'warn "Test"');
  
  {capture_exec} passes its arguments to {system()} and on MSWin32 will protect
  arguments with shell quotes if necessary.  This makes it a handy and slightly
  more portable alternative to backticks, piped {open()} and {IPC::Open3}.
  
  The {$success} flag returned will be true if the command ran successfully and
  false if it did not (if the command could not be run or if it ran and
  returned a non-zero exit value).  On failure, the raw exit value of the
  {system()} call is available both in the {$exit_code} returned and in the {$?}
  variable.
  
    ($stdout, $stderr, $success, $exit_code) = 
        capture_exec('perl', '-e', 'warn "Test" and exit 1');
  
    if ( ! $success ) {
        print "The exit code was " . ($exit_code >> 8) . "\n";
    }
  
  See [perlvar] for more information on interpreting a child process
  exit code.
  
  == capture_exec_combined()
  
      ($combined, $success, $exit_code) = capture_exec_combined(
          'perl', '-e', 'print "hello\n"', 'warn "Test\n"
      );
  
  This is just like {capture_exec()}, except that it merges {STDERR} with {STDOUT}
  before capturing output.
  
  *Note:* there is no guarantee that text printed to {STDOUT} and {STDERR} in the
  subprocess will be appear in order. The actual order will depend on how IO
  buffering is handled in the subprocess.
  
  == qxx()
  
  This is an alias for {capture_exec()}.
  
  == qxy()
  
  This is an alias for {capture_exec_combined()}.
  
  = SEE ALSO
  
  * [IPC::Open3]
  * [IO::Capture]
  * [IO::Utils]
  * [IPC::System::Simple]
  
  = AUTHORS
  
  * Simon Flack <simonflk _AT_ cpan.org> (original author)
  * David Golden <dagolden _AT_ cpan.org> (co-maintainer since version 1.04)
  
  = COPYRIGHT AND LICENSE
  
  Portions copyright 2004, 2005 Simon Flack.  Portions copyright 2007, 2008 David
  Golden.  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or
  the Artistic License, as specified in the Perl README file.
  
  =end wikidoc 
  
  =cut
IO_CAPTUREOUTPUT

$fatpacked{"IO/Interactive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_INTERACTIVE';
  package IO::Interactive;
  
  use version; $VERSION = qv('0.0.6');
  
  use warnings;
  use strict;
  use Carp;
  use Scalar::Util qw( openhandle );
  
  sub is_interactive {
      my ($out_handle) = (@_, select);    # Default to default output handle
  
      # Not interactive if output is not to terminal...
      return 0 if not -t $out_handle;
  
      # If *ARGV is opened, we're interactive if...
      if (openhandle *ARGV) {
          # ...it's currently opened to the magic '-' file
          return -t *STDIN if defined $ARGV && $ARGV eq '-';
  
          # ...it's at end-of-file and the next file is the magic '-' file
          return @ARGV>0 && $ARGV[0] eq '-' && -t *STDIN if eof *ARGV;
  
          # ...it's directly attached to the terminal 
          return -t *ARGV;
      }
  
      # If *ARGV isn't opened, it will be interactive if *STDIN is attached 
      # to a terminal.
      else {
          return -t *STDIN;
      }
  }
  
  local (*DEV_NULL, *DEV_NULL2);
  my $dev_null;
  BEGIN {
      pipe *DEV_NULL, *DEV_NULL2
          or die "Internal error: can't create null filehandle";
      $dev_null = \*DEV_NULL;
  }
  
  sub interactive {
      my ($out_handle) = (@_, \*STDOUT);      # Default to STDOUT
      return &is_interactive ? $out_handle : $dev_null;
  }
  
  sub _input_pending_on {
      my ($fh) = @_;
      my $read_bits = "";
      my $bit = fileno($fh);
      return if $bit < 0;
      vec($read_bits, fileno($fh), 1) = 1;
      select $read_bits, undef, undef, 0.1;
      return $read_bits;
  }
  
  sub busy (&) {
      my ($block_ref) = @_;
  
      # Non-interactive busy-ness is easy...just do it
      if (!is_interactive()) {
          $block_ref->();
          open my $fh, '<', \"";
          return $fh;
      }
  
      # Otherwise fork off an interceptor process...
      my ($read, $write);
      pipe $read, $write;
      my $child = fork;
  
      # Within that interceptor process...
      if (!$child) {
          # Prepare to send back any intercepted input...
          use IO::Handle;
          close $read;
          $write->autoflush(1);
  
          # Intercept that input...
          while (1) {
              if (_input_pending_on(\*ARGV)) {
                  # Read it...
                  my $res = <ARGV>;
  
                  # Send it back to the parent...
                  print {$write} $res;
  
                  # Admonish them for not waiting...
                  print {*STDERR} "That input was ignored. ",
                                  "Please don't press any keys yet.\n";
              }
          }
          exit;
      }
  
      # Meanwhile, back in the parent...
      close $write;
  
      # Temporarily close the input...
      local *ARGV;
      open *ARGV, '<', \"";
  
      # Do the job...
      $block_ref->();
  
      # Take down the interceptor...
      kill 9, $child;
      wait;
  
      # Return whatever the interceptor caught...
      return $read;
  }
  
  use Carp;
  
  sub import {
      my ($package) = shift;
      my $caller = caller;
  
      # Export each sub if it's requested...
      for my $request ( @_ ) {
          no strict 'refs';
          my $impl = *{$package.'::'.$request}{CODE};
          croak "Unknown subroutine ($request()) requested"
              if !$impl || $request =~ m/\A _/xms;
          *{$caller.'::'.$request} = $impl;
      }
  }
  
  
  1; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  IO::Interactive - Utilities for interactive I/O
  
  =head1 VERSION
  
  This document describes IO::Interactive version 0.0.6
  
  
  =head1 SYNOPSIS
  
      use IO::Interactive qw(is_interactive interactive busy);
  
      if ( is_interactive() ) {
          print "Running interactively\n";
      }
  
      # or...
  
      print {interactive} "Running interactively\n";
  
  
      $fh = busy {
          do_noninteractive_stuff();
      }
  
  
  =head1 DESCRIPTION
  
  This module provides three utility subroutines that make it easier to
  develop interactive applications...
  
  =over
  
  =item C<is_interactive()>
  
  This subroutine returns true if C<*ARGV> and the currently selected
  filehandle (usually C<*STDOUT>) are connected to the terminal. The 
  test is considerably more sophisticated than:
  
      -t *ARGV && -t *STDOUT
  
  as it takes into account the magic behaviour of C<*ARGV>.
  
  You can also pass C<is_interactive> a writable filehandle, in which case it
  requires that filehandle be connected to a terminal (instead of the
  currently selected).  The usual suspect here is C<*STDERR>:
  
      if ( is_interactive(*STDERR) ) {
          carp $warning;
      }
  
  
  =item C<interactive()>
  
  This subroutine returns C<*STDOUT> if C<is_interactive> is true. If
  C<is_interactive()> is false, C<interactive> returns a filehandle that
  does not print.
  
  This makes it easy to create applications that print out only when the
  application is interactive:
  
      print {interactive} "Please enter a value: ";
      my $value = <>;
  
  You can also pass C<interactive> a writable filehandle, in which case it
  writes to that filehandle if it is connected to a terminal (instead of 
  writinbg to C<*STDOUT>). Once again, the usual suspect is C<*STDERR>:
  
      print {interactive(*STDERR)} $warning;
  
  
  =item C<busy {...}>
  
  This subroutine takes a block as its single argument and executes that block.
  Whilst the block is executed, C<*ARGV> is temporarily replaced by a closed
  filehandle. That is, no input from C<*ARGV> is possible in a C<busy> block.
  Furthermore, any attempts to send input into the C<busy> block through
  C<*ARGV> is intercepted and a warning message is printed to C<*STDERR>.
  The C<busy> call returns a filehandle that contains the intercepted input.
  
  A C<busy> block is therefore useful to prevent attempts at input when the
  program is busy at some non-interactive task.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item Unknown subroutine (%s) requested
  
  This module only exports the three subroutines described above.
  You asked for something else. Maybe you misspelled the subroutine you wanted.
  
  =back
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  IO::Interactive requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  This module requires the C<openhandle()> subroutine from the
  Scalar::Util module.
  
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-io-interactive@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  Currently maintained by brian d foy C<< <bdfoy@cpan.org> >>
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
  =cut
IO_INTERACTIVE

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use strictures 1;
  use Moo::_Utils;
  use base qw(Moo::Object);
  use Sub::Quote;
  use B 'perlstring';
  use Scalar::Util 'blessed';
  use overload ();
  use Module::Runtime qw(use_module);
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
  }
  
  sub _SIGDIE
  {
    our ($CurrentAttribute, $OrigSigDie);
    my $sigdie = $OrigSigDie && $OrigSigDie != \&_SIGDIE
      ? $OrigSigDie
      : sub { die $_[0] };
    
    return $sigdie->(@_) if ref($_[0]);
    
    my $attr_desc = _attr_desc(@$CurrentAttribute{qw(name init_arg)});
    $sigdie->("$CurrentAttribute->{step} for $attr_desc failed: $_[0]");
  }
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    die "You cannot overwrite a locally defined method ($method) with @{[ $type || 'an accessor' ]}";
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      die "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ /\A[A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)*\z/;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
  
    for my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (!defined $spec->{default} || ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name", 'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      for my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${reader}")}{CODE};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${accessor}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${writer}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${pred}")}{CODE};
      $methods{$pred} =
        quote_sub "${into}::${pred}" =>
          '    '.$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $pred = $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $spec->{builder_sub} );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${cl}")}{CODE};
      $methods{$cl} =
        quote_sub "${into}::${cl}" => 
          $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], use_module('Role::Tiny')->methods_provided_by(use_module($hspec))
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && *{_getglob("${into}::${proxy}")}{CODE};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
  
  
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" => $self->_generate_asserter($name, $spec),
          delete $self->{captures}
        ;
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and ($spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\perlstring $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\perlstring $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa}
      ? "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n");
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
        : perlstring $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->_generate_simple_get(@args);
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $value_store = '$_[0]';
      my $code;
      if ($coerce) {
        $value_store = '$value';
        $code = "do { my (\$self, \$value) = \@_;\n"
          ."        \$value = "
          .$self->_generate_coerce($name, $value_store, $coerce).";\n";
      }
      else {
        $code = "do { my \$self = shift;\n";
      }
      if ($isa_check) {
        $code .= 
          "        ".$self->_generate_isa_check($name, $value_store, $isa_check).";\n";
      }
      my $simple = $self->_generate_simple_set('$self', $name, $spec, $value_store);
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', $value_store, $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        $value_store;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return perlstring($name) if !defined($init_arg) or $init_arg eq $name;
    return perlstring($name).' (constructor argument: '.perlstring($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce)
    );
  }
   
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_die_prefix {
    my ($self, $name, $prefix, $arg, $inside) = @_;
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'
    .'    init_arg => '.(defined $arg ? B::perlstring($arg) : 'undef') . ",\n"
    .'    name     => '.B::perlstring($name).",\n"
    .'    step     => '.B::perlstring($prefix).",\n"
    ."  };\n"
    .'  local $Method::Generate::Accessor::OrigSigDie = $SIG{__DIE__};'."\n"
    .'  local $SIG{__DIE__} = \&Method::Generate::Accessor::_SIGDIE;'."\n"
    .$inside
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_${name}};
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify(
          $code, $values, Sub::Quote::capture_unroll($cap_name, $captures, 6), $local
        );
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_${name}};
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $name, $spec
                        );
      my $get_value = 
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ($spec->{coerce}) {
        $get_value = $self->_generate_coerce(
          $name, $get_value,
          $spec->{coerce}, $init_arg
        )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}, $init_arg
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name, $spec),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $source,
              $spec->{coerce}, $init_arg
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}, $init_arg
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name, $spec),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      #Internals::SetReadWrite($foo);
      #Scalar::Util::weaken ($foo);
      #Internals::SetReadOnly($foo);
      #
      # but requires XS and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : $weak_simple;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
  
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  unless (".$self->_generate_simple_has('$_[0]', $name, $spec).") {\n"
     .qq!    die "Attempted to access '${name}' but it is not set";\n!
     ."  }\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using perlstring
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
    my $invalid = "Invalid $setting '" . overload::StrVal($value)
      . "' for $into not a coderef";
    $invalid .= " $appended" if $appended;
  
    unless (ref $value and (ref $value eq 'CODE' or blessed($value))) {
      die "$invalid or code-convertible object";
    }
  
    unless (eval { \&$value }) {
      die "$invalid and could not be converted to a coderef: $@";
    }
  
    1;
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B 'perlstring';
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @builds;
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use strictures 1;
  use Sub::Quote;
  use base qw(Moo::Object);
  use Sub::Defer;
  use B 'perlstring';
  use Moo::_Utils qw(_getstash);
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    my $specs = $self->{attribute_specs}||={};
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        die "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        foreach my $key (keys %$old_spec) {
          if (!exists $new_spec->{$key}) {
            $new_spec->{$key} = $old_spec->{$key}
              unless $key eq 'handles';
          }
          elsif ($key eq 'moosify') {
            $new_spec->{$key} = [
              map { ref $_ eq 'ARRAY' ? @$_ : $_ }
                ($old_spec->{$key}, $new_spec->{$key})
            ];
          }
        }
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub _build_construction_string {
    'bless('
      .$_[0]->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    my $package = $self->{package};
    defer_sub "${package}::new" => sub {
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      require Method::Generate::BuildAll;
      $body .= Method::Generate::BuildAll->new->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.perlstring($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg_key = perlstring($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $test{$_},
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my %s = %{$spec->{$_}}; # ignore required if default or builder set
          $s{required} and not($s{builder} or $s{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, qw('
      .join(' ',@required_init).')) {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  use Moo;
  Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'ro' },
  );
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B qw(perlstring);
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL(Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;
  
  use strictures 1;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
  	$fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same
  syntax that is used for barewords in Perl source.  In principle this
  syntax can vary between versions of Perl, and this module applies the
  syntax of the Perl on which it is running.  In practice the usable syntax
  hasn't changed yet, but there's a good chance of it changing in Perl 5.18.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.15.7.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  This may finally be addressed in the Perl 5.17 series.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.013";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	if(defined $version) {
  		$name->VERSION($version);
  	}
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and this function changed
  to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	check_module_name($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		$@ !~ /\ACan't locate .+ at \Q@{[__FILE__]}\E line/s;
  	$name->VERSION($version) if defined $version;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use strictures 1;
  use Moo::_Utils;
  use B 'perlstring';
  use Sub::Defer ();
  
  our $VERSION = '1.003001';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    strictures->import;
    if ($Role::Tiny::INFO{$target} and $Role::Tiny::INFO{$target}{is_role}) {
      die "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{"Role/Tiny.pm"} && $Role::Tiny::INFO{$superclass}) {
        require Carp;
        Carp::croak("Can't extend role '$superclass'");
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    no warnings 'once'; # piss off. -- mst
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              if (my $defer_target = 
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target, $select_super) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
      require Sub::Defer;
      my ($moo_constructor, $con);
  
      if ($select_super && $MAKERS{$select_super}) {
        $moo_constructor = 1;
        $con = $MAKERS{$select_super}{constructor};
      } else {
        my $t_new = $target->can('new');
        if ($t_new) {
          if ($t_new == Moo::Object->can('new')) {
            $moo_constructor = 1;
          } elsif (my $defer_target = (Sub::Defer::defer_info($t_new)||[])->[0]) {
            my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
            if ($MAKERS{$pkg}) {
              $moo_constructor = 1;
              $con = $MAKERS{$pkg}{constructor};
            }
          }
        } else {
          $moo_constructor = 1; # no other constructor, make a Moo one
        }
      };
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(
          package => $target,
          accessor_generator => $class->_accessor_maker_for($target),
          construction_string => (
            $moo_constructor
              ? ($con ? $con->construction_string : undef)
              : ('$class->'.$target.'::SUPER::new($class->can(q[FOREIGNBUILDARGS]) ? $class->FOREIGNBUILDARGS(@_) : @_)')
          ),
          subconstructor_handler => (
            '      if ($Moo::MAKERS{$class}) {'."\n"
            .'        '.$class.'->_constructor_maker_for($class,'.perlstring($target).');'."\n"
            .'        return $class->new(@_)'.";\n"
            .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
            .'        return $meta->new_object($class->BUILDARGS(@_));'."\n"
            .'      }'."\n"
          ),
        )
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  1;
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
   );
  
   has pounds => (
     is  => 'rw',
     isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  And elsewhere:
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  This module is an extremely light-weight subset of L<Moose> optimised for
  rapid startup and "pay only for what you use".
  
  It also avoids depending on any XS modules to allow simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite -- two
  thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead of provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  However, sometimes you're writing a command line script or a CGI script
  where fast startup is essential, or code designed to be deployed as a single
  file via L<App::FatPacker>, or you're writing a CPAN module and you want it
  to be usable by people with those constraints.
  
  I've tried several times to use L<Mouse> but it's 3x the size of Moo and
  takes longer to load than most of my Moo based CGI scripts take to run.
  
  If you don't want L<Moose>, you don't want "less metaprotocol" like L<Mouse>,
  you want "as little as possible" -- which means "no metaprotocol", which is
  what Moo provides.
  
  Better still, if you install and load L<Moose>, we set up metaclasses for your
  L<Moo> classes and L<Moo::Role> roles, so you can use them in L<Moose> code
  without ever noticing that some of your codebase is using L<Moo>.
  
  Hence, Moo exists as its name -- Minimal Object Orientation -- with a pledge
  to make it smooth to upgrade to L<Moose> when you need more than minimal
  features.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without anybody ever noticing you aren't using
  L<Moose> everywhere.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  classes and roles, so that C<< isa => 'MyClass' >> and C<< isa => 'MyRole' >>
  work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  So will extending a L<Mouse> class or consuming a L<Mouse::Role> - but note
  that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you want types to be upgraded to the L<Moose> types, use
  L<MooX::Types::MooseLike> and install the L<MooseX::Types> library to
  match the L<MooX::Types::MooseLike> library you're using - L<Moo> will
  load the L<MooseX::Types> library and use that type for the newly created
  metaclass.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  currently global and turns the mechanism off entirely so don't put this
  in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it
  will be used to generate simple accessors, readers, and writers for
  a speed boost.  Simple accessors are those without lazy defaults,
  type checks/coercions, or triggers.  Readers and writers generated
  by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   sub BUILDARGS {
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return { @args };
   };
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as C<BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares base class. Multiple superclasses can be passed for multiple
  inheritance (but please use roles instead).
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
  
  or
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles have conflicting methods.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
   package Foo;
   use Moo;
   has 'attr' => (
     is => 'ro'
   );
  
   package Bar;
   use Moo;
   extends 'Foo';
   has '+attr' => (
     default => sub { "blah" },
   );
  
  Using the C<+> notation, it's possible to override an attribute.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * is
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> generates an accessor that dies if you attempt to write to it - i.e.
  a getter only - by defaulting C<reader> to the name of the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> generates a reader like C<ro>, but also sets C<writer> to
  C<_set_${attribute_name}> for attributes that are designed to be written
  from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> generates a normal getter/setter by defaulting C<accessor> to the
  name of the attribute.
  
  =item * isa
  
  Takes a coderef which is meant to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   isa => sub {
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  Note that the return value is ignored, only whether the sub lives or
  dies matters.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<MooseX::Types> style named types, look at
  L<MooX::Types::MooseLike>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item * coerce
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always fire your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * handles
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a role (L<Moo::Role>) that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. Coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<default>
  
  Takes a coderef which will get called with $self as its only argument
  to populate an attribute if no value is supplied to the constructor - or
  if the attribute is lazy, when the attribute is first retrieved if no
  value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item * C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or <_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on instantiation.
  
  =item * C<reader>
  
  The value of this attribute will be the name of the method to get the value of
  the attribute.  If you like Java style methods, you might set this to
  C<get_foo>
  
  =item * C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item * C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened; use this when circular references are possible, which will cause
  leaks.
  
  =item * C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item * C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Moo;
    use Sub::Quote;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, just make a library of coderefs, or better yet, functions
  that return quoted subs. L<MooX::Types::MooseLike> provides a similar API
  to L<MooseX::Types::Moose> so that you can write
  
    has days_to_live => (is => 'ro', isa => Int);
  
  and have it work with both; it is hoped that providing only subrefs as an
  API will encourage the use of other type systems as well, since it's
  probably the weakest part of Moose design-wise.
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you wanted
  L<Moose> - Moo succeeds at being small because it explicitly does not
  provide a metaprotocol. However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  Handling of warnings: when you C<use Moo> we enable FATAL warnings.  The nearest
  similar invocation for L<Moose> would be:
  
    use Moose;
    use warnings FATAL => "all";
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
      package MyClass;
      use Moo;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
      package MyClass;
  
      use Moose;
      use MooseX::NonMoose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
      __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#moose@irc.perl.org">(click for instant chatroom login)</a>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#web-simple@irc.perl.org">(click for instant chatroom login)</a>
  
  Bugtracker: L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Moo>
  
  Git repository: L<git://git.shadowcat.co.uk/gitmo/Moo.git>
  
  Git web access: L<http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=gitmo/Moo.git>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2011 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_CONFLICTS';
  package # hide from PAUSE
      Moo::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Moo',
      -conflicts => {
          # enter conflicting downstream deps here, with the version indicating
          # the last *broken* version that *does not work*.
          'HTML::Restrict' => '2.1.5',
      },
  
      # these dists' ::Conflicts modules (if they exist) are also checked for
      # more incompatibilities -- should include all runtime prereqs here.
      -also => [ qw(
          Carp
          Class::Method::Modifiers
          strictures
          Module::Runtime
          Role::Tiny
          Devel::GlobalDestruction
      ) ],
  ;
  
  1;
MOO_CONFLICTS

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  
  use strictures 1;
  use Moo::_Utils;
  use B qw(perlstring);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', do { no warnings 'once'; keys %Moo::MAKERS };
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
      
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    for my $spec (values %$attr_specs) {
      if (my $inflators = delete $spec->{moosify}) {
        $_->($spec) for @$inflators;
      }
    }
  
    my %methods = %{Role::Tiny->_concrete_methods_of($name)};
  
    # if stuff gets added afterwards, _maybe_reset_handlemoose should
    # trigger the recreation of the metaclass but we need to ensure the
    # Role::Tiny cache is cleared so we don't confuse Moo itself.
    if (my $info = $Role::Tiny::INFO{$name}) {
      delete $info->{methods};
    }
  
    # needed to ensure the method body is stable and get things named
    Sub::Defer::undefer_sub($_) for grep defined, values %methods;
    my @attrs;
    {
      # This local is completely not required for roles but harmless
      local @{_getstash($name)}{keys %methods};
      my %seen_name;
      foreach my $name (@$attr_order) {
        $seen_name{$name} = 1;
        my %spec = %{$attr_specs->{$name}};
        my %spec_map = (
          map { $_->name => $_->init_arg||$_->name }
          (
            (grep { $_->has_init_arg }
               $meta->attribute_metaclass->meta->get_all_attributes),
            grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
            map {
              my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                           ->meta;
              map $meta->get_attribute($_), $meta->get_attribute_list
            }  @{$spec{traits}||[]}
          )
        );
        # have to hard code this because Moose's role meta-model is lacking
        $spec_map{traits} ||= 'traits';
  
        $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
        my $coerce = $spec{coerce};
        if (my $isa = $spec{isa}) {
          my $tc = $spec{isa} = do {
            if (my $mapped = $TYPE_MAP{$isa}) {
              my $type = $mapped->();
              Scalar::Util::blessed($type) && $type->isa("Moose::Meta::TypeConstraint")
                or die "error inflating attribute '$name' for package '$_[0]': \$TYPE_MAP{$isa} did not return a valid type constraint'";
              $coerce ? $type->create_child_type(name => $type->name) : $type;
            } else {
              Moose::Meta::TypeConstraint->new(
                constraint => sub { eval { &$isa; 1 } }
              );
            }
          };
          if ($coerce) {
            $tc->coercion(Moose::Meta::TypeCoercion->new)
               ->_compiled_type_coercion($coerce);
            $spec{coerce} = 1;
          }
        } elsif ($coerce) {
          my $attr = perlstring($name);
          my $tc = Moose::Meta::TypeConstraint->new(
                     constraint => sub { die "This is not going to work" },
                     inlined => sub {
                        'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                     },
                   );
          $tc->coercion(Moose::Meta::TypeCoercion->new)
             ->_compiled_type_coercion($coerce);
          $spec{isa} = $tc;
          $spec{coerce} = 1;
        }
        %spec =
          map { $spec_map{$_} => $spec{$_} }
          grep { exists $spec_map{$_} }
          keys %spec;
        push @attrs, $meta->add_attribute($name => %spec);
      }
      foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
        foreach my $attr ($mouse->get_all_attributes) {
          my %spec = %{$attr};
          delete @spec{qw(
            associated_class associated_methods __METACLASS__
            provides curries
          )};
          my $name = delete $spec{name};
          next if $seen_name{$name}++;
          push @attrs, $meta->add_attribute($name => %spec);
        }
      }
    }
    for my $meth_name (keys %methods) {
      my $meth_code = $methods{$meth_name};
      $meta->add_method($meth_name, $meth_code) if $meth_code;
    }
  
    if ($am_role) {
      my $info = $Moo::Role::INFO{$name};
      $meta->add_required_methods(@{$info->{requires}});
      foreach my $modifier (@{$info->{modifiers}}) {
        my ($type, @args) = @$modifier;
        my $code = pop @args;
        $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
      }
    } else {
      foreach my $attr (@attrs) {
        foreach my $method (@{$attr->associated_methods}) {
          $method->{body} = $name->can($method->name);
        }
      }
      bless(
        $meta->find_method_by_name('new'),
        'Moo::HandleMoose::FakeConstructor',
      );
      # a combination of Moo and Moose may bypass a Moo constructor but still
      # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
      # global destruction.
      require Method::Generate::DemolishAll;
    }
    $meta->add_role(Class::MOP::class_of($_))
      for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
        do { no warnings 'once'; keys %{$Role::Tiny::APPLIED_TO{$name}} };
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->$meth(@_)
  }
  sub can {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->can(@_)
  }
  sub isa {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use strictures 1;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    $NO_BUILD{$class} and
      return bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class)
      : do {
          my $proto = ref($_[0]) eq 'HASH' ? $_[0] : { @_ };
          bless({ %$proto }, $class)->BUILDALL($proto);
        };
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    require Role::Tiny;
    { no warnings 'redefine'; *does = \&Role::Tiny::does_role }
    goto &Role::Tiny::does_role;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use strictures 1;
  use Moo::_Utils;
  use Role::Tiny ();
  use base qw(Role::Tiny);
  
  our $VERSION = '1.003001';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  
  BEGIN { *INFO = \%Role::Tiny::INFO }
  
  our %INFO;
  our %APPLY_DEFAULTS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my ($me) = @_;
    strictures->import;
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      die "Cannot import Moo::Role into a Moo class";
    }
    $INFO{$target} ||= {};
    # get symbol table reference
    my $stash = _getstash($target);
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    return if $INFO{$target}{is_role}; # already exported into this package
    $INFO{$target}{is_role} = 1;
    *{_getglob("${target}::meta")} = $me->can('meta');
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later) with a map to the coderefs in case of copying or re-use
    my @not_methods = ('', map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $Role::Tiny::APPLIED_TO{$target} = { $target => undef };
  
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    _load_module($role);
    my $meta;
    if (!$INFO{$role}
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $Role::Tiny::APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $is_mouse = $meta->isa('Mouse::Meta::Role');
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
  
            $spec->{isa} = sub {
              &$check or die "Type constraint failed for $_[0]"
            };
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      require Class::Method::Modifiers if @$mods;
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      $me->_inhale_if_moose($role);
      die "${role} is not a Moo::Role" unless $INFO{$role};
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    $me->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $INFO{$role};
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
        $me->_inhale_if_moose($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      *{_getglob("${new_name}::ISA")} = [ $superclass ];
      $me->apply_roles_to_package($new_name, @roles);
      return $new_name;
    }
  
    require Sub::Quote;
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Role::Tiny" unless $INFO{$role};
    }
  
    $Moo::MAKERS{$new_name} = {is_class => 1};
  
    $me->_handle_constructor($new_name, $_) for @roles;
  
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
  
    my $apply_defaults = $APPLY_DEFAULTS{ref $new} ||= do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for(ref $new)
          and my $m = Moo->_accessor_maker_for(ref $new)) {
        require Sub::Quote;
  
        my $specs = $con_gen->all_attribute_specs;
  
        my $assign = '';
        my %captures;
        foreach my $name ( keys %attrs ) {
          my $spec = $specs->{$name};
          if ($m->has_eager_default($name, $spec)) {
            my ($has, $has_cap)
              = $m->generate_simple_has('$_[0]', $name, $spec);
            my ($code, $pop_cap)
              = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
            $assign .= $code;
            @captures{keys %$has_cap, keys %$pop_cap}
              = (values %$has_cap, values %$pop_cap);
          }
        }
        Sub::Quote::quote_sub($assign, \%captures);
      }
      else {
        sub {};
      }
    };
    $new->$apply_defaults;
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $Role::Tiny::COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    if ($INFO{$to}) {
      push @{$INFO{$to}{attributes}||=[]}, @$attr_info;
    } else {
      # only fiddle with the constructor if the target is a Moo class
      if ($INC{"Moo.pm"}
          and my $con = Moo->_constructor_maker_for($to)) {
        # shallow copy of the specs since the constructor will assign an index
        $con->register_attribute_specs(map ref() ? { %$_ } : $_, @$attr_info);
      }
    }
  }
  
  1;
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  And elsewhere:
  
   package Some::Class;
  
   use Moo;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  
  no warnings 'once'; # guard against -w
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use constant lt_5_8_3 => ( $] < 5.008003 or $ENV{MOO_TEST_PRE_583} ) ? 1 : 0;
  use constant can_haz_subname => eval { require Sub::Name };
  
  use strictures 1;
  use Module::Runtime qw(require_module);
  use Devel::GlobalDestruction ();
  use base qw(Exporter);
  use Moo::_mro;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa _getstash _install_coderef _name_coderef
      _unimport_coderefs _in_global_destruction
  );
  
  sub _in_global_destruction ();
  *_in_global_destruction = \&Devel::GlobalDestruction::in_global_destruction;
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      require Sub::Defer;
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  sub _load_module {
    (my $proto = $_[0]) =~ s/::/\//g;
    return 1 if $INC{"${proto}.pm"};
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($_[0])||{};
    return 1 if grep +(!ref($_) and *$_{CODE}), values %$stash;
    require_module($_[0]);
    return 1;
  }
  
  sub _maybe_load_module {
    return $MAYBE_LOADED{$_[0]} if exists $MAYBE_LOADED{$_[0]};
    (my $proto = $_[0]) =~ s/::/\//g;
    local $@;
    if (eval { require "${proto}.pm"; 1 }) {
      $MAYBE_LOADED{$_[0]} = 1;
    } else {
      if (exists $INC{"${proto}.pm"}) {
        warn "$_[0] exists but failed to load with error: $@";
      }
      $MAYBE_LOADED{$_[0]} = 0;
    }
    return $MAYBE_LOADED{$_[0]};
  }
  
  sub _get_linear_isa {
    return mro::get_linear_isa($_[0]);
  }
  
  sub _install_coderef {
    no warnings 'redefine';
    *{_getglob($_[0])} = _name_coderef(@_);
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    can_haz_subname ? Sub::Name::subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  sub STANDARD_DESTROY {
    my $self = shift;
  
    my $e = do {
      local $?;
      local $@;
      eval {
        $self->DEMOLISHALL(_in_global_destruction);
      };
      $@;
    };
  
    no warnings 'misc';
    die $e if $e; # rethrow
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use strictures 1;
  use Moo::_Utils ();
  
  sub unimport { our $disarmed = 1 }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disarmed or Moo::_Utils::_in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  if ($INC{"Moose.pm"}) {
    require Moo::HandleMoose;
    Moo::HandleMoose->import;
  } else {
    $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
  }
  
  1;
MOO_SIFICATION

$fatpacked{"Reply/Plugin/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REPLY_PLUGIN_TYPETINY';
  package Reply::Plugin::TypeTiny;
  
  use strict;
  use warnings;
  
  BEGIN {
  	$Reply::Plugin::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Reply::Plugin::TypeTiny::VERSION   = '0.034';
  };
  
  require Reply::Plugin;
  our @ISA = 'Reply::Plugin';
  
  use Scalar::Util qw(blessed);
  use Term::ANSIColor;
  
  sub mangle_error {
  	my $self  = shift;
  	my ($err) = @_;
  	
  	if (blessed $err and $err->isa("Error::TypeTiny::Assertion"))
  	{
  		my $explain = $err->explain;
  		if ($explain)
  		{
  			print color("cyan");
  			print "Error::TypeTiny::Assertion explain:\n";
  			$self->_explanation($explain, "");
  			local $| = 1;
  			print "\n";
  			print color("reset");
  		}
  	}
  	
  	return @_;
  }
  
  sub _explanation
  {
  	my $self = shift;
  	my ($ex, $indent)  = @_;
  	
  	for my $line (@$ex)
  	{
  		if (ref($line) eq q(ARRAY))
  		{
  			print "$indent * Explain:\n";
  			$self->_explanation($line, "$indent   ");
  		}
  		else
  		{
  			print "$indent * $line\n";
  		}
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Reply::Plugin::TypeTiny - improved type constraint exceptions in Reply
  
  =head1 DESCRIPTION
  
  This is a small plugin to improve error messages in L<Reply>.
  Not massively tested.
  
  =begin trustme
  
  =item mangle_error
  
  =end trustme
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>, L<Reply>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
REPLY_PLUGIN_TYPETINY

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings FATAL => 'all';
  
  our $VERSION = '1.003002'; # 1.3.2
  $VERSION = eval $VERSION;
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  our %COMPOSITE_INFO;
  
  # Module state workaround totally stolen from Zefram's Module::Runtime.
  
  BEGIN {
    *_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  sub Role::Tiny::__GUARD__::DESTROY {
    delete $INC{$_[0]->[0]} if @{$_[0]};
  }
  
  sub _load_module {
    (my $proto = $_[0]) =~ s/::/\//g;
    $proto .= '.pm';
    return 1 if $INC{$proto};
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1 if grep !/::$/, keys %{_getstash($_[0])||{}};
    my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
      && bless([ $proto ], 'Role::Tiny::__GUARD__');
    require $proto;
    pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
    return 1;
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strict->import;
    warnings->import(FATAL => 'all');
    return if $INFO{$target}; # already exported into this package
    $INFO{$target}{is_role} = 1;
    # get symbol table reference
    my $stash = _getstash($target);
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        return;
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      return;
    };
    *{_getglob "${target}::with"} = sub {
      $me->apply_roles_to_package($target, @_);
      return;
    };
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) with a map to the coderefs in
    # case of copying or re-use
    my @not_methods = (map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
  }
  
  sub role_application_steps {
    qw(_install_methods _check_requires _install_modifiers _copy_applied_list);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    die "This is apply_role_to_package" if ref($to);
    die "${role} is not a Role::Tiny" unless $INFO{$role};
  
    foreach my $step ($me->role_application_steps) {
      $me->$step($to, $role);
    }
  }
  
  sub _copy_applied_list {
    my ($me, $to, $role) = @_;
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    die "No roles supplied!" unless @roles;
    my $class = ref($object);
    bless($object, $me->create_class_with_roles($class, @roles));
    $object;
  }
  
  my $role_suffix = 'A000';
  sub _composite_name {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    if (length($new_name) > 252) {
      $new_name = $COMPOSED{abbrev}{$new_name}
        ||= substr($new_name, 0, 250 - length $role_suffix).'__'.$role_suffix++;
    }
    return wantarray ? ($new_name, $compose_name) : $new_name;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    die "No roles supplied!" unless @roles;
  
    _load_module($superclass);
    {
      my %seen;
      $seen{$_}++ for @roles;
      if (my @dupes = grep $seen{$_} > 1, @roles) {
        die "Duplicated roles: ".join(', ', @dupes);
      }
    }
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      die "${role} is not a Role::Tiny" unless $INFO{$role};
    }
  
    if ($] >= 5.010) {
      require mro;
    } else {
      require MRO::Compat;
    }
  
    my $composite_info = $me->_composite_info_for(@roles);
    my %conflicts = %{$composite_info->{conflicts}};
    if (keys %conflicts) {
      my $fail = 
        join "\n",
          map {
            "Method name conflict for '$_' between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", cannot apply these simultaneously to an object."
          } keys %conflicts;
      die $fail;
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    # some methods may not exist in the role, but get generated by
    # _composable_package_for (Moose accessors via Moo).  filter out anything
    # provided by the composable packages, excluding the subs we generated to
    # make modifiers work.
    my @requires = grep {
      my $method = $_;
      !grep $_->can($method) && !$COMPOSED{role}{$_}{modifiers_only}{$method},
        @composable
    } @{$composite_info->{requires}};
  
    $me->_check_requires(
      $superclass, $compose_name, \@requires
    );
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  # preserved for compat, and apply_roles_to_package calls it to allow an
  # updated Role::Tiny to use a non-updated Moo::Role
  
  sub apply_role_to_package { shift->apply_single_role_to_package(@_) }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
  
    return $me->apply_role_to_package($to, $roles[0]) if @roles == 1;
  
    my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
    delete $conflicts{$_} for keys %{ $me->_concrete_methods_of($to) };
    if (keys %conflicts) {
      my $fail = 
        join "\n",
          map {
            "Due to a method name conflict between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", the method '$_' must be implemented by '${to}'"
          } keys %conflicts;
      die $fail;
    }
  
    # the if guard here is essential since otherwise we accidentally create
    # a $INFO for something that isn't a Role::Tiny (or Moo::Role) because
    # autovivification hates us and wants us to die()
    if ($INFO{$to}) {
      delete $INFO{$to}{methods}; # reset since we're about to add methods
    }
  
    # backcompat: allow subclasses to use apply_single_role_to_package
    # to apply changes.  set a local var so ours does nothing.
    our %BACKCOMPAT_HACK;
    if($me ne __PACKAGE__
        and exists $BACKCOMPAT_HACK{$me} ? $BACKCOMPAT_HACK{$me} :
        $BACKCOMPAT_HACK{$me} =
          $me->can('role_application_steps')
            == \&role_application_steps
          && $me->can('apply_single_role_to_package')
            != \&apply_single_role_to_package
    ) {
      foreach my $role (@roles) {
        $me->apply_single_role_to_package($to, $role);
      }
    }
    else {
      foreach my $step ($me->role_application_steps) {
        foreach my $role (@roles) {
          $me->$step($to, $role);
        }
      }
    }
    $APPLIED_TO{$to}{join('|',@roles)} = 1;
  }
  
  sub _composite_info_for {
    my ($me, @roles) = @_;
    $COMPOSITE_INFO{join('|', sort @roles)} ||= do {
      foreach my $role (@roles) {
        _load_module($role);
      }
      my %methods;
      foreach my $role (@roles) {
        my $this_methods = $me->_concrete_methods_of($role);
        $methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
      }
      my %requires;
      @requires{map @{$INFO{$_}{requires}||[]}, @roles} = ();
      delete $requires{$_} for keys %methods;
      delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
      +{ conflicts => \%methods, requires => [keys %requires] }
    };
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    # force stash to exist so ->can doesn't complain
    _getstash($base_name);
    # Not using _getglob, since setting @ISA via the typeglob breaks
    # inheritance on 5.10.0 if the stash has previously been accessed an
    # then a method called on the class (in that order!), which
    # ->_install_methods (with the help of ->_install_does) ends up doing.
    { no strict 'refs'; @{"${composed_name}::ISA"} = ( $base_name ); }
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    my @modifiers = grep !$composed_name->can($_),
      do { my %h; @h{map @{$_}[1..$#$_-1], @$modifiers} = (); keys %h };
    foreach my $modified (@modifiers) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    my $e;
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      $e = "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    die $e if $e;
    $me->_install_modifiers($composed_name, $role);
    $COMPOSED{role}{$composed_name} = {
      modifiers_only => { map { $_ => 1 } @modifiers },
    };
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, $requires) = @_;
    return unless my @requires = @{$requires||$INFO{$name}{requires}||[]};
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        die "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$info->{not_methods}||{}} };
    $info->{methods} ||= +{
      # grab all code entries that aren't in the not_methods list
      map {
        my $code = *{$stash->{$_}}{CODE};
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    die "${role} is not a Role::Tiny" unless my $info = $INFO{$role};
    (keys %{$me->_concrete_methods_of($role)}, @{$info->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = _getstash($to);
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      *{_getglob "${to}::${i}"} = $methods->{$i};
    }
    
    $me->_install_does($to);
  }
  
  sub _install_modifiers {
    my ($me, $to, $name) = @_;
    return unless my $modifiers = $INFO{$name}{modifiers};
    if (my $info = $INFO{$to}) {
      push @{$info->{modifiers}}, @{$modifiers||[]};
    } else {
      foreach my $modifier (@{$modifiers||[]}) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  my $vcheck_error;
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    defined($vcheck_error) or $vcheck_error = do {
      local $@;
      eval { Class::Method::Modifiers->VERSION(1.05); 1 }
        ? 0
        : $@
    };
    $vcheck_error and die $vcheck_error;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  my $FALLBACK = sub { 0 };
  sub _install_does {
    my ($me, $to) = @_;
    
    # only add does() method to classes
    return if $INFO{$to};
    
    # add does() only if they don't have one
    *{_getglob "${to}::does"} = \&does_role unless $to->can('does');
    
    return if ($to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0));
    
    my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
    my $new_sub = sub {
      my ($proto, $role) = @_;
      Role::Tiny::does_role($proto, $role) or $proto->$existing($role);
    };
    no warnings 'redefine';
    *{_getglob "${to}::DOES"} = $new_sub;
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    if ($] >= 5.010) {
      require mro;
    } else {
      require MRO::Compat;
    }
    foreach my $class (@{mro::get_linear_isa(ref($proto)||$proto)}) {
      return 1 if exists $APPLIED_TO{$class}{$role};
    }
    return 0;
  }
  
  sub is_role {
    my ($me, $role) = @_;
    return !!$INFO{$role};
  }
  
  1;
  
  =encoding utf-8
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cuisine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   around baz => sub { ... }
  
   1;
  
  else where
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   # baz is wrapped in the around modifier by Class::Method::Modifiers
   sub baz { ... }
  
   1;
  
  If you wanted attributes as well, look at L<Moo::Role>.
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where the class wins. If multiple roles
  are applied in a single call (single with statement), then if any of their
  provided methods clash, an exception is raised unless the class provides
  a method since this conflict indicates a potential problem.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes another role into the current role (or class via L<Role::Tiny::With>).
  
  If you have conflicts and want to resolve them in favour of Some::Role1 you
  can instead write: 
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  If you have conflicts and want to resolve different conflicts in favour of
  different roles, please refactor your codebase.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly.
  
  Additionally, Role::Tiny will override the standard Perl C<DOES> method
  for your class. However, if C<any> class in your class' inheritance
  hierarchy provides C<DOES>, then Role::Tiny will not override it.
  
  =head1 METHODS
  
  =head2 apply_roles_to_package
  
   Role::Tiny->apply_roles_to_package(
     'Some::Package', 'Some::Role', 'Some::Other::Role'
   );
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly.  Object is reblessed into the
  resulting class.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head2 is_role
  
   Role::Tiny->is_role('Some::Role1')
  
  Returns true if the given package is a role.
  
  =head1 SEE ALSO
  
  L<Role::Tiny> is the attribute-less subset of L<Moo::Role>; L<Moo::Role> is
  a meta-protocol-less subset of the king of role systems, L<Moose::Role>.
  
  If you don't want method modifiers and do want to be forcibly restricted
  to a single role application per class, Ovid's L<Role::Basic> exists. But
  Stevan Little (the L<Moose> author) and I don't find the additional
  restrictions to be amazingly helpful in most cases; L<Role::Basic>'s choices
  are more a guide to what you should prefer doing, to our mind, rather than
  something that needs to be enforced.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2012 the Role::Tiny L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings FATAL => 'all';
  use Role::Tiny ();
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_roles_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Role::Tiny> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Role::Tiny> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  
  use strictures 1;
  use base qw(Exporter);
  use Moo::_Utils;
  use Scalar::Util qw(weaken);
  
  our $VERSION = '1.003001';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    weaken($DEFERRED{$made} = $DEFERRED{$deferred});
  
    return $made;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    $DEFERRED{$deferred||''};
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_info;
    my $deferred = sub {
      $undeferred ||= undefer_sub($deferred_info->[3]);
      goto &$undeferred;
    };
    $deferred_info = [ $target, $maker, \$undeferred, $deferred ];
    weaken($DEFERRED{$deferred} = $deferred_info);
    _install_coderef($target => $deferred) if defined $target;
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map { defined $_ ? ($_->[3] => $_) : () } values %DEFERRED;
    weaken($_) for values %DEFERRED;
  }
  
  1;
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.001011';
  
  use Carp ();
  use List::Util ();
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if (List::Util::first { ref || !m/ \A [:-]? \w+ \z /xm } @args) {
           Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif (defined(my $num = List::Util::first { !ref and m/^\d/ } @args)) {
           die "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ($setup eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              Carp::croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              Carp::croak $too_complicated if List::Util::first { ref } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 Carp::croak $too_complicated if List::Util::first { / \A - (?! all \b ) /x || ref } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              Carp::croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        Carp::croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 AUTHOR
  
  frew - Arthur Axel Schmidt (cpan:FREW) <frioux+cpan@gmail.com>
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Sub::Exporter::Progressive L</AUTHOR> and
  L</CONTRIBUTORS> as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  use strictures 1;
  
  sub _clean_eval { eval $_[0] }
  
  use Sub::Defer;
  use B 'perlstring';
  use Scalar::Util qw(weaken);
  use base qw(Exporter);
  
  our $VERSION = '1.003001';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub);
  
  our %QUOTED;
  
  our %WEAK_REFS;
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if (my ($code_args, $body) = $code =~ / +my \(([^)]+)\) = \@_;(.*)$/s) {
      if ($code_args eq $args) {
        $do.$body.' }'
      } else {
        $do.'my ('.$code_args.') = ('.$args.'); '.$body.' }';
      }
    } else {
      my $assign = '';
      if ($local || $args ne '@_') {
        $assign = ($local ? 'local ' : '').'@_ = ('.$args.'); ';
      }
      $do.$assign.$code.' }';
    }
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = pop if ref($_[-1]) eq 'HASH';
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my $quoted_info;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      unquote_sub($quoted_info->[4]);
    };
    $quoted_info = [ $name, $code, $captures, undef, $deferred ];
    weaken($QUOTED{$deferred} = $quoted_info);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    $QUOTED{$sub||''};
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    unless ($QUOTED{$sub}[3]) {
      my ($name, $code, $captures) = @{$QUOTED{$sub}};
  
      my $make_sub = "{\n";
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_QUOTED'} = \$QUOTED{$sub};
      $make_sub .= capture_unroll("\$_[1]", \%captures, 2);
  
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$_QUOTED->[3] = sub {\n"
      );
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$_QUOTED->[3] = \\&${name}\n";
      }
      $make_sub .= "}\n1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        local $@;
        no strict 'refs';
        local *{$name} if $name;
        unless (_clean_eval $make_sub, \%captures) {
          die "Eval went very, very wrong:\n\n${make_sub}\n\n$@";
        }
      }
    }
    $QUOTED{$sub}[3];
  }
  
  sub CLONE {
    %QUOTED = map { defined $_ ? ($_->[4] => $_) : () } values %QUOTED;
    weaken($_) for values %QUOTED;
  }
  
  1;
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   };
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few caveats
  apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 strictures
  
  Sub::Quote compiles quoted subs in an environment where C<< use strictures >>
  is in effect. L<strictures> enables L<strict> and FATAL L<warnings>.
  
  The following dies I<< Use of uninitialized value in print... >>
  
   no warnings;
   quote_sub 'Silly::kitty', q{ print undef };
  
  If you need to disable parts of strictures, do it within the quoted sub:
  
   quote_sub 'Silly::kitty', q{ no warnings; print undef };
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
SUB_QUOTE

$fatpacked{"Test/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TYPETINY';
  package Test::TypeTiny;
  
  use strict;
  use warnings;
  
  use Test::More qw();
  use Scalar::Util qw(blessed);
  use Types::TypeTiny qw(to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN {
  	*EXTENDED_TESTING = $ENV{EXTENDED_TESTING} ? sub(){!!1} : sub(){!!0};
  };
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  our @EXPORT    = qw( should_pass should_fail ok_subtype );
  our @EXPORT_OK = qw( EXTENDED_TESTING matchfor );
  
  sub matchfor
  {
  	my @matchers = @_;
  	bless \@matchers, do {
  		package #
  		Test::TypeTiny::Internal::MATCHFOR;
  		use overload
  			q[==] => 'match',
  			q[eq] => 'match',
  			q[""] => 'to_string',
  			fallback => 1;
  		sub to_string {
  			$_[0][0]
  		}
  		sub match {
  			my ($self, $e) = @_;
  			my $does = Scalar::Util::blessed($e) ? ($e->can('DOES') || $e->can('isa')) : undef;
  			for my $s (@$self) {
  				return 1 if  ref($s) && $e =~ $s;
  				return 1 if !ref($s) && $does && $e->$does($s);
  			}
  			return;
  		}
  		__PACKAGE__;
  	};
  }
  
  sub _mk_message
  {
  	require Type::Tiny;
  	my ($template, $value) = @_;
  	sprintf($template, Type::Tiny::_dd($value));
  }
  
  sub ok_subtype
  {
  	my ($type, @s) = @_;
  	@_ = (
  		not(scalar grep !$_->is_subtype_of($type), @s),
  		sprintf("%s subtype: %s", $type, join q[, ], @s),
  	);
  	goto \&Test::More::ok;
  }
  
  eval(EXTENDED_TESTING ? <<'SLOW' : <<'FAST');
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!!$type->check($value), '->check');
  	$test->ok(!!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!$type->check($value), '->check');
  	$test->ok(!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  SLOW
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!!$type->check($value),
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!$type->check($value),
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  FAST
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Test::TypeTiny - useful functions for testing the efficacy of type constraints
  
  =head1 SYNOPSIS
  
     use strict;
     use warnings;
     use Test::More;
     use Test::TypeTiny;
     
     use Types::Mine qw(Integer);
     
     should_pass(1, Integer);
     should_pass(-1, Integer);
     should_pass(0, Integer);
     should_fail(2.5, Integer);
     
     ok_subtype(Number, Integer);
     
     done_testing;
  
  =head1 DESCRIPTION
  
  L<Test::TypeTiny> provides a few handy functions for testing type constraints.
  
  =head2 Functions
  
  =over
  
  =item C<< should_pass($value, $type, $test_name) >>
  
  =item C<< should_pass($value, $type) >>
  
  Test that passes iff C<< $value >> passes C<< $type->check >>.
  
  =item C<< should_fail($value, $type, $test_name) >>
  
  =item C<< should_fail($value, $type) >>
  
  Test that passes iff C<< $value >> fails C<< $type->check >>.
  
  =item C<< ok_subtype($type, @subtypes) >>
  
  Test that passes iff all C<< @subtypes >> are subtypes of C<< $type >>.
  
  =item C<< EXTENDED_TESTING >>
  
  Exportable boolean constant.
  
  =item C<< matchfor(@things) >>
  
  Assistant for matching exceptions. Not exported by default.
  See also L<Test::Fatal::matchfor>.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the C<EXTENDED_TESTING> environment variable is set to true, this
  module will promote each C<should_pass> or C<should_fail> test into a
  subtest block and test the type constraint in both an inlined and
  non-inlined manner.
  
  This variable must be set at compile time (i.e. before this module is
  loaded).
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  For an alternative to C<should_pass>, see L<Test::Deep::Type> which will
  happily accept a Type::Tiny type constraint instead of a MooseX::Types one.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TEST_TYPETINY

$fatpacked{"Test/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_YAML';
  package Test::YAML;
  
  use Test::Base 0.47 -Base;
  use lib 'lib';
  
  our $VERSION = '0.84';
  
  our $YAML    = 'YAML';
  our @EXPORT  = qw(
      no_diff
      run_yaml_tests
      run_roundtrip_nyn roundtrip_nyn
      run_load_passes load_passes
      dumper Load Dump LoadFile DumpFile
      XXX
  );
  
  delimiters('===', '+++');
  
  sub Dump     () { YAML(Dump => @_)     }
  sub Load     () { YAML(Load => @_)     }
  sub DumpFile () { YAML(DumpFile => @_) }
  sub LoadFile () { YAML(LoadFile => @_) }
  
  sub YAML () {
      load_yaml_pm();
      my $meth = shift;
      my $code = $YAML->can($meth) or die "$YAML cannot do $meth";
      goto &$code;
  }
  
  sub load_yaml_pm {
      my $file = "$YAML.pm";
      $file =~ s{::}{/}g;
      require $file;
  }
  
  sub run_yaml_tests() {
      run {
          my $block = shift;
          &{_get_function($block)}($block) unless 
            _skip_tests_for_now($block) or
            _skip_yaml_tests($block);
      };
  }
  
  sub run_roundtrip_nyn() {
      my @options = @_;
      run {
          my $block = shift;
          roundtrip_nyn($block, @options);
      };
  }
  
  sub roundtrip_nyn() {
      my $block = shift;
      my $option = shift || '';
      die "'perl' data section required"
          unless exists $block->{perl};
      my @values = eval $block->perl;
      die "roundtrip_nyn eval perl error: $@" if $@;
      my $config = $block->config || '';
      my $result = eval "$config; Dump(\@values)";
      die "roundtrip_nyn YAML::Dump error: $@" if $@;
      if (exists $block->{yaml}) {
          is $result, $block->yaml,
              $block->description . ' (n->y)';
      }
      else {
          pass $block->description . ' (n->y)';
      }
          
      return if exists $block->{no_round_trip} or
          not exists $block->{yaml};
  
      if ($option eq 'dumper') {
          is dumper(Load($block->yaml)), dumper(@values),
              $block->description . ' (y->n)';
      }
      else {
          is_deeply [Load($block->yaml)], [@values],
              $block->description . ' (y->n)';
      }
  }
  
  sub count_roundtrip_nyn() {
      my $block = shift or die "Bad call to count_roundtrip_nyn";
      return 1 if exists $block->{skip_this_for_now};
      my $count = 0;
      $count++ if exists $block->{perl};
      $count++ unless exists $block->{no_round_trip} or
          not exists $block->{yaml};
      die "Invalid test definition" unless $count;
      return $count;
  }
  
  sub run_load_passes() {
      run {
          my $block = shift;
          my $yaml = $block->yaml;
          eval { YAML(Load => $yaml) };
          is("$@", "");
      };
  }
  
  sub load_passes() {
      my $block = shift;
      my $yaml = $block->yaml;
      eval { YAML(Load => $yaml) };
      is "$@", "", $block->description;
  }
  
  sub count_load_passes() {1}
  
  sub dumper() {
      require Data::Dumper;
      $Data::Dumper::Sortkeys = 1;
      $Data::Dumper::Terse = 1;
      $Data::Dumper::Indent = 1;
      return Data::Dumper::Dumper(@_);
  }
  
  sub _count_tests() {
      my $block = shift or die "Bad call to _count_tests";
      no strict 'refs';
      &{'count_' . _get_function_name($block)}($block);
  }
  
  sub _get_function_name() {
      my $block = shift;
      return $block->function || 'roundtrip_nyn';
  }
  
  sub _get_function() {
      my $block = shift;
      no strict 'refs';
      \ &{_get_function_name($block)};
  }
  
  sub _skip_tests_for_now() {
      my $block = shift;
      if (exists $block->{skip_this_for_now}) {
          _skip_test(
              $block->description,
              _count_tests($block),
          );
          return 1;
      }
      return 0;
  }
  
  sub _skip_yaml_tests() {
      my $block = shift;
      if ($block->skip_unless_modules) {
          my @modules = split /[\s\,]+/, $block->skip_unless_modules;
          for my $module (@modules) {
              eval "require $module";
              if ($@) {
                  _skip_test(
                      "This test requires the '$module' module",
                      _count_tests($block),
                  );
                  return 1;
              }
          }
      }
      return 0;
  }
  
  sub _skip_test() {
      my ($message, $count) = @_;
      SKIP: {
          skip($message, $count);
      }
  }
  
  #-------------------------------------------------------------------------------
  package Test::YAML::Filter;
  
  use Test::Base::Filter ();
  
  our @ISA = 'Test::Base::Filter';
  
  sub yaml_dump {
      Test::YAML::Dump(@_);
  }
  
  sub yaml_load {
      Test::YAML::Load(@_);
  }
  
  sub Dump { goto &Test::YAML::Dump }
  sub Load { goto &Test::YAML::Load }
  sub DumpFile { goto &Test::YAML::DumpFile }
  sub LoadFile { goto &Test::YAML::LoadFile }
  
  sub yaml_load_or_fail {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $result;
  }
  
  sub yaml_load_error_or_warning {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub perl_eval_error_or_warning {
      my ($result, $error, $warning) =
        $self->_perl_eval_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub _yaml_load_result_error_warning {
      $self->assert_scalar(@_);
      my $yaml = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval {
          $self->yaml_load($yaml);
      };
      return ($result, $@, $warning);
  }
  
  sub _perl_eval_result_error_warning {
      $self->assert_scalar(@_);
      my $perl = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval $perl;
      return ($result, $@, $warning);
  }
  
  1;
  
  =head1 NAME
  
  Test::YAML - Testing Module for YAML Implementations
  
  =head1 SYNOPSIS
  
      use Test::YAML tests => 1;
  
      pass;
  
  =head1 DESCRIPTION
  
  Test::YAML is a subclass of Test::Base with YAML specific support.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST_YAML

$fatpacked{"Type/Coercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION';
  package Type::Coercion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::VERSION   = '0.034';
  }
  
  use Eval::TypeTiny qw<>;
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny qw<>;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	q(+)       => sub { __PACKAGE__->add(@_) },
  	fallback   => 1,
  ;
  
  BEGIN {
  	require Type::Tiny;
  	overload->import(q(~~) => sub { $_[0]->has_coercion_for_value($_[1]) })
  		if Type::Tiny::SUPPORT_SMARTMATCH();
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	
  	if ("Sub::Quote"->can("quote_sub") && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_coercion('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->coerce(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	$params{name} = '__ANON__' unless exists($params{name});
  	my $C = delete($params{type_coercion_map}) || [];
  	my $F = delete($params{frozen});
  	
  	my $self = bless \%params, $class;
  	$self->add_type_coercions(@$C) if @$C;
  	Scalar::Util::weaken($self->{type_constraint}); # break ref cycle
  	$self->{frozen} = $F if $F;
  	
  	unless ($self->is_anon)
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$self->name =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $self->name =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid coercion name', $self->name;
  	}
  	
  	return $self;
  }
  
  sub name                   { $_[0]{name} }
  sub display_name           { $_[0]{display_name}      ||= $_[0]->_build_display_name }
  sub library                { $_[0]{library} }
  sub type_constraint        { $_[0]{type_constraint} }
  sub type_coercion_map      { $_[0]{type_coercion_map} ||= [] }
  sub moose_coercion         { $_[0]{moose_coercion}    ||= $_[0]->_build_moose_coercion }
  sub compiled_coercion      { $_[0]{compiled_coercion} ||= $_[0]->_build_compiled_coercion }
  sub frozen                 { $_[0]{frozen}            ||= 0 }
  sub coercion_generator     { $_[0]{coercion_generator} }
  sub parameters             { $_[0]{parameters} }
  
  sub has_library            { exists $_[0]{library} }
  sub has_type_constraint    { defined $_[0]{type_constraint} } # sic
  sub has_coercion_generator { exists $_[0]{coercion_generator} }
  sub has_parameters         { exists $_[0]{parameters} }
  
  sub add
  {
  	my $class = shift;
  	my ($x, $y, $swap) = @_;
  	
  	Types::TypeTiny::TypeTiny->check($x) and return $x->plus_fallback_coercions($y);
  	Types::TypeTiny::TypeTiny->check($y) and return $y->plus_coercions($x);
  	
  	_croak "Attempt to add $class to something that is not a $class"
  		unless blessed($x) && blessed($y) && $x->isa($class) && $y->isa($class);
  
  	($y, $x) = ($x, $y) if $swap;
  
  	my %opts;
  	if ($x->has_type_constraint and $y->has_type_constraint and $x->type_constraint == $y->type_constraint)
  	{
  		$opts{type_constraint} = $x->type_constraint;
  	}
  	elsif ($x->has_type_constraint and $y->has_type_constraint)
  	{
  #		require Type::Tiny::Union;
  #		$opts{type_constraint} = "Type::Tiny::Union"->new(
  #			type_constraints => [ $x->type_constraint, $y->type_constraint ],
  #		);
  	}
  	$opts{display_name} ||= "$x+$y";
  	delete $opts{display_name} if $opts{display_name} eq '__ANON__+__ANON__';
  	
  	my $new = $class->new(%opts);
  	$new->add_type_coercions( @{$x->type_coercion_map} );
  	$new->add_type_coercions( @{$y->type_coercion_map} );
  	return $new;
  }
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	
  	if ($self->has_library and not $self->is_anon)
  	{
  		return sprintf("%s::%s", $self->library, $self->name);
  	}
  	
  	return $self->name;
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub _clear_compiled_coercion {
  	delete $_[0]{_overload_coderef};
  	delete $_[0]{compiled_coercion};
  }
  
  sub freeze { $_[0]{frozen} = 1; $_[0] }
  
  sub coerce
  {
  	my $self = shift;
  	return $self->compiled_coercion->(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	my $r = $self->coerce(@_);
  	$self->type_constraint->assert_valid($r)
  		if $self->has_type_constraint;
  	return $r;
  }
  
  sub has_coercion_for_type
  {
  	my $self = shift;
  	my $type = Types::TypeTiny::to_TypeTiny($_[0]);
  	
  	return "0 but true"
  		if $self->has_type_constraint && $type->is_a_type_of($self->type_constraint);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $type->is_a_type_of($c->[$i]);
  	}
  	return;
  }
  
  sub has_coercion_for_value
  {
  	my $self = shift;
  	local $_ = $_[0];
  	
  	return "0 but true"
  		if $self->has_type_constraint && $self->type_constraint->check(@_);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $c->[$i]->check(@_);
  	}
  	return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	my @args = @_;
  	
  	_croak "Attempt to add coercion code to a Type::Coercion which has been frozen" if $self->frozen;
  	
  	while (@args)
  	{
  		my $type     = Types::TypeTiny::to_TypeTiny(shift @args);
  		my $coercion = shift @args;
  		
  		_croak "Types must be blessed Type::Tiny objects"
  			unless Types::TypeTiny::TypeTiny->check($type);
  		_croak "Coercions must be code references or strings"
  			unless Types::TypeTiny::StringLike->check($coercion) || Types::TypeTiny::CodeLike->check($coercion);
  		
  		push @{$self->type_coercion_map}, $type, $coercion;
  	}
  	
  	$self->_clear_compiled_coercion;
  	return $self;
  }
  
  sub _build_compiled_coercion
  {
  	my $self = shift;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return sub { $_[0] } unless @mishmash;
  
  	if ($self->can_be_inlined)
  	{
  		return Eval::TypeTiny::eval_closure(
  			source      => sprintf('sub ($) { %s }', $self->inline_coercion('$_[0]')),
  			description => sprintf("compiled coercion '%s'", $self),
  		);
  	}
  
  	# These arrays will be closed over.
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub,
  			$types[$i]->can_be_inlined ? sprintf('if (%s)', $types[$i]->inline_check('$_[0]')) :
  			sprintf('if ($checks[%d]->(@_))', $i);
  		push @sub,
  			!defined($codes[$i])
  				? sprintf('  { return $_[0] }') :
  			Types::TypeTiny::StringLike->check($codes[$i])
  				? sprintf('  { local $_ = $_[0]; return( %s ) }', $codes[$i]) :
  			sprintf('  { local $_ = $_[0]; return $codes[%d]->(@_) }', $i);
  	}
  	
  	push @sub, 'return $_[0];';
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', join qq[\n], @sub),
  		description => sprintf("compiled coercion '%s'", $self),
  		environment => {
  			'@checks' => [ map $_->compiled_check, @types ],
  			'@codes'  => \@codes,
  		},
  	);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	return
  		if $self->has_type_constraint
  		&& !$self->type_constraint->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type, $converter) = splice(@mishmash, 0, 2);
  		return unless $type->can_be_inlined;
  		return unless Types::TypeTiny::StringLike->check($converter);
  	}
  	return !!1;
  }
  
  sub _source_type_union
  {
  	my $self = shift;
  	
  	my @r;
  	push @r, $self->type_constraint if $self->has_type_constraint;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type) = splice(@mishmash, 0, 2);
  		push @r, $type;
  	}
  	
  	require Type::Tiny::Union;
  	return "Type::Tiny::Union"->new(type_constraints => \@r, tmp => 1);
  }
  
  sub inline_coercion
  {
  	my $self = shift;
  	my $varname = $_[0];
  	
  	_croak "This coercion cannot be inlined" unless $self->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return "($varname)" unless @mishmash;
  	
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub, sprintf('(%s) ?', $types[$i]->inline_check($varname));
  		push @sub,
  			(defined($codes[$i]) && ($varname eq '$_'))
  				? sprintf('scalar(%s) :', $codes[$i]) :
  			defined($codes[$i])
  				? sprintf('do { local $_ = %s; scalar(%s) } :', $varname, $codes[$i]) :
  			sprintf('%s :', $varname);
  	}
  	
  	push @sub, "$varname";
  	
  	"@sub";
  }
  
  sub _build_moose_coercion
  {
  	my $self = shift;
  	
  	my %options = ();
  	$options{type_coercion_map} = [ $self->freeze->_codelike_type_coercion_map('moose_type') ];
  	$options{type_constraint}   = $self->type_constraint if $self->has_type_constraint;
  	
  	require Moose::Meta::TypeCoercion;
  	my $r = "Moose::Meta::TypeCoercion"->new(%options);
  	
  	return $r;
  }
  
  sub _codelike_type_coercion_map
  {
  	my $self = shift;
  	my $modifier = $_[0];
  	
  	my @orig = @{ $self->type_coercion_map };
  	my @new;
  	
  	while (@orig)
  	{
  		my ($type, $converter) = splice(@orig, 0, 2);
  		
  		push @new, $modifier ? $type->$modifier : $type;
  		
  		if (Types::TypeTiny::CodeLike->check($converter))
  		{
  			push @new, $converter;
  		}
  		else
  		{
  			Eval::TypeTiny::eval_closure(
  				source      => sprintf('sub { local $_ = $_[0]; %s }', $converter),
  				description => sprintf("temporary compiled converter from '%s'", $type),
  			);
  		}
  	}
  	
  	return @new;
  }
  
  sub is_parameterizable
  {
  	shift->has_coercion_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  sub parameterize
  {
  	my $self = shift;
  	return $self unless @_;
  	$self->is_parameterizable
  		or _croak "Constraint '%s' does not accept parameters", "$self";
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  	
  	return ref($self)->new(
  		type_constraint    => $self->type_constraint,
  		type_coercion_map  => [ $self->coercion_generator->($self, $self->type_constraint, @_) ],
  		parameters         => \@_,
  		frozen             => 1,
  	);
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and blessed($self) and $_[0] eq 'Moose::Meta::TypeCoercion')
  	{
  		return !!1;
  	}
  	
  	if ($INC{"Moose.pm"} and blessed($self) and $_[0] =~ /^Moose/ and my $r = $self->moose_coercion->isa(@_))
  	{
  		return $r;
  	}
  	
  	$self->SUPER::isa(@_);
  }
  
  sub can
  {
  	my $self = shift;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if ($INC{"Moose.pm"} and blessed($self) and my $method = $self->moose_coercion->can(@_))
  	{
  		return sub { $method->(shift->moose_coercion, @_) };
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if ($INC{"Moose.pm"} and blessed($self) and my $method = $self->moose_coercion->can($m))
  	{
  		return $method->($self->moose_coercion, @_);
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  # Private Moose method, but Moo uses this...
  sub _compiled_type_coercion
  {
  	my $self = shift;
  	if (@_)
  	{
  		my $thing = $_[0];
  		if (blessed($thing) and $thing->isa("Type::Coercion"))
  		{
  			$self->add_type_coercions(@{$thing->type_coercion_map});
  		}
  		elsif (Types::TypeTiny::CodeLike->check($thing))
  		{
  			require Types::Standard;
  			$self->add_type_coercions(Types::Standard::Any(), $thing);
  		}
  	}
  	$self->compiled_coercion;
  }
  
  *compile_type_coercion = \&compiled_coercion;
  sub meta { _croak("Not really a Moose::Meta::TypeCoercion. Sorry!") }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion - a set of coercions to a particular target type constraint
  
  =head1 DESCRIPTION
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< add($c1, $c2) >>
  
  Create a Type::Coercion from two existing Type::Coercion objects.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<name>
  
  A name for the coercion. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous coercion.
  
  =item C<display_name>
  
  A name to display for the coercion when stringified. These don't have
  to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<library>
  
  The package name of the type library this coercion is associated with.
  Optional. Informational only: setting this attribute does not install
  the coercion into the package.
  
  =item C<type_constraint>
  
  Weak reference to the target type constraint (i.e. the type constraint which
  the output of coercion coderefs is expected to conform to).
  
  =item C<type_coercion_map>
  
  Arrayref of source-type/code pairs. Don't set this in the constructor; use
  the C<add_type_coercions> method instead.
  
  =item C<< compiled_coercion >>
  
  Coderef to coerce a value (C<< $_[0] >>).
  
  The general point of this attribute is that you should not set it, and
  rely on the lazily-built default. Type::Coerce will usually generate a
  pretty fast coderef, inlining all type constraint checks, etc.
  
  =item C<moose_coercion>
  
  A L<Moose::Meta::TypeCoercion> object equivalent to this one. Don't set this
  manually; rely on the default built one.
  
  =item C<frozen>
  
  Boolean; default false. A frozen coercion cannot have C<add_type_coercions>
  called upon it.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_type_constraint>, C<has_library>
  
  Predicate methods.
  
  =item C<is_anon>
  
  Returns true iff the coercion does not have a C<name>.
  
  =item C<< qualified_name >>
  
  For non-anonymous coercions that have a library, returns a qualified
  C<< "Library::Type" >> sort of name. Otherwise, returns the same as C<name>.
  
  =item C<< add_type_coercions($type1, $code1, ...) >>
  
  Takes one or more pairs of L<Type::Tiny> constraints and coercion code,
  creating an ordered list of source types and coercion codes.
  
  Coercion codes can be expressed as either a string of Perl code (this
  includes objects which overload stringification), or a coderef (or object
  that overloads coderefification). In either case, the value to be coerced
  is C<< $_ >>.
  
  =item C<< coerce($value) >>
  
  Coerce the value to the target type.
  
  Returns the coerced value, or the original value if no coercion was
  possible.
  
  =item C<< assert_coerce($value) >>
  
  Coerce the value to the target type, and throw an exception if the result
  does not validate against the target type constraint.
  
  Returns the coerced value.
  
  =item C<< has_coercion_for_type($source_type) >>
  
  Returns true iff this coercion has a coercion from the source type.
  
  Returns the special string C<< "0 but true" >> if no coercion should
  actually be necessary for this type. (For example, if a coercion coerces
  to a theoretical "Number" type, there is probably no coercion necessary
  for values that already conform to the "Integer" type.)
  
  =item C<< has_coercion_for_value($value) >>
  
  Returns true iff the value could be coerced by this coercion.
  
  Returns the special string C<< "0 but true" >> if no coercion would be
  actually be necessary for this value (due to it already meeting the target
  type constraint).
  
  =item C<< can_be_inlined >>
  
  Returns true iff the coercion can be inlined.
  
  =item C<< inline_coercion($varname) >>
  
  Much like C<inline_coerce> from L<Type::Tiny>.
  
  =item C<< freeze >>
  
  Set C<frozen> to true. There is no C<unfreeze>. Called automatically by
  L<Type::Tiny> sometimes.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeCoercion.
  
  =back
  
  The following methods are used for parameterized coercions, but are not
  fully documented because they may change in the near future:
  
  =over
  
  =item C<< coercion_generator >>
  
  =item C<< has_coercion_generator >>
  
  =item C<< has_parameters >>
  
  =item C<< is_parameterizable >>
  
  =item C<< is_parameterized >>
  
  =item C<< parameterize(@params) >>
  
  =item C<< parameters >>
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_coercion >>
  
  =item C<< meta >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<coerce>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<has_coercion_for_value>.
  
  =item *
  
  Addition is overloaded to call C<add>.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item B<< Attempt to add coercion code to a Type::Coercion which has been frozen >>
  
  Type::Tiny type constraints are designed as immutable objects. Once you've
  created a constraint, rather than modifying it you generally create child
  constraints to do what you need.
  
  Type::Coercion objects, on the other hand, are mutable. Coercion routines
  can be added at any time during the object's lifetime.
  
  Sometimes Type::Tiny needs to freeze a Type::Coercion object to prevent this.
  In L<Moose> and L<Mouse> code this is likely to happen as soon as you use a
  type constraint in an attribute.
  
  Workarounds:
  
  =over
  
  =item *
  
  Define as many of your coercions as possible within type libraries, not
  within the code that uses the type libraries. The type library will be
  evaluated relatively early, likely before there is any reason to freeze
  a coercion.
  
  =item *
  
  If you do need to add coercions to a type within application code outside
  the type library, instead create a subtype and add coercions to that. The
  C<plus_coercions> method provided by L<Type::Tiny> should make this simple.
  
  =back
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Types::Standard>.
  
  L<Type::Coercion::Union>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_COERCION

$fatpacked{"Type/Coercion/FromMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_FROMMOOSE';
  package Type::Coercion::FromMoose;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::FromMoose::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::FromMoose::VERSION   = '0.034';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	my @from = @{ $self->type_constraint->moose_type->coercion->type_coercion_map };
  
  	my @return;
  	while (@from)
  	{
  		my ($type, $code) = splice(@from, 0, 2);
  		$type = Moose::Util::TypeConstraints::find_type_constraint($type)
  			unless ref $type;
  		push @return, Types::TypeTiny::to_TypeTiny($type), $code;
  	}
  	
  	return \@return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::FromMoose not currently supported" if @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::FromMoose - a set of coercions borrowed from Moose
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  Moose.
  
  This is mostly for internal purposes.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_FROMMOOSE

$fatpacked{"Type/Coercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_UNION';
  package Type::Coercion::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::Union::VERSION   = '0.034';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	Types::TypeTiny::TypeTiny->assert_valid(my $type = $self->type_constraint);
  	$type->isa('Type::Tiny::Union')
  		or _croak "Type::Coercion::Union must be used in conjunction with Type::Tiny::Union";
  	
  	my @c;
  	for my $tc (@$type)
  	{
  		next unless $tc->has_coercion;
  		push @c, @{$tc->coercion->type_coercion_map};
  	}
  	return \@c;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::Union not currently supported" if @_;
  }
  
  # sub _build_moose_coercion ???
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::Union - a set of coercions to a union type constraint
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  the child constraints of the union type constraint.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion::Union>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_UNION

$fatpacked{"Type/Library.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_LIBRARY';
  package Type::Library;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Library::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Library::VERSION   = '0.034';
  }
  
  use Eval::TypeTiny qw< eval_closure >;
  use Scalar::Util qw< blessed >;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny >;
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN { *NICE_PROTOTYPES = ($] >= 5.014) ? sub () { !!1 } : sub () { !!0 } };
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  {
  	my $got_subname;
  	sub _subname ($$)
  	{
  		$got_subname = 1 && goto \&Sub::Name::subname
  			if $got_subname || eval "require Sub::Name";
  		return $_[1];
  	}
  }
  
  sub _exporter_validate_opts
  {
  	my $class = shift;
  	
  	no strict "refs";
  	my $into  = $_[0]{into};
  	push @{"$into\::ISA"}, $class if $_[0]{base};
  	
  	return $class->SUPER::_exporter_validate_opts(@_);
  }
  
  sub _exporter_expand_tag
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	$name eq 'types'     and return map [ "$_"        => $value ], $class->type_names;
  	$name eq 'is'        and return map [ "is_$_"     => $value ], $class->type_names;
  	$name eq 'assert'    and return map [ "assert_$_" => $value ], $class->type_names;
  	$name eq 'to'        and return map [ "to_$_"     => $value ], $class->type_names;
  	$name eq 'coercions' and return map [ "$_"        => $value ], $class->coercion_names;
  	
  	if ($name eq 'all')
  	{
  		no strict "refs";
  		return (
  			map(
  				[ "+$_" => $value ],
  				$class->type_names,
  			),
  			map(
  				[ $_ => $value ],
  				$class->coercion_names,
  				@{"$class\::EXPORT"},
  				@{"$class\::EXPORT_OK"},
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_expand_tag(@_);
  }
  
  sub _mksub
  {
  	my $class = shift;
  	my ($type, $post_method) = @_;
  	$post_method ||= q();
  	
  	my $source = $type->is_parameterizable
  		? sprintf(
  			q{
  				sub (%s) {
  					my $params; $params = shift if ref($_[0]) eq q(ARRAY);
  					my $t = $params ? $type->parameterize(@$params) : $type;
  					@_ && wantarray ? return($t%s, @_) : return $t%s;
  				}
  			},
  			NICE_PROTOTYPES ? q(;$) : q(;@),
  			$post_method,
  			$post_method,
  		)
  		: sprintf(
  			q{ sub () { $type%s if $] } },
  			$post_method,
  		);
  		
  	return _subname(
  		$type->qualified_name,
  		eval_closure(
  			source      => $source,
  			description => sprintf("exportable function '%s'", $type),
  			environment => {'$type' => \$type},
  		),
  	);
  }
  
  sub _exporter_permitted_regexp
  {
  	my $class = shift;
  	
  	my $inherited = $class->SUPER::_exporter_permitted_regexp(@_);
  	my $types = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->type_names;
  	my $coercions = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->coercion_names;
  	
  	qr{^(?:
  		$inherited
  		| (?: (?:is_|to_|assert_)? (?:$types) )
  		| (?:$coercions)
  	)$}xms;
  }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	if ($name =~ /^\+(.+)/ and $class->has_type($1))
  	{
  		my $type   = $1;
  		my $value2 = +{%{$value||{}}};
  		
  		return map $class->_exporter_expand_sub($_, $value2, $globals),
  			$type, "is_$type", "assert_$type", "to_$type";
  	}
  	
  	if (my $type = $class->get_type($name))
  	{
  		my $post_method = q();
  		$post_method = '->mouse_type' if $globals->{mouse};
  		$post_method = '->moose_type' if $globals->{moose};
  		return ($name => $class->_mksub($type, $post_method)) if $post_method;
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  #sub _exporter_install_sub
  #{
  #	my $class = shift;
  #	my ($name, $value, $globals, $sym) = @_;
  #	
  #	warn sprintf(
  #		'Exporter %s exporting %s with prototype %s',
  #		$class,
  #		$name,
  #		prototype($sym),
  #	);
  #	
  #	$class->SUPER::_exporter_install_sub(@_);
  #}
  
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	my $into = $globals->{into}
  		or _croak("Parameter 'into' not supplied");
  	
  	if ($globals->{declare})
  	{
  		my $declared = sub (;$)
  		{
  			my $params; $params = shift if ref($_[0]) eq "ARRAY";
  			my $type = $into->get_type($name);
  			unless ($type)
  			{
  				_croak "Cannot parameterize a non-existant type" if $params;
  				$type = $name;
  			}
  			
  			my $t = $params ? $type->parameterize(@$params) : $type;
  			@_ && wantarray ? return($t, @_) : return $t;
  		};
  		
  		return(
  			$name,
  			_subname(
  				"$class\::$name",
  				NICE_PROTOTYPES ? sub (;$) { goto $declared } : sub (;@) { goto $declared },
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_fail(@_);
  }
  
  sub meta
  {
  	no strict "refs";
  	no warnings "once";
  	return $_[0] if blessed $_[0];
  	${"$_[0]\::META"} ||= bless {}, $_[0];
  }
  
  sub add_type
  {
  	my $meta  = shift->meta;
  	my $class = blessed($meta);
  	
  	my $type =
  		ref($_[0]) =~ /^Type::Tiny\b/  ? $_[0] :
  		blessed($_[0])                 ? to_TypeTiny($_[0]) :
  		ref($_[0]) eq q(HASH)          ? "Type::Tiny"->new(library => $class, %{$_[0]}) :
  		"Type::Tiny"->new(library => $class, @_);
  	my $name = $type->{name};
  	
  	$meta->{types} ||= {};
  	_croak 'Type %s already exists in this library', $name if $meta->has_type($name);
  	_croak 'Type %s conflicts with coercion of same name', $name if $meta->has_coercion($name);
  	_croak 'Cannot add anonymous type to a library' if $type->is_anon;
  	$meta->{types}{$name} = $type;
  	
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	
  	# There is an inlined coercion available, but don't use that because
  	# additional coercions can be added *after* the type has been installed
  	# into the library.
  	#
  	# XXX: maybe we can use it if the coercion is frozen???
  	#
  	*{"$class\::$name"}        = $class->_mksub($type);
  	*{"$class\::is_$name"}     = _subname "is_"    .$type->qualified_name, $type->compiled_check;
  	*{"$class\::to_$name"}     = _subname "to_"    .$type->qualified_name, sub ($) { $type->coerce($_[0]) };
  	*{"$class\::assert_$name"} = _subname "assert_".$type->qualified_name, $type->_overload_coderef;
  	
  	return $type;
  }
  
  sub get_type
  {
  	my $meta = shift->meta;
  	$meta->{types}{$_[0]};
  }
  
  sub has_type
  {
  	my $meta = shift->meta;
  	exists $meta->{types}{$_[0]};
  }
  
  sub type_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{types} };
  }
  
  sub add_coercion
  {
  	require Type::Coercion;
  	my $meta = shift->meta;
  	my $c    = blessed($_[0]) ? $_[0] : "Type::Coercion"->new(@_);
  	my $name = $c->name;
  
  	$meta->{coercions} ||= {};
  	_croak 'Coercion %s already exists in this library', $name if $meta->has_coercion($name);
  	_croak 'Coercion %s conflicts with type of same name', $name if $meta->has_type($name);
  	_croak 'Cannot add anonymous type to a library' if $c->is_anon;
  	$meta->{coercions}{$name} = $c;
  
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	my $class = blessed($meta);
  	*{"$class\::$name"} = $class->_mksub($c);
  	
  	return $c;
  }
  
  sub get_coercion
  {
  	my $meta = shift->meta;
  	$meta->{coercions}{$_[0]};
  }
  
  sub has_coercion
  {
  	my $meta = shift->meta;
  	exists $meta->{coercions}{$_[0]};
  }
  
  sub coercion_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{coercions} };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX::Types-like
  
  =head1 NAME
  
  Type::Library - tiny, yet Moo(se)-compatible type libraries
  
  =head1 SYNOPSIS
  
     package Types::Mine {
        use Scalar::Util qw(looks_like_number);
        use Type::Library -base;
        use Type::Tiny;
        
        my $NUM = "Type::Tiny"->new(
           name       => "Number",
           constraint => sub { looks_like_number($_) },
           message    => sub { "$_ ain't a number" },
        );
        
        __PACKAGE__->meta->add_type($NUM);
     }
        
     package Ermintrude {
        use Moo;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Bullwinkle {
        use Moose;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Maisy {
        use Mouse;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
  
  =head1 DESCRIPTION
  
  L<Type::Library> is a tiny class for creating MooseX::Types-like type
  libraries which are compatible with Moo, Moose and Mouse.
  
  If you're reading this because you want to create a type library, then
  you're probably better off reading L<Type::Tiny::Manual::Libraries>.
  
  =head2 Methods
  
  A type library is a singleton class. Use the C<meta> method to get a blessed
  object which other methods can get called on. For example:
  
     Types::Mine->meta->add_type($foo);
  
  =begin trustme
  
  =item meta
  
  =end trustme
  
  =over
  
  =item C<< add_type($type) >> or C<< add_type(%opts) >>
  
  Add a type to the library. If C<< %opts >> is given, then this method calls
  C<< Type::Tiny->new(%opts) >> first, and adds the resultant type.
  
  Adding a type named "Foo" to the library will automatically define four
  functions in the library's namespace:
  
  =over
  
  =item C<< Foo >>
  
  Returns the Type::Tiny object.
  
  =item C<< is_Foo($value) >>
  
  Returns true iff $value passes the type constraint.
  
  =item C<< assert_Foo($value) >>
  
  Returns $value iff $value passes the type constraint. Dies otherwise.
  
  =item C<< to_Foo($value) >>
  
  Coerces the value to the type.
  
  =back
  
  =item C<< get_type($name) >>
  
  Gets the C<Type::Tiny> object corresponding to the name.
  
  =item C<< has_type($name) >>
  
  Boolean; returns true if the type exists in the library.
  
  =item C<< type_names >>
  
  List all types defined by the library.
  
  =item C<< add_coercion($c) >> or C<< add_coercion(%opts) >>
  
  Add a standalone coercion to the library. If C<< %opts >> is given, then
  this method calls C<< Type::Coercion->new(%opts) >> first, and adds the
  resultant coercion.
  
  Adding a coercion named "FooFromBar" to the library will automatically
  define a function in the library's namespace:
  
  =over
  
  =item C<< FooFromBar >>
  
  Returns the Type::Coercion object.
  
  =back
  
  =item C<< get_coercion($name) >>
  
  Gets the C<Type::Coercion> object corresponding to the name.
  
  =item C<< has_coercion($name) >>
  
  Boolean; returns true if the coercion exists in the library.
  
  =item C<< coercion_names >>
  
  List all standalone coercions defined by the library.
  
  =item C<< import(@args) >>
  
  Type::Library-based libraries are exporters.
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< NICE_PROTOTYPES >>
  
  If this is true, then Type::Library will give parameterizable type constraints
  slightly the nicer prototype of C<< (;$) >> instead of the default C<< (;@) >>.
  This allows constructs like:
  
     ArrayRef[Int] | HashRef[Int]
  
  ... to "just work". Sadly, this constant is false on Perl < 5.14, and
  expressions like the above need lots of parentheses to do what you mean.
  
  =back
  
  =head2 Export
  
  Type libraries are exporters. For the purposes of the following examples,
  assume that the C<Types::Mine> library defines types C<Number> and C<String>.
  
     # Exports nothing.
     # 
     use Types::Mine;
     
     # Exports a function "String" which is a constant returning
     # the String type constraint.
     #
     use Types::Mine qw( String );
     
     # Exports both String and Number as above.
     #
     use Types::Mine qw( String Number );
     
     # Same.
     #
     use Types::Mine qw( :types );
     
     # Exports a sub "is_String" so that "is_String($foo)" is equivalent
     # to "String->check($foo)".
     #
     use Types::Mine qw( is_String );
     
     # Exports "is_String" and "is_Number".
     #
     use Types::Mine qw( :is );
     
     # Exports a sub "assert_String" so that "assert_String($foo)" is
     # equivalent to "String->assert_return($foo)".
     #
     use Types::Mine qw( assert_String );
     
     # Exports "assert_String" and "assert_Number".
     #
     use Types::Mine qw( :assert );
     
     # Exports a sub "to_String" so that "to_String($foo)" is equivalent
     # to "String->coerce($foo)".
     #
     use Types::Mine qw( to_String );
     
     # Exports "to_String" and "to_Number".
     #
     use Types::Mine qw( :to );
     
     # Exports "String", "is_String", "assert_String" and "coerce_String".
     #
     use Types::Mine qw( +String );
     
     # Exports everything.
     #
     use Types::Mine qw( :all );
  
  Type libraries automatically inherit from L<Exporter::Tiny>; see the
  documentation of that module for tips and tricks importing from libraries.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_LIBRARY

$fatpacked{"Type/Params.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARAMS';
  package Type::Params;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Params::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Params::VERSION   = '0.034';
  }
  
  use B qw(perlstring);
  use Eval::TypeTiny;
  use Scalar::Util qw(refaddr);
  use Error::TypeTiny;
  use Error::TypeTiny::Assertion;
  use Error::TypeTiny::WrongNumberOfParameters;
  use Type::Tiny::Union;
  use Types::Standard -types;
  use Types::TypeTiny qw(CodeLike ArrayLike to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  our @EXPORT = qw( compile );
  our @EXPORT_OK = qw( multisig validate Invocant );
  
  BEGIN {
  	my $Invocant = 'Type::Tiny::Union'->new(
  		name             => 'Invocant',
  		type_constraints => [Object, ClassName],
  	);
  	sub Invocant () { $Invocant };
  };
  
  sub _mkslurpy
  {
  	my ($name, $type, $tc, $i) = @_;
  	$name = 'local $_' if $name eq '$_';
  	
  	$type eq '@'
  		? sprintf(
  			'%s = [ @_[%d..$#_] ];',
  			$name,
  			$i,
  		)
  		: sprintf(
  			'%s = (($#_-%d)%%2)==0 ? "Error::TypeTiny::WrongNumberOfParameters"->throw(message => sprintf("Odd number of elements in %%s", %s)) : +{ @_[%d..$#_] };',
  			$name,
  			$i,
  			perlstring("$tc"),
  			$i,
  			$i,
  		);
  }
  
  sub compile
  {
  	my (@code, %env);
  	@code = 'my (@R, %tmp, $tmp);';
  	push @code, '#placeholder';   # $code[1]
  	
  	my %options    = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my $arg        = -1;
  	my $saw_slurpy = 0;
  	my $min_args   = 0;
  	my $max_args   = 0;
  	my $saw_opt    = 0;
  	
  	while (@_)
  	{
  		++$arg;
  		my $constraint = shift;
  		my $is_optional;
  		my $is_slurpy;
  		my $varname;
  		
  		if (Bool->check($constraint))
  		{
  			$constraint = $constraint ? Any : Optional[Any];
  		}
  		
  		if (HashRef->check($constraint))
  		{
  			$constraint = to_TypeTiny($constraint->{slurpy});
  			push @code,
  				$constraint->is_a_type_of(Dict)     ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Map)      ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Tuple)    ? _mkslurpy('$_', '@', $constraint => $arg) :
  				$constraint->is_a_type_of(HashRef)  ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(ArrayRef) ? _mkslurpy('$_', '@', $constraint => $arg) :
  				Error::TypeTiny::croak("Slurpy parameter not of type HashRef or ArrayRef");
  			$varname = '$_';
  			$is_slurpy++;
  			$saw_slurpy++;
  		}
  		else
  		{
  			Error::TypeTiny::croak("Parameter following slurpy parameter") if $saw_slurpy;
  			
  			$is_optional = grep $_->{uniq} == Optional->{uniq}, $constraint->parents;
  			
  			if ($is_optional)
  			{
  				push @code, sprintf 'return @R if $#_ < %d;', $arg;
  				$saw_opt++;
  				$max_args++;
  			}
  			else
  			{
  				Error::TypeTiny::croak("Non-Optional parameter following Optional parameter") if $saw_opt;
  				$min_args++;
  				$max_args++;
  			}
  			
  			$varname = sprintf '$_[%d]', $arg;
  		}
  		
  		if ($constraint->has_coercion and $constraint->coercion->can_be_inlined)
  		{
  			push @code, sprintf(
  				'$tmp%s = %s;',
  				($is_optional ? '{x}' : ''),
  				$constraint->coercion->inline_coercion($varname)
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		elsif ($constraint->has_coercion)
  		{
  			$env{'@coerce'}[$arg] = $constraint->coercion->compiled_coercion;
  			push @code, sprintf(
  				'$tmp%s = $coerce[%d]->(%s);',
  				($is_optional ? '{x}' : ''),
  				$arg,
  				$varname,
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		
  		if ($constraint->can_be_inlined)
  		{
  			push @code, sprintf(
  				'(%s) or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				$constraint->inline_check($varname),
  				$constraint->{uniq},
  				perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		else
  		{
  			$env{'@check'}[$arg] = $constraint->compiled_check;
  			push @code, sprintf(
  				'%s or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				sprintf(sprintf '$check[%d]->(%s)', $arg, $varname),
  				$constraint->{uniq},
  				perlstring($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		
  		push @code, sprintf 'push @R, %s;', $varname;
  	}
  	
  	if ($min_args == $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ != %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  		);
  	}
  	elsif ($min_args < $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ < %d || @_ > %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  			$max_args,
  		);
  	}
  	elsif ($min_args and $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d) if @_ < %d;',
  			$min_args,
  			$min_args,
  		);
  	}
  	
  	push @code, '@R;';
  	
  	my $source  = "sub { no warnings; ".join("\n", @code)." };";
  	
  	return $source if $options{want_source};
  	
  	my $closure = eval_closure(
  		source      => $source,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => \%env,
  	);
  	
  	return {
  		min_args   => $min_args,
  		max_args   => $saw_slurpy ? undef : $max_args,
  		closure    => $closure,
  	} if $options{want_details};
  	
  	return $closure;
  }
  
  my %compiled;
  sub validate
  {
  	my $arr = shift;
  	my $sub = $compiled{ join ":", map($_->{uniq}||"\@$_->{slurpy}", @_) } ||= compile({ caller_level => 1 }, @_);
  	@_ = @$arr;
  	goto $sub;
  }
  
  sub multisig
  {
  	my %options = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my @multi = map {
  		CodeLike->check($_)  ? { closure => $_ } :
  		ArrayLike->check($_) ? compile({ want_details => 1 }, @$_) :
  		$_;
  	} @_;
  	
  	my @code = 'sub { my $r; ';
  	
  	for my $i (0 .. $#multi)
  	{
  		my $sig = $multi[$i];
  		my @cond;
  		push @cond, sprintf('@_ >= %s', $sig->{min_args}) if defined $sig->{min_args};
  		push @cond, sprintf('@_ <= %s', $sig->{max_args}) if defined $sig->{max_args};
  		push @code, sprintf('if (%s){', join(' and ', @cond)) if @cond;
  		push @code, sprintf('eval { $r = [ $multi[%d]{closure}->(@_) ] };', $i);
  		push @code, 'return(@$r) if $r;';
  		push @code, '}' if @cond;
  	}
  	
  	push @code, '"Error::TypeTiny"->throw(message => "Parameter validation failed");';
  	push @code, '}';
  	
  	eval_closure(
  		source      => \@code,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => { '@multi' => \@multi },
  	);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords evals
  
  =head1 NAME
  
  Type::Params - Params::Validate-like parameter validation using Type::Tiny type constraints and coercions
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Params qw( compile );
   use Types::Standard qw( slurpy Str ArrayRef Num );
     
   sub deposit_monies
   {
      state $check = compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);
      
      my $account = Local::BankAccount->new($sort_code, $account_number);
      $account->deposit($_) for @$monies;
   }
   
   deposit_monies("12-34-56", "11223344", 1.2, 3, 99.99);
  
  =head1 DESCRIPTION
  
  Type::Params uses L<Type::Tiny> constraints to validate the parameters to a
  sub. It takes the slightly unorthodox approach of separating validation
  into two stages:
  
  =over
  
  =item 1.
  
  Compiling the parameter specification into a coderef; then
  
  =item 2.
  
  Using the coderef to validate parameters.
  
  =back
  
  The first stage is slow (it might take a couple of milliseconds), but you
  only need to do it the first time the sub is called. The second stage is
  fast; according to my benchmarks faster even than the XS version of
  L<Params::Validate>.
  
  If you're using a modern version of Perl, you can use the C<state> keyword
  which was a feature added to Perl in 5.10. If you're stuck on Perl 5.8, the
  example from the SYNOPSIS could be rewritten as:
  
   my $deposit_monies_check;
   sub deposit_monies
   {
      $deposit_monies_check ||= compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);
      
      ...;
   }
  
  Not quite as neat, but not awful either.
  
  There's a shortcut reducing it to one step:
  
   use Type::Params qw( validate );
   
   sub deposit_monies
   {
      my ($sort_code, $account_number, $monies) = 
         validate( \@_, Str, Str, slurpy ArrayRef[Num] );
      
      ...;
   }
  
  Type::Params has a few tricks up its sleeve to make sure performance doesn't
  suffer too much with the shortcut, but it's never going to be as fast as the
  two stage compile/execute.
  
  =begin trustme
  
  Dude, these functions are documented!
  
  =item compile
  
  =item validate
  
  =item Invocant
  
  =item multisig
  
  =end trustme
  
  =head1 COOKBOOK
  
  =head2 Positional Parameters
  
     sub nth_root
     {
        state $check = compile( Num, Num );
        my ($x, $n) = $check->(@_);
        
        return $x ** (1 / $n);
     }
  
  =head2 Method Calls
  
  Type::Params exports an additional keyword C<Invocant> on request. This is
  a type constraint accepting blessed objects and also class names.
  
     use Types::Standard qw( ClassName Object Str Int );
     use Type::Params qw( compile Invocant );
     
     # a class method
     sub new_from_json
     {
        state $check = compile( ClassName, Str );
        my ($class, $json) = $check->(@_);
        
        $class->new( from_json($json) );
     }
     
     # an object method
     sub dump
     {
        state $check = compile( Object, Int );
        my ($self, $limit) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     # can be called as either and object or class method
     sub run
     {
        state $check = compile( Invocant );
        my ($proto) = $check->(@_);
        
        my $self = ref($proto) ? $proto : $default_instance;
        $self->_run;
     }
  
  =head2 Optional Parameters
  
     use Types::Standard qw( Object Optional Int );
     
     sub dump
     {
        state $check = compile( Object, Optional[Int] );
        my ($self, $limit) = $check->(@_);
        $limit //= 0;
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     $obj->dump(1);      # ok
     $obj->dump();       # ok
     $obj->dump(undef);  # dies
  
  =head2 Slurpy Parameters
  
     use Types::Standard qw( slurpy ClassName HashRef );
     
     sub new
     {
        state $check = compile( ClassName, slurpy HashRef );
        my ($class, $ref) = $check->(@_);
        bless $ref => $class;
     }
     
     __PACKAGE__->new(foo => 1, bar => 2);
  
  The following types from L<Types::Standard> can be made slurpy:
  C<ArrayRef>, C<Tuple>, C<HashRef>, C<Map>, C<Dict>. Hash-like types
  will die if an odd number of elements are slurped in.
  
  A check may only have one slurpy parameter, and it must be the last
  parameter.
  
  =head2 Named Parameters
  
  Just use a slurpy C<Dict>:
  
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub dump
     {
        state $check = compile(
           slurpy Dict[
              var    => Ref,
              limit  => Optional[Int],
           ],
        );
        my ($arg) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $arg->{limit};
        print Data::Dumper::Dumper($arg->{var});
     }
     
     dump(var => $foo, limit => 1);   # ok
     dump(var => $foo);               # ok
     dump(limit => 1);                # dies
  
  =head2 Mixed Positional and Named Parameters
  
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub my_print
     {
        state $check = compile(
           Str,
           slurpy Dict[
              colour => Optional[Str],
              size   => Optional[Int],
           ],
        );
        my ($string, $arg) = $check->(@_);
     }
     
     my_print("Hello World", colour => "blue");
  
  =head2 Coercions
  
  Coercions will automatically be applied for I<all> type constraints that have
  a coercion associated.
  
     use Type::Utils;
     use Types::Standard qw( Int Num );
     
     my $RoundedInt = declare as Int;
     coerce $RoundedInt, from Num, q{ int($_) };
     
     sub set_age
     {
        state $check = compile( Object, $RoundedInt );
        my ($self, $age) = $check->(@_);
        
        $self->{age} = $age;
     }
     
     $obj->set_age(32.5);   # ok; coerced to "32".
  
  Coercions carry over into structured types such as C<ArrayRef> automatically:
  
     sub delete_articles
     {
        state $check = compile( Object, slurpy ArrayRef[$RoundedInt] );
        my ($db, $articles) = $check->(@_);
        
        $db->select_article($_)->delete for @$articles;
     }
     
     # delete articles 1, 2 and 3
     delete_articles($my_db, 1.1, 2.2, 3.3);
  
  If type C<Foo> has coercions from C<Str> and C<ArrayRef> and you want to
  B<prevent> coercion, then use:
  
     state $check = compile( Foo->no_coercions );
  
  Or if you just want to prevent coercion from C<Str>, use:
  
     state $check = compile( Foo->minus_coercions(Str) );
  
  Or maybe add an extra coercion:
  
     state $check = compile(
        Foo->plus_coercions(Int, q{ Foo->new_from_number($_) }),
     );
  
  Note that the coercion is specified as a string of Perl code. This is usually
  the fastest way to do it, but a coderef is also accepted. Either way, the
  value to be coerced is C<< $_ >>.
  
  =head2 Alternatives
  
  Type::Params can export a C<multisig> function that compiles multiple
  alternative signatures into one, and uses the first one that works:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        [ HashRef, Num ],
        [ CodeRef ],
     );
     
     my ($int, $arrayref) = $check->( 1, [] );
     my ($hashref, $num)  = $check->( {}, 1.1 );
     my ($code)           = $check->( sub { 1 } );
     
     $check->( sub { 1 }, 1.1 );  # throws an exception
  
  Coercions, slurpy parameters, etc still work.
  
  There's currently no indication of which of the multiple signatures
  succeeded.
  
  The present implementation involves compiling each signature independently,
  and trying them each (in their given order!) in an C<eval> block. The only
  slightly intelligent part is that it checks if C<< scalar(@_) >> fits into
  the signature properly (taking into account optional and slurpy parameters),
  and skips evals which couldn't possibly succeed.
  
  It's also possible to list coderefs as alternatives in C<multisig>:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        sub { ... },
        [ HashRef, Num ],
        [ CodeRef ],
     );
  
  The coderef is expected to die if that alternative should be abandoned (and
  the next alternative tried), or return the list of accepted parameters. Here's
  a full example:
  
     sub get_from {
        state $check = multisig(
           [ Int, ArrayRef ],
           [ Str, HashRef ],
           sub {
              my ($meth, $obj);
              die unless is_Object($obj);
              die unless $obj->can($meth);
              return ($meth, $obj);
           },
        );
        my ($needle, $haystack) = $check->(@_);
        
        is_HashRef($haystack)  ? $haystack->{$needle} :
        is_ArrayRef($haystack) ? $haystack->[$needle] :
        is_Object($haystack)   ? $haystack->$needle   :
        die;
     }
     
     get_from(0, \@array);      # returns $array[0]
     get_from('foo', \%hash);   # returns $hash{foo}
     get_from('foo', $obj);     # returns $obj->foo
  
  =head1 COMPARISON WITH PARAMS::VALIDATE
  
  L<Type::Params> is not really a drop-in replacement for L<Params::Validate>;
  the API differs far too much to claim that. Yet it performs a similar task,
  so it makes sense to compare them.
  
  =over
  
  =item *
  
  Type::Params will tend to be faster if you've got a sub which is called
  repeatedly, but may be a little slower than Params::Validate for subs that
  are only called a few times. This is because it does a bunch of work the
  first time your sub is called to make subsequent calls a lot faster.
  
  =item *
  
  Type::Params is mostly geared towards positional parameters, while
  Params::Validate seems to be primarily aimed at named parameters. (Though
  either works for either.) Params::Validate doesn't appear to have a
  particularly natural way of validating a mix of positional and named
  parameters.
  
  =item *
  
  Type::Utils allows you to coerce parameters. For example, if you expect
  a L<Path::Tiny> object, you could coerce it from a string.
  
  =item *
  
  Params::Validate allows you to supply defaults for missing parameters;
  Type::Params does not, but you may be able to use coercion from Undef.
  
  =item *
  
  If you are primarily writing object-oriented code, using Moose or similar,
  and you are using Type::Tiny type constraints for your attributes, then
  using Type::Params allows you to use the same constraints for method calls.
  
  =item *
  
  Type::Params comes bundled with Types::Standard, which provides a much
  richer vocabulary of types than the type validation constants that come
  with Params::Validate. For example, Types::Standard provides constraints
  like C<< ArrayRef[Int] >> (an arrayref of integers), while the closest from
  Params::Validate is C<< ARRAYREF >>, which you'd need to supplement with
  additional callbacks if you wanted to check that the arrayref contained
  integers.
  
  Whatsmore, Type::Params doesn't just work with Types::Standard, but also
  any other Type::Tiny type constraints.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>, L<Type::Coercion>, L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARAMS

$fatpacked{"Type/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARSER';
  package Type::Parser;
  
  use strict;
  use warnings;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  
  # Token types
  # 
  sub TYPE      () { "TYPE" };
  sub QUOTELIKE () { "QUOTELIKE" };
  sub STRING    () { "STRING" };
  sub CLASS     () { "CLASS" };
  sub L_BRACKET () { "L_BRACKET" };
  sub R_BRACKET () { "R_BRACKET" };
  sub COMMA     () { "COMMA" };
  sub SLURPY    () { "SLURPY" };
  sub UNION     () { "UNION" };
  sub INTERSECT () { "INTERSECT" };
  sub NOT       () { "NOT" };
  sub L_PAREN   () { "L_PAREN" };
  sub R_PAREN   () { "R_PAREN" };
  sub MYSTERY   () { "MYSTERY" };
  
  our @EXPORT_OK = qw( eval_type _std_eval parse );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  Evaluate: {
  	
  	sub parse
  	{
  		my $str = $_[0];
  		my $parser = "Type::Parser::AstBuilder"->new(input => $str);
  		$parser->build;
  		wantarray ? ($parser->ast, $parser->remainder) : $parser->ast;
  	}
  	
  	sub extract_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		wantarray ? (_eval_type($parsed, $reg), $tail) : _eval_type($parsed, $reg);
  	}
  	
  	sub eval_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		_croak("Unexpected tail on type expression: $tail") if $tail =~ /\S/sm;
  		return _eval_type($parsed, $reg);
  	}
  	
  	my $std;
  	sub _std_eval
  	{
  		require Type::Registry;
  		unless ($std)
  		{
  			$std = "Type::Registry"->new;
  			$std->add_types(-Standard);
  		}
  		eval_type($_[0], $std);
  	}
  	
  	sub _eval_type
  	{
  		my ($node, $reg) = @_;
  		
  		$node = _simplify_expression($node);
  		
  		if ($node->{type} eq "list")
  		{
  			return map _eval_type($_, $reg), @{$node->{list}};
  		}
  		
  		if ($node->{type} eq "union")
  		{
  			require Type::Tiny::Union;
  			return "Type::Tiny::Union"->new(
  				type_constraints => [ map _eval_type($_, $reg), @{$node->{union}} ],
  			);
  		}
  		
  		if ($node->{type} eq "intersect")
  		{
  			require Type::Tiny::Intersection;
  			return "Type::Tiny::Intersection"->new(
  				type_constraints => [ map _eval_type($_, $reg), @{$node->{intersect}} ],
  			);
  		}
  		
  		if ($node->{type} eq "slurpy")
  		{
  			return +{ slurpy => _eval_type($node->{of}, $reg) };
  		}
  		
  		if ($node->{type} eq "complement")
  		{
  			return _eval_type($node->{of}, $reg)->complementary_type;
  		}
  		
  		if ($node->{type} eq "parameterized")
  		{
  			my $base = _eval_type($node->{base}, $reg);
  			
  			return $base unless $base->is_parameterizable || $node->{params};
  			return $base->parameterize($node->{params} ? _eval_type($node->{params}, $reg) : ());
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq CLASS)
  		{
  			my $class = substr($node->{token}->spelling, 0, length($node->{token}->spelling) - 2);
  			require Type::Tiny::Class;
  			return "Type::Tiny::Class"->new(class => $class);
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq QUOTELIKE)
  		{
  			return eval($node->{token}->spelling); #ARGH
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq STRING)
  		{
  			return $node->{token}->spelling;
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq TYPE)
  		{
  			my $t = $node->{token}->spelling;
  			my $r;
  			if ($t =~ /^(.+)::(\w+)$/)
  			{
  				require Types::TypeTiny;
  				my $library = $1; $t = $2;
  				eval "require $library;";
  				$r =
  					$library->isa('MooseX::Types::Base')  ? Types::TypeTiny::to_TypeTiny( $library->has_type($t) ? $library->can($t)->() : () ) :
  					$library->can("get_type")             ? $library->get_type($t) :
  					$reg->simple_lookup("$library\::$t", 1);
  				}
  			else
  			{
  				$r = $reg->simple_lookup($t, 1);
  			}
  			$r or _croak("%s is not a known type constraint", $node->{token}->spelling);
  			return $r;
  		}
  	}
  	
  	sub _simplify_expression
  	{
  		my $expr = shift;
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq COMMA)
  		{
  			return _simplify("list", COMMA, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq UNION)
  		{
  			return _simplify("union", UNION, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq INTERSECT)
  		{
  			return _simplify("intersect", INTERSECT, $expr);
  		}
  		
  		return $expr;
  	}
  	
  	sub _simplify
  	{
  		my $type = shift;
  		my $op   = shift;
  		
  		my @list;
  		for my $expr ($_[0]{lhs}, $_[0]{rhs})
  		{
  			if ($expr->{type} eq "expression" and $expr->{op}[0] eq $op)
  			{
  				my $simple = _simplify($type, $op, $expr);
  				push @list, @{ $simple->{$type} };
  			}
  			else
  			{
  				push @list, $expr;
  			}
  		}
  		
  		return { type => $type, $type => \@list };
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::AstBuilder;
  	
  	sub new
  	{
  		my $class = shift;
  		bless { @_ }, $class;
  	}
  	
  	our %precedence = (
  #		Type::Parser::COMMA()     , 1 ,
  		Type::Parser::UNION()     , 2 ,
  		Type::Parser::INTERSECT() , 3 ,
  		Type::Parser::NOT()       , 4 ,
  	);
  	
  	sub _parse_primary
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		$tokens->assert_not_empty;
  		
  		if ($tokens->peek(0)->type eq Type::Parser::NOT)
  		{
  			$tokens->eat(Type::Parser::NOT);
  			$tokens->assert_not_empty;
  			return {
  				type  => "complement",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::SLURPY)
  		{
  			$tokens->eat(Type::Parser::SLURPY);
  			$tokens->assert_not_empty;
  			return {
  				type  => "slurpy",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::L_PAREN)
  		{
  			$tokens->eat(Type::Parser::L_PAREN);
  			my $r = $self->_parse_expression;
  			$tokens->eat(Type::Parser::R_PAREN);
  			return $r;
  		}
  		
  		if ($tokens->peek(1)
  		and $tokens->peek(0)->type eq Type::Parser::TYPE
  		and $tokens->peek(1)->type eq Type::Parser::L_BRACKET)
  		{
  			my $base = { type  => "primary", token => $tokens->eat(Type::Parser::TYPE) };
  			$tokens->eat(Type::Parser::L_BRACKET);
  			$tokens->assert_not_empty;
  			
  			local $precedence{ Type::Parser::COMMA() } = 1;
  			
  			my $params = undef;
  			if ($tokens->peek(0)->type eq Type::Parser::R_BRACKET)
  			{
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			else
  			{
  				$params = $self->_parse_expression;
  				$params = { type => "list", list => [$params] } unless $params->{type} eq "list";
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			return {
  				type   => "parameterized",
  				base   => $base,
  				params => $params,
  			};
  		}
  		
  		my $type = $tokens->peek(0)->type;
  		if ($type eq Type::Parser::TYPE
  		or  $type eq Type::Parser::QUOTELIKE
  		or  $type eq Type::Parser::STRING
  		or  $type eq Type::Parser::CLASS)
  		{
  			return { type  => "primary", token => $tokens->eat };
  		}
  		
  		Type::Parser::_croak("Unexpected token in primary type expression; got '%s'", $tokens->peek(0)->spelling);
  	}
  	
  	sub _parse_expression_1
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		my ($lhs, $min_p) = @_;
  		while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} >= $min_p)
  		{
  			my $op  = $tokens->eat;
  			my $rhs = $self->_parse_primary;
  			
  			while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} > $precedence{$op->type})
  			{
  				my $lookahead = $tokens->peek(0);
  				$rhs = $self->_parse_expression_1($rhs, $precedence{$lookahead->type});
  			}
  			
  			$lhs = {
  				type => "expression",
  				op   => $op,
  				lhs  => $lhs,
  				rhs  => $rhs,
  			};
  		}
  		return $lhs;
  	}
  	
  	sub _parse_expression
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		return $self->_parse_expression_1($self->_parse_primary, 0);
  	}
  	
  	sub build
  	{
  		my $self = shift;
  		$self->{tokens} = "Type::Parser::TokenStream"->new(remaining => $self->{input});
  		$self->{ast}    = $self->_parse_expression;
  	}
  	
  	sub ast
  	{
  		$_[0]{ast};
  	}
  	
  	sub remainder
  	{
  		$_[0]{tokens}->remainder;
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::Token;
  	sub type     { $_[0][0] }
  	sub spelling { $_[0][1] }
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::TokenStream;
  	
  	use Scalar::Util qw(looks_like_number);
  	use Text::Balanced qw(extract_quotelike);
  	
  	sub new
  	{
  		my $class = shift;
  		bless { stack => [], done => [], @_ }, $class;
  	}
  	
  	sub peek
  	{
  		my $self  = shift;
  		my $ahead = $_[0];
  		
  		while ($self->_stack_size <= $ahead and length $self->{remaining})
  		{
  			$self->_stack_extend;
  		}
  		
  		my @tokens = grep ref, @{ $self->{stack} };
  		return $tokens[$ahead];
  	}
  	
  	sub empty
  	{
  		my $self = shift;
  		not $self->peek(0);
  	}
  	
  	sub eat
  	{
  		my $self = shift;
  		$self->_stack_extend unless $self->_stack_size;
  		my $r;
  		while (defined(my $item = shift @{$self->{stack}}))
  		{
  			push @{ $self->{done} }, $item;
  			if (ref $item)
  			{
  				$r = $item;
  				last;
  			}
  		}
  		
  		if (@_ and $_[0] ne $r->type)
  		{
  			unshift @{$self->{stack}}, pop @{$self->{done}};
  			Type::Parser::_croak("Expected $_[0]; got ".$r->type);
  		}
  		
  		return $r;
  	}
  	
  	sub assert_not_empty
  	{
  		my $self = shift;
  		Type::Parser::_croak("Expected token; got empty string") if $self->empty;
  	}
  	
  	sub _stack_size
  	{
  		my $self = shift;
  		scalar grep ref, @{ $self->{stack} };
  	}
  	
  	sub _stack_extend
  	{
  		my $self = shift;
  		push @{ $self->{stack} }, $self->_read_token;
  		my ($space) = ($self->{remaining} =~ m/^([\s\n\r]*)/sm);
  		return unless length $space;
  		push @{ $self->{stack} }, $space;
  		substr($self->{remaining}, 0, length $space) = "";
  	}
  	
  	sub remainder
  	{
  		my $self = shift;
  		return join "",
  			map { ref($_) ? $_->spelling : $_ }
  			(@{$self->{stack}}, $self->{remaining})
  	}
  	
  	my %punctuation = (
  		'['       => bless([ Type::Parser::L_BRACKET, "[" ], "Type::Parser::Token"),
  		']'       => bless([ Type::Parser::R_BRACKET, "]" ], "Type::Parser::Token"),
  		'('       => bless([ Type::Parser::L_PAREN,   "[" ], "Type::Parser::Token"),
  		')'       => bless([ Type::Parser::R_PAREN,   "]" ], "Type::Parser::Token"),
  		','       => bless([ Type::Parser::COMMA,     "," ], "Type::Parser::Token"),
  		'=>'      => bless([ Type::Parser::COMMA,     "=>" ], "Type::Parser::Token"),
  		'slurpy'  => bless([ Type::Parser::SLURPY,    "slurpy" ], "Type::Parser::Token"),
  		'|'       => bless([ Type::Parser::UNION,     "|" ], "Type::Parser::Token"),
  		'&'       => bless([ Type::Parser::INTERSECT, "&" ], "Type::Parser::Token"),
  		'~'       => bless([ Type::Parser::NOT,       "~" ], "Type::Parser::Token"),
  	);
  	
  	sub _read_token
  	{
  		my $self = shift;
  		
  		return if $self->{remaining} eq "";
  		
  		# Punctuation
  		# 
  		
  		if ($self->{remaining} =~ /^( => | [()\]\[|&~,] )/xsm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			return $punctuation{$spelling};
  		}
  		
  		if (my $quotelike = extract_quotelike $self->{remaining})
  		{
  			return bless([ Type::Parser::QUOTELIKE, $quotelike ], "Type::Parser::Token"),;
  		}
  		
  		if ($self->{remaining} =~ /^([+-]?[\w:.+]+)/sm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			
  			if ($spelling =~ /::$/sm)
  			{
  				return bless([ Type::Parser::CLASS, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif (looks_like_number($spelling))
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($self->{remaining} =~ /^\s*=>/sm) # peek ahead
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($spelling eq "slurpy")
  			{
  				return $punctuation{$spelling};
  			}
  			
  			return bless([ Type::Parser::TYPE, $spelling ], "Type::Parser::Token");
  		}
  		
  		my $rest = $self->{remaining};
  		$self->{remaining} = "";
  		return bless([ Type::Parser::MYSTERY, $rest ], "Type::Parser::Token");
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords non-whitespace
  
  =head1 NAME
  
  Type::Parser - parse type constraint strings
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Parser qw( eval_type );
   use Type::Registry;
   
   my $reg = Type::Registry->for_me;
   $reg->add_types("Types::Standard");
   
   my $type = eval_type("Int | ArrayRef[Int]", $reg);
   
   $type->check(10);        # true
   $type->check([1..4]);    # true
   $type->check({foo=>1});  # false
  
  =head1 DESCRIPTION
  
  Generally speaking, you probably don't want to be using this module directly.
  Instead use the C<< lookup >> method from L<Type::Registry> which wraps it.
  
  =head2 Functions
  
  =over
  
  =item C<< parse($string) >>
  
  Parse the type constraint string into something like an AST.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< extract_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< eval_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  Throws an error if the "tail" contains any non-whitespace character.
  
  =back
  
  =head2 Constants
  
  The following constants correspond to values returned by C<< $token->type >>.
  
  =over
  
  =item C<< TYPE >>
  
  =item C<< QUOTELIKE >>
  
  =item C<< STRING >>
  
  =item C<< CLASS >>
  
  =item C<< L_BRACKET >>
  
  =item C<< R_BRACKET >>
  
  =item C<< COMMA >>
  
  =item C<< SLURPY >>
  
  =item C<< UNION >>
  
  =item C<< INTERSECT >>
  
  =item C<< NOT >>
  
  =item C<< L_PAREN >>
  
  =item C<< R_PAREN >>
  
  =item C<< MYSTERY >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Registry>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARSER

$fatpacked{"Type/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_REGISTRY';
  package Type::Registry;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Registry::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Registry::VERSION   = '0.034';
  }
  
  use Exporter::Tiny qw( mkopt );
  use Scalar::Util qw( refaddr );
  use Type::Parser qw( eval_type );
  use Types::TypeTiny qw( CodeLike ArrayLike to_TypeTiny );
  
  our @ISA = 'Exporter::Tiny';
  our @EXPORT_OK = qw(t);
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	
  	if ($name eq "t")
  	{
  		my $caller = $globals->{into};
  		my $reg = $class->for_class(
  			ref($caller) ? sprintf('HASH(0x%08X)', refaddr($caller)) : $caller
  		);
  		return t => sub (;$) { @_ ? $reg->lookup(@_) : $reg };
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  sub new
  {
  	my $class = shift;
  	ref($class) and _croak("Not an object method");
  	bless {}, $class;
  }
  
  {
  	my %registries;
  	
  	sub for_class
  	{
  		my $class = shift;
  		my ($for) = @_;
  		$registries{$for} ||= $class->new;
  	}
  	
  	sub for_me
  	{
  		my $class = shift;
  		my $for   = caller;
  		$registries{$for} ||= $class->new;
  	}
  }
  
  sub add_types
  {
  	my $self = shift;
  	my $opts = mkopt(\@_);
  	for my $opt (@$opts)
  	{
  		my ($lib, $types) = @_;
  		
  		$lib =~ s/^-/Types::/;
  		eval "require $lib";
  		
  		my %hash;
  		
  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$types ||= [qw/-types/];
  			ArrayLike->check($types)
  				or _croak("Expected arrayref following '%s'; got %s", $lib, $types);
  			
  			$lib->import({into => \%hash}, @$types);
  			$hash{$_} = &{$hash{$_}}() for keys %hash;
  		}
  		elsif ($lib->isa("MooseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MooseX::Types type constraint library. No import options currently supported", $lib);
  			
  			require Moose::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Moose::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		elsif ($lib->isa("MouseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MouseX::Types type constraint library. No import options currently supported", $lib);
  			
  			require Mouse::Util::TypeConstraints;
  			my $moosextypes = $lib->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Mouse::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		else
  		{
  			_croak("%s is not a type library", $lib);
  		}
  		
  		for my $key (sort keys %hash)
  		{
  			exists($self->{$key})
  				and _croak("Duplicate type name: %s", $key);
  			$self->{$key} = $hash{$key};
  		}
  	}
  	$self;
  }
  
  sub add_type
  {
  	my $self = shift;
  	my ($type, $name) = @_;
  	$type = to_TypeTiny($type);
  	$name ||= do {
  		$type->is_anon
  			and _croak("Expected named type constraint; got anonymous type constraint");
  		$type->name;
  	};
  	
  	exists($self->{$name})
  		and _croak("Duplicate type name: %s", $name);
  	
  	$self->{$name} = $type;
  	$self;
  }
  
  sub alias_type
  {
  	my $self = shift;
  	my ($old, @new) = @_;
  	$self->{$_} = $self->{$old} for @new;
  	$self;
  }
  
  sub simple_lookup
  {
  	my $self = shift;
  	
  	my ($tc) = @_;
  	$tc =~ s/(^\s+|\s+$)//g;
  	
  	if (exists $self->{$tc})
  	{
  		return $self->{$tc};
  	}
  	
  	return;
  }
  
  sub lookup
  {
  	my $self = shift;
  	
  	$self->simple_lookup(@_) or eval_type($_[0], $self);
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  	my $type = $self->simple_lookup($method);
  	return $type if $type;
  	_croak(q[Can't locate object method "%s" via package "%s"], $method, ref($self));
  }
  
  # Prevent AUTOLOAD being called for DESTROY!
  sub DESTROY
  {
  	return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords optlist
  
  =head1 NAME
  
  Type::Registry - a glorified hashref for looking up type constraints
  
  =head1 SYNOPSIS
  
     package Foo::Bar;
     
     use Type::Registry;
     
     my $reg = "Type::Registry"->for_me;  # a registry for Foo::Bar
     
     # Register all types from Types::Standard
     $reg->add_types(-Standard);
     
     # Register just one type from Types::XSD
     $reg->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     $reg->add_types("MyApp::Types");
     
     # Create a type alias
     $reg->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = $reg->lookup("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  Alternatively:
  
     package Foo::Bar;
     
     use Type::Registry qw( t );
     
     # Register all types from Types::Standard
     t->add_types(-Standard);
     
     # Register just one type from Types::XSD
     t->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     t->add_types("MyApp::Types");
     
     # Create a type alias
     t->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = t("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  =head1 STATUS
  
  Type::Registry (and L<Type::Parser>) is currently a pretty isolated part
  of this distribution. It seems like something that would be useful, but
  it's not heavily integrated with everything else. In particular, if you
  do:
  
     use Type::Registry qw(t);
     use Types::Standard -types;
  
  Then the C<Str>, C<Num>, etc keywords imported from L<Types::Standard> will
  work fine, but C<< t->lookup("Str") >> and C<< t->lookup("Num") >> will fail,
  because importing types from a library does not automatically add them to
  your registry.
  
  Clearly some kind of integration is desirable between Type::Registry and
  L<Type::Library>, but exactly what form that will take is still to be
  decided.
  
  So if you decide to use Type::Registry, be aware of its somewhat experimental
  status. It's not likely to disappear completely, but there may be changes
  ahead.
  
  =head1 DESCRIPTION
  
  A type registry is basically just a hashref mapping type names to type
  constraint objects.
  
  =head2 Constructors
  
  =over
  
  =item C<< new >>
  
  Create a new glorified hashref.
  
  =item C<< for_class($class) >>
  
  Create or return the existing glorified hashref associated with the given
  class.
  
  =item C<< for_me >>
  
  Create or return the existing glorified hashref associated with the caller.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< add_types(@libraries) >>
  
  The libraries list is treated as an "optlist" (a la L<Data::OptList>).
  
  Strings are the names of type libraries; if the first character is a
  hyphen, it is expanded to the "Types::" prefix. If followed by an
  arrayref, this is the list of types to import from that library.
  Otherwise, imports all types from the library.
  
     use Type::Registry qw(t);
     
     t->add_types(-Standard);  # OR: t->add_types("Types::Standard");
     
     t->add_types(
        -TypeTiny => ['HashLike'],
        -Standard => ['HashRef' => { -as => 'RealHash' }],
     );
  
  L<MooseX::Types> (and experimentally, L<MouseX::Types>) libraries can
  also be added this way, but I<< cannot be followed by an arrayref of
  types to import >>.
  
  =item C<< add_type($type, $name) >>
  
  The long-awaited singular form of C<add_types>. Given a type constraint
  object, adds it to the registry with a given name. The name may be
  omitted, in which case C<< $type->name >> is called, and Type::Registry
  will throw an error if C<< $type >> is anonymous. If a name is explicitly
  given, Type::Registry cares not one wit whether the type constraint is
  anonymous.
  
  This method can even add L<MooseX::Types> and L<MouseX::Types> type
  constraints; indeed anything that can be handled by L<Types::TypeTiny>'s
  C<to_TypeTiny> function. (Bear in mind that to_TypeTiny I<always> results
  in an anonymous type constraint, so C<< $name >> will be required.)
  
  =item C<< alias_type($oldname, $newname) >>
  
  Create an alias for an existing type.
  
  =item C<< simple_lookup($name) >>
  
  Look up a type in the registry by name. 
  
  Returns undef if not found.
  
  =item C<< lookup($name) >>
  
  Look up by name, with a DSL.
  
     t->lookup("Int|ArrayRef[Int]")
  
  The DSL can be summed up as:
  
     X               type from this registry
     My::Lib::X      type from a type library
     ~X              complementary type
     X | Y           union
     X & Y           intersection
     X[...]          parameterized type
     slurpy X        slurpy type
     Foo::Bar::      class type
  
  Croaks if not found.
  
  =item C<< AUTOLOAD >>
  
  Overloaded to call C<lookup>.
  
     $registry->Str;  # like $registry->lookup("Str")
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< t >>
  
  This class can export a function C<< t >> which acts like
  C<< "Type::Registry"->for_class($importing_class) >>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Library>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_REGISTRY

$fatpacked{"Type/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY';
  package Type::Tiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::VERSION   = '0.034';
  }
  
  use Eval::TypeTiny ();
  use Scalar::Util qw( blessed weaken refaddr isweak );
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _swap { $_[2] ? @_[1,0] : @_[0,1] }
  
  BEGIN {
  	($] > 5.010001)
  		? eval q{ sub SUPPORT_SMARTMATCH () { !!0 } }
  		: eval q{ sub SUPPORT_SMARTMATCH () { !!1 } }
  }
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	q(+)       => sub { $_[2] ? $_[1]->plus_coercions($_[0]) : $_[0]->plus_fallback_coercions($_[1]) },
  	q(|)       => sub { my @tc = _swap @_; require Type::Tiny::Union; "Type::Tiny::Union"->new(type_constraints => \@tc) },
  	q(&)       => sub { my @tc = _swap @_; require Type::Tiny::Intersection; "Type::Tiny::Intersection"->new(type_constraints => \@tc) },
  	q(~)       => sub { shift->complementary_type },
  	q(==)      => sub { $_[0]->equals($_[1]) },
  	q(<)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(_swap @_) },
  	q(>)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(reverse _swap @_) },
  	q(<=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(_swap @_) },
  	q(>=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(reverse _swap @_) },
  	q(eq)      => sub { "$_[0]" eq "$_[1]" },
  	q(cmp)     => sub { $_[2] ? ("$_[1]" cmp "$_[0]") : ("$_[0]" cmp "$_[1]") },
  	fallback   => 1,
  ;
  BEGIN {
  	overload->import(q(~~) => sub { $_[0]->check($_[1]) })
  		if Type::Tiny::SUPPORT_SMARTMATCH;
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	$self->message unless exists $self->{message};
  	
  #	if ($self->has_parent && $self->_is_null_constraint)
  #	{
  #		$self->{_overload_coderef} ||= $self->parent->_overload_coderef;
  #	}
  #	els
  	if (!exists($self->{message}) && exists(&Sub::Quote::quote_sub) && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_assert('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->assert_return(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  our %ALL_TYPES;
  
  my $QFS;
  my $uniq = 1;
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	if (exists $params{parent})
  	{
  		$params{parent} = ref($params{parent}) =~ /^Type::Tiny\b/
  			? $params{parent}
  			: Types::TypeTiny::to_TypeTiny($params{parent});
  		
  		_croak "Parent must be an instance of %s", __PACKAGE__
  			unless blessed($params{parent}) && $params{parent}->isa(__PACKAGE__);
  	}
  	
  	$params{name} = "__ANON__" unless exists $params{name};
  	$params{uniq} = $uniq++;
  	
  	if ($params{name} ne "__ANON__")
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$params{name} =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $params{name} =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid type name', $params{name};
  	}
  	
  	if (exists $params{coercion} and !ref $params{coercion} and $params{coercion})
  	{
  		$params{parent}->has_coercion
  			or _croak "coercion => 1 requires type to have a direct parent with a coercion";
  		
  		$params{coercion} = $params{parent}->coercion;
  	}
  	
  	if (!exists $params{inlined}
  	and exists $params{constraint}
  	and ( !exists $params{parent} or $params{parent}->can_be_inlined )
  	and $QFS ||= "Sub::Quote"->can("quoted_from_sub"))
  	{
  		my (undef, $perlstring, $captures) = @{ $QFS->($params{constraint}) || [] };
  		
  		$params{inlined} = sub {
  			my ($self, $var) = @_;
  			my $code = Sub::Quote::inlinify(
  				$var eq q($_) ? $perlstring : "local \$_ = $var; $perlstring",
  				$var,
  			);
  			$code = sprintf('%s and %s', $self->parent->inline_check($var), $code) if $self->has_parent;
  			return $code;
  		} if $perlstring && !$captures;
  	}
  	
  	my $self = bless \%params, $class;
  	
  	unless ($params{tmp})
  	{
  		my $uniq = $self->{uniq};
  		
  		$ALL_TYPES{$uniq} = $self;
  		weaken( $ALL_TYPES{$uniq} );
  		
  		$Moo::HandleMoose::TYPE_MAP{overload::StrVal($self)} = sub { $ALL_TYPES{$uniq} };
  	}
  	
  	if (ref($params{coercion}) eq q(CODE))
  	{
  		require Types::Standard;
  		my $code = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(Types::Standard::Any(), $code);
  	}
  	elsif (ref($params{coercion}) eq q(ARRAY))
  	{
  		my $arr = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(@$arr);
  	}
  	
  	$self->{type_constraints} ||= undef;
  	
  	return $self;
  }
  
  sub DESTROY
  {
  	my $self = shift;
  	delete( $ALL_TYPES{$self->{uniq}} );
  	delete( $Moo::HandleMoose::TYPE_MAP{overload::StrVal($self)} );
  	return;
  }
  
  sub _clone
  {
  	my $self = shift;
  	my %opts;
  	$opts{$_} = $self->{$_} for qw< name display_name message >;
  	$self->create_child_type(%opts);
  }
  
  our $DD;
  sub _dd
  {
  	@_ = $_ unless @_;
  	my ($value) = @_;
  	
  	goto $DD if ref($DD) eq q(CODE);
  	
  	require B;
  	
  	!defined $value ? 'Undef' :
  	!ref $value     ? sprintf('Value %s', B::perlstring($value)) :
  	do {
  		my $N = 0 + (defined($DD) ? $DD : 72);
  		require Data::Dumper;
  		local $Data::Dumper::Indent   = 0;
  		local $Data::Dumper::Useqq    = 1;
  		local $Data::Dumper::Terse    = 1;
  		local $Data::Dumper::Sortkeys = 1;
  		local $Data::Dumper::Maxdepth = 2;
  		my $str = Data::Dumper::Dumper($value);
  		$str = substr($str, 0, $N - 12).'...'.substr($str, -1, 1)
  			if length($str) >= $N;
  		"Reference $str";
  	}
  }
  
  sub _loose_to_TypeTiny
  {
  	map +(
  		ref($_)
  			? Types::TypeTiny::to_TypeTiny($_)
  			: do { require Type::Utils; Type::Utils::dwim_type($_) }
  	), @_;
  }
  
  sub name                     { $_[0]{name} }
  sub display_name             { $_[0]{display_name}   ||= $_[0]->_build_display_name }
  sub parent                   { $_[0]{parent} }
  sub constraint               { $_[0]{constraint}     ||= $_[0]->_build_constraint }
  sub compiled_check           { $_[0]{compiled_type_constraint} ||= $_[0]->_build_compiled_check }
  sub coercion                 { $_[0]{coercion}       ||= $_[0]->_build_coercion }
  sub message                  { $_[0]{message} }
  sub library                  { $_[0]{library} }
  sub inlined                  { $_[0]{inlined} }
  sub constraint_generator     { $_[0]{constraint_generator} }
  sub inline_generator         { $_[0]{inline_generator} }
  sub name_generator           { $_[0]{name_generator} ||= $_[0]->_build_name_generator }
  sub coercion_generator       { $_[0]{coercion_generator} }
  sub parameters               { $_[0]{parameters} }
  sub moose_type               { $_[0]{moose_type}     ||= $_[0]->_build_moose_type }
  sub mouse_type               { $_[0]{mouse_type}     ||= $_[0]->_build_mouse_type }
  sub deep_explanation         { $_[0]{deep_explanation} }
  
  sub has_parent               { exists $_[0]{parent} }
  sub has_library              { exists $_[0]{library} }
  sub has_coercion             {        $_[0]{coercion} and !!@{ $_[0]{coercion}->type_coercion_map } }
  sub has_inlined              { exists $_[0]{inlined} }
  sub has_constraint_generator { exists $_[0]{constraint_generator} }
  sub has_inline_generator     { exists $_[0]{inline_generator} }
  sub has_coercion_generator   { exists $_[0]{coercion_generator} }
  sub has_parameters           { exists $_[0]{parameters} }
  sub has_message              { defined $_[0]{message} }
  sub has_deep_explanation     { exists $_[0]{deep_explanation} }
  
  sub _default_message         { $_[0]{_default_message} ||= $_[0]->_build_default_message }
  
  sub _assert_coercion
  {
  	my $self = shift;
  	_croak "No coercion for this type constraint"
  		unless $self->has_coercion && @{$self->coercion->type_coercion_map};
  	return $self->coercion;
  }
  
  my $null_constraint = sub { !!1 };
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub _build_constraint
  {
  	return $null_constraint;
  }
  
  sub _is_null_constraint
  {
  	shift->constraint == $null_constraint;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion;
  	my $self = shift;
  	my %opts = (type_constraint => $self);
  	$opts{display_name} = "to_$self" unless $self->is_anon;
  	return "Type::Coercion"->new(%opts);
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	return sub { sprintf '%s did not pass type constraint', _dd($_[0]) } if "$self" eq "__ANON__";
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s"', _dd($_[0]), $name };
  }
  
  sub _build_name_generator
  {
  	my $self = shift;
  	return sub {
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], @a);
  	};
  }
  
  sub _build_compiled_check
  {
  	my $self = shift;
  	
  	if ($self->_is_null_constraint and $self->has_parent)
  	{
  		return $self->parent->compiled_check;
  	}
  	
  	if ($INC{'Mouse/Util.pm'} and Mouse::Util::MOUSE_XS())
  	{
  		require Mouse::Util::TypeConstraints;
  		
  		if ($self->{_is_core})
  		{
  			my $xs = "Mouse::Util::TypeConstraints"->can($self->name);
  			return $xs if $xs;
  		}
  		elsif ($self->is_parameterized and $self->has_parent
  		and $self->parent->{_is_core} and $self->parent->name =~ /^(ArrayRef|HashRef|Maybe)$/)
  		{
  			my $xs = "Mouse::Util::TypeConstraints"->can("_parameterize_".$self->parent->name."_for");
  			return $xs->($self->parameters->[0]) if $xs;
  		}
  	}
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', $self->inline_check('$_[0]')),
  		description => sprintf("compiled check '%s'", $self),
  	) if $self->can_be_inlined;
  	
  	my @constraints;
  	push @constraints, $self->parent->compiled_check if $self->has_parent;
  	push @constraints, $self->constraint if !$self->_is_null_constraint;
  	return $null_constraint unless @constraints;
  	
  	return sub ($)
  	{
  		local $_ = $_[0];
  		for my $c (@constraints)
  		{
  			return unless $c->(@_);
  		}
  		return !!1;
  	};
  }
  
  sub equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	return !!1 if refaddr($self) == refaddr($other);
  	
  	return !!1 if $self->has_parent  && $self->_is_null_constraint  && $self->parent==$other;
  	return !!1 if $other->has_parent && $other->_is_null_constraint && $other->parent==$self;
  	
  	return !!1 if refaddr($self->compiled_check) == refaddr($other->compiled_check);
  	
  	return $self->qualified_name eq $other->qualified_name
  		if $self->has_library && !$self->is_anon && $other->has_library && !$other->is_anon;
  	
  	return $self->inline_check('$x') eq $other->inline_check('$x')
  		if $self->can_be_inlined && $other->can_be_inlined;
  	
  	return;
  }
  
  sub is_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->equals($other) or $self->parent->is_subtype_of($other);
  }
  
  sub is_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_subtype_of($self);
  }
  
  sub is_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->equals($other) or $self->is_subtype_of($other);
  }
  
  sub strictly_equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	$self->{uniq} == $other->{uniq};
  }
  
  sub is_strictly_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->strictly_equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->strictly_equals($other) or $self->parent->is_strictly_subtype_of($other);
  }
  
  sub is_strictly_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_strictly_subtype_of($self);
  }
  
  sub is_strictly_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->strictly_equals($other) or $self->is_strictly_subtype_of($other);
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	(exists $self->{library} and $self->name ne "__ANON__")
  		? "$self->{library}::$self->{name}"
  		: $self->{name};
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub parents
  {
  	my $self = shift;
  	return unless $self->has_parent;
  	return ($self->parent, $self->parent->parents);
  }
  
  sub check
  {
  	my $self = shift;
  	($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  }
  
  sub _strict_check
  {
  	my $self = shift;
  	local $_ = $_[0];
  
  	my @constraints =
  		reverse
  		map  { $_->constraint }
  		grep { not $_->_is_null_constraint }
  		($self, $self->parents);
  	
  	for my $c (@constraints)
  	{
  		return unless $c->(@_);
  	}
  	
  	return !!1;
  }
  
  sub get_message
  {
  	my $self = shift;
  	local $_ = $_[0];
  	$self->has_message
  		? $self->message->(@_)
  		: $self->_default_message->(@_);
  }
  
  sub validate
  {
  	my $self = shift;
  	
  	return undef if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	return $self->get_message(@_);
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	if ($self->has_parent)
  	{
  		my $parent = $self->parent->validate_explain($value, $varname);
  		return [ sprintf('"%s" is a subtype of "%s"', $self, $self->parent), @$parent ] if $parent;
  	}
  	
  	my $message = sprintf(
  		'%s%s',
  		$self->get_message($value),
  		$varname eq q{$_} ? '' : sprintf(' (in %s)', $varname),
  	);
  	
  	if ($self->is_parameterized and $self->parent->has_deep_explanation)
  	{
  		my $deep = $self->parent->deep_explanation->($self, $value, $varname);
  		return [ $message, @$deep ] if $deep;
  	}
  	
  	return [ $message, sprintf('"%s" is defined as: %s', $self, $self->_perlcode) ];
  }
  
  my $b;
  sub _perlcode
  {
  	my $self = shift;
  	
  	return $self->inline_check('$_')
  		if $self->can_be_inlined;
  	
  	$b ||= do {
  		require B::Deparse;
  		my $tmp = "B::Deparse"->new;
  		$tmp->ambient_pragmas(strict => "all", warnings => "all") if $tmp->can('ambient_pragmas');
  		$tmp;
  	};
  	
  	my $code = $b->coderef2text($self->constraint);
  	$code =~ s/\s+/ /g;
  	return "sub $code";
  }
  
  sub assert_valid
  {
  	my $self = shift;
  	
  	return !!1 if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub assert_return
  {
  	my $self = shift;
  	
  	return $_[0] if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	return $self->parent->can_be_inlined
  		if $self->has_parent && $self->_is_null_constraint;
  	return !!1
  		if !$self->has_parent && $self->_is_null_constraint;
  	return $self->has_inlined;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	_croak 'Cannot inline type constraint check for "%s"', $self
  		unless $self->can_be_inlined;
  	
  	return $self->parent->inline_check(@_)
  		if $self->has_parent && $self->_is_null_constraint;
  	return '(!!1)'
  		if !$self->has_parent && $self->_is_null_constraint;
  	
  	local $_ = $_[0];
  	my @r = $self->inlined->($self, @_);
  	if (@r and not defined $r[0])
  	{
  		_croak 'Inlining type constraint check for "%s" returned undef!', $self
  			unless $self->has_parent;
  		$r[0] = $self->parent->inline_check(@_);
  	}
  	my $r = join " && " => map { /[;{}]/ ? "do { $_ }" : "($_)" } @r;
  	return @r==1 ? $r : "($r)";
  }
  
  sub inline_assert
  {
  	require B;
  	my $self = shift;
  	my $varname = $_[0];
  	my $code = sprintf(
  		q[do { no warnings "void"; %s ? %s : Type::Tiny::_failed_check(%d, %s, %s) };],
  		$self->inline_check(@_),
  		$varname,
  		$self->{uniq},
  		B::perlstring("$self"),
  		$varname,
  	);
  	return $code;
  }
  
  sub _failed_check
  {
  	require Error::TypeTiny::Assertion;
  	
  	my ($self, $name, $value, %attrs) = @_;
  	$self = $ALL_TYPES{$self} unless ref $self;
  	
  	my $exception_class = delete($attrs{exception_class}) || "Error::TypeTiny::Assertion";
  	
  	if ($self)
  	{
  		$exception_class->throw(
  			message => $self->get_message($value),
  			type    => $self,
  			value   => $value,
  			%attrs,
  		);
  	}
  	else
  	{
  		$exception_class->throw(
  			message => sprintf('%s did not pass type constraint "%s"', _dd($value), $name),
  			value   => $value,
  			%attrs,
  		);
  	}
  }
  
  sub coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->coerce(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->assert_coerce(@_);
  }
  
  sub is_parameterizable
  {
  	shift->has_constraint_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  my %param_cache;
  sub parameterize
  {
  	my $self = shift;
  	
  	$self->is_parameterizable
  		or @_ ? _croak("Type '%s' does not accept parameters", "$self") : return($self);
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  
  	# Generate a key for caching parameterized type constraints,
  	# but only if all the parameters are strings or type constraints.
  	my $key;
  	if ( not grep(ref($_) && !Types::TypeTiny::TypeTiny->check($_), @_) )
  	{
  		require B;
  		$key = join ":", map(Types::TypeTiny::TypeTiny->check($_) ? $_->{uniq} : B::perlstring($_), $self, @_);
  	}
  	
  	return $param_cache{$key} if defined $key && defined $param_cache{$key};
  	
  	local $Type::Tiny::parameterize_type = $self;
  	local $_ = $_[0];
  	my $P;
  	
  	my $constraint = $self->constraint_generator->(@_);
  	
  	if (Types::TypeTiny::TypeTiny->check($constraint))
  	{
  		$P = $constraint;
  	}
  	else
  	{
  		my %options = (
  			constraint   => $constraint,
  			display_name => $self->name_generator->($self, @_),
  			parameters   => [@_],
  		);
  		$options{inlined} = $self->inline_generator->(@_)
  			if $self->has_inline_generator;
  		exists $options{$_} && !defined $options{$_} && delete $options{$_}
  			for keys %options;
  		
  		$P = $self->create_child_type(%options);
  		
  		my $coercion;
  		$coercion = $self->coercion_generator->($self, $P, @_)
  			if $self->has_coercion_generator;
  		$P->coercion->add_type_coercions( @{$coercion->type_coercion_map} )
  			if $coercion;
  	}
  	
  	if (defined $key)
  	{
  		$param_cache{$key} = $P;
  		weaken($param_cache{$key});
  	}
  	
  	return $P;
  }
  
  sub child_type_class
  {
  	__PACKAGE__;
  }
  
  sub create_child_type
  {
  	my $self = shift;
  	return $self->child_type_class->new(parent => $self, @_);
  }
  
  sub complementary_type
  {
  	my $self = shift;
  	my $r    = ($self->{complementary_type} ||= $self->_build_complementary_type);
  	weaken($self->{complementary_type}) unless isweak($self->{complementary_type});
  	return $r;
  }
  
  sub _build_complementary_type
  {
  	my $self = shift;
  	my %opts = (
  		constraint   => sub { not $self->check($_) },
  		display_name => sprintf("~%s", $self),
  	);
  	$opts{display_name} =~ s/^\~{2}//;
  	$opts{inlined} = sub { shift; "not(".$self->inline_check(@_).")" }
  		if $self->can_be_inlined;
  	return "Type::Tiny"->new(%opts);
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	require Moose::Meta::TypeConstraint;
  	return "Moose::Meta::TypeConstraint"->new(%opts);
  }
  
  sub _build_moose_type
  {
  	my $self = shift;
  	
  	my $r;
  	if ($self->{_is_core})
  	{
  		require Moose::Util::TypeConstraints;
  		$r = Moose::Util::TypeConstraints::find_type_constraint($self->name);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		Scalar::Util::weaken($r->{"Types::TypeTiny::to_TypeTiny"});
  	}
  	else
  	{
  		my %opts;
  		$opts{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  		$opts{parent}     = $self->parent->moose_type if $self->has_parent;
  		$opts{constraint} = $self->constraint         unless $self->_is_null_constraint;
  		$opts{message}    = $self->message            if $self->has_message;
  		$opts{inlined}    = $self->inlined            if $self->has_inlined;
  		
  		$r = $self->_instantiate_moose_type(%opts);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		$self->{moose_type} = $r;  # prevent recursion
  		$r->coercion($self->coercion->moose_coercion) if $self->has_coercion;
  	}
  		
  	return $r;
  }
  
  sub _build_mouse_type
  {
  	my $self = shift;
  	
  	my %options;
  	$options{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  	$options{parent}     = $self->parent->mouse_type if $self->has_parent;
  	$options{constraint} = $self->constraint         unless $self->_is_null_constraint;
  	$options{message}    = $self->message            if $self->has_message;
  		
  	require Mouse::Meta::TypeConstraint;
  	my $r = "Mouse::Meta::TypeConstraint"->new(%options);
  	
  	$self->{mouse_type} = $r;  # prevent recursion
  	$r->_add_type_coercions(
  		$self->coercion->freeze->_codelike_type_coercion_map('mouse_type')
  	) if $self->has_coercion;
  	
  	return $r;
  }
  
  sub plus_coercions
  {
  	my $self = shift;
  	
  	my @more = (@_==1 && blessed($_[0]) && $_[0]->can('type_coercion_map'))
  		? @{ $_[0]->type_coercion_map }
  		: (@_==1 && ref $_[0]) ? @{$_[0]} : @_;
  	
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		@more,
  		@{$self->coercion->type_coercion_map},
  	);
  	return $new;
  }
  
  sub plus_fallback_coercions
  {
  	my $self = shift;
  	
  	my @more = (@_==1 && blessed($_[0]) && $_[0]->can('type_coercion_map'))
  		? @{ $_[0]->type_coercion_map }
  		: (@_==1 && ref $_[0]) ? @{$_[0]} : @_;
  	
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		@{$self->coercion->type_coercion_map},
  		@more,
  	);
  	return $new;
  }
  
  sub minus_coercions
  {
  	my $self = shift;
  	
  	my @not = (@_==1 && blessed($_[0]) && $_[0]->can('type_coercion_map'))
  		? grep(blessed($_)&&$_->isa("Type::Tiny"), @{ $_[0]->type_coercion_map })
  		: (@_==1 && ref $_[0]) ? @{$_[0]} : @_;
  	
  	my @keep;
  	my $c = $self->coercion->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		my $keep_this = 1;
  		NOT: for my $n (@not)
  		{
  			if ($c->[$i] == $n)
  			{
  				$keep_this = 0;
  				last NOT;
  			}
  		}
  		
  		push @keep, $c->[$i], $c->[$i+1] if $keep_this;
  	}
  
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(@keep);
  	return $new;
  }
  
  sub no_coercions
  {
  	shift->_clone;
  }
  
  sub coercibles
  {
  	my $self = shift;
  	$self->has_coercion ? $self->coercion->_source_type_union : $self;
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and ref($self))
  	{
  		return !!1                       if $_[0] eq 'Moose::Meta::TypeConstraint';
  		return $self->is_parameterized   if $_[0] eq 'Moose::Meta::TypeConstraint::Parameterized';
  		return $self->is_parameterizable if $_[0] eq 'Moose::Meta::TypeConstraint::Parameterizable';
  	}
  	
  	if ($INC{"Moose.pm"} and ref($self) and $_[0] =~ /^Moose/ and my $r = $self->moose_type->isa(@_))
  	{
  		return $r;
  	}
  
  	if ($INC{"Mouse.pm"} and ref($self) and $_[0] eq 'Mouse::Meta::TypeConstraint')
  	{
  		return !!1;
  	}
  
  	$self->SUPER::isa(@_);
  }
  
  sub can
  {
  	my $self = shift;
  	
  	return !!0 if $_[0] eq 'type_parameter' && blessed($_[0]) && $_[0]->has_parameters;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if ($INC{"Moose.pm"} and ref($self) and my $method = $self->moose_type->can(@_))
  	{
  		return sub { $method->(shift->moose_type, @_) };
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if ($INC{"Moose.pm"} and ref($self) and my $method = $self->moose_type->can($m))
  	{
  		return $method->($self->moose_type, @_);
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  sub DOES
  {
  	my $self = shift;
  	
  	return !!1 if  ref($self) && $_[0] =~ m{^ Type::API::Constraint (?: ::Coercible | ::Inlinable )? $}x;
  	return !!1 if !ref($self) && $_[0] eq 'Type::API::Constraint::Constructor';
  	
  	"UNIVERSAL"->can("DOES") ? $self->SUPER::DOES(@_) : $self->isa(@_);
  }
  
  # fill out Moose-compatible API
  sub inline_environment         { +{} }
  sub _inline_check              { shift->inline_check(@_) }
  sub _compiled_type_constraint  { shift->compiled_check(@_) }
  sub meta                       { _croak("Not really a Moose::Meta::TypeConstraint. Sorry!") }
  sub compile_type_constraint    { shift->compiled_check }
  sub _actually_compile_type_constraint   { shift->_build_compiled_check }
  sub hand_optimized_type_constraint      { shift->{hand_optimized_type_constraint} }
  sub has_hand_optimized_type_constraint  { exists(shift->{hand_optimized_type_constraint}) }
  sub type_parameter             { my @p = @{ shift->parameters || [] }; @p==1 ? $p[0] : @p }
  
  # some stuff for Mouse-compatible API
  sub __is_parameterized         { shift->is_parameterized(@_) }
  sub _add_type_coercions        { shift->coercion->add_type_coercions(@_) };
  sub _as_string                 { shift->qualified_name(@_) }
  sub _compiled_type_coercion    { shift->coercion->compiled_coercion(@_) };
  sub _identity                  { refaddr(shift) };
  sub _unite                     { require Type::Tiny::Union; "Type::Tiny::Union"->new(type_constraints => \@_) };
  
  # Hooks for Type::Tie
  sub TIESCALAR  { require Type::Tie; unshift @_, 'Type::Tie::SCALAR'; goto \&Type::Tie::SCALAR::TIESCALAR };
  sub TIEARRAY   { require Type::Tie; unshift @_, 'Type::Tie::ARRAY';  goto \&Type::Tie::SCALAR::TIEARRAY };
  sub TIEHASH    { require Type::Tie; unshift @_, 'Type::Tie::HASH';   goto \&Type::Tie::SCALAR::TIEHASH };
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX MouseX MooX Moose-compat
  
  =head1 NAME
  
  Type::Tiny - tiny, yet Moo(se)-compatible type constraint
  
  =head1 SYNOPSIS
  
     use Scalar::Util qw(looks_like_number);
     use Type::Tiny;
     
     my $NUM = "Type::Tiny"->new(
        name       => "Number",
        constraint => sub { looks_like_number($_) },
        message    => sub { "$_ ain't a number" },
     );
     
     package Ermintrude {
        use Moo;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Bullwinkle {
        use Moose;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Maisy {
        use Mouse;
        has favourite_number => (is => "ro", isa => $NUM);
     }
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> is a tiny class for creating Moose-like type constraint
  objects which are compatible with Moo, Moose and Mouse.
  
  Maybe now we won't need to have separate MooseX, MouseX and MooX versions
  of everything? We can but hope...
  
  This documents the internals of L<Type::Tiny>. L<Type::Tiny::Manual> is
  a better starting place if you're new.
  
  =head2 Constructor
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<< name >>
  
  The name of the type constraint. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous type constraint.
  
  =item C<< display_name >>
  
  A name to display for the type constraint when stringified. These don't
  have to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<< parent >>
  
  Optional attribute; parent type constraint. For example, an "Integer"
  type constraint might have a parent "Number".
  
  If provided, must be a Type::Tiny object.
  
  =item C<< constraint >>
  
  Coderef to validate a value (C<< $_ >>) against the type constraint. The
  coderef will not be called unless the value is known to pass any parent
  type constraint.
  
  Defaults to C<< sub { 1 } >> - i.e. a coderef that passes all values.
  
  =item C<< compiled_check >>
  
  Coderef to validate a value (C<< $_[0] >>) against the type constraint.
  This coderef is expected to also handle all validation for the parent
  type constraints.
  
  The general point of this attribute is that you should not set it, and
  rely on the lazily-built default. Type::Tiny will usually generate a
  pretty fast coderef.
  
  =item C<< message >>
  
  Coderef that returns an error message when C<< $_ >> does not validate
  against the type constraint. Optional (there's a vaguely sensible default.)
  
  =item C<< inlined >>
  
  A coderef which returns a string of Perl code suitable for inlining this
  type. Optional.
  
  If C<constraint> (above) is a coderef generated via L<Sub::Quote>, then
  Type::Tiny I<may> be able to automatically generate C<inlined> for you.
  
  =item C<< library >>
  
  The package name of the type library this type is associated with.
  Optional. Informational only: setting this attribute does not install
  the type into the package.
  
  =item C<< coercion >>
  
  A L<Type::Coercion> object associated with this type.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built coercion object.
  
  You may pass C<< coercion => 1 >> to the constructor to inherit coercions
  from the constraint's parent. (This requires the parent constraint to have
  a coercion.)
  
  =item C<< complementary_type >>
  
  A complementary type for this type. For example, the complementary type
  for an integer type would be all things that are not integers, including
  floating point numbers, but also alphabetic strings, arrayrefs, filehandles,
  etc.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built complementary type.
  
  =item C<< moose_type >>, C<< mouse_type >>
  
  Objects equivalent to this type constraint, but as a
  L<Moose::Meta::TypeConstraint> or L<Mouse::Meta::TypeConstraint>.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built objects.
  
  It should rarely be necessary to obtain a L<Moose::Meta::TypeConstraint>
  object from L<Type::Tiny> because the L<Type::Tiny> object itself should
  be usable pretty much anywhere a L<Moose::Meta::TypeConstraint> is expected.
  
  =back
  
  The following additional attributes are used for parameterizable (e.g.
  C<ArrayRef>) and parameterized (e.g. C<< ArrayRef[Int] >>) type
  constraints. Unlike Moose, these aren't handled by separate subclasses.
  
  =over
  
  =item C<< parameters >>
  
  In parameterized types, returns an arrayref of the parameters.
  
  =item C<< name_generator >>
  
  A coderef which generates a new display_name based on parameters.
  Optional; the default is reasonable.
  
  =item C<< constraint_generator >>
  
  Coderef that generates a new constraint coderef based on parameters.
  Optional; providing a generator makes this type into a parameterizable
  type constraint.
  
  =item C<< inline_generator >>
  
  A coderef which generates a new inlining coderef based on parameters.
  
  =item C<< coercion_generator >>
  
  A coderef which generates a new L<Type::Coercion> object based on parameters.
  
  =item C<< deep_explanation >>
  
  This API is not finalized. Coderef used by L<Error::TypeTiny::Assertion> to
  peek inside parameterized types and figure out why a value doesn't pass the
  constraint.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_parent>, C<has_library>, C<has_inlined>, C<has_constraint_generator>, C<has_inline_generator>, C<has_coercion_generator>, C<has_parameters>, C<has_message>, C<has_deep_explanation>
  
  Predicate methods.
  
  =item C<has_coercion>
  
  Predicate method with a little extra DWIM. Returns false if the coercion is
  a no-op.
  
  =item C<< is_anon >>
  
  Returns true iff the type constraint does not have a C<name>.
  
  =item C<< is_parameterized >>, C<< is_parameterizable >>
  
  Indicates whether a type has been parameterized (e.g. C<< ArrayRef[Int] >>)
  or could potentially be (e.g. C<< ArrayRef >>).
  
  =item C<< qualified_name >>
  
  For non-anonymous type constraints that have a library, returns a qualified
  C<< "Library::Type" >> sort of name. Otherwise, returns the same as C<name>.
  
  =item C<< parents >>
  
  Returns a list of all this type constraint's ancestor constraints. For
  example, if called on the C<Str> type constraint would return the list
  C<< (Value, Defined, Item, Any) >>.
  
  B<< Due to a historical misunderstanding, this differs from the Moose
  implementation of the C<parents> method. In Moose, C<parents> only returns the
  immediate parent type constraints, and because type constraints only have
  one immediate parent, this is effectively an alias for C<parent>. The
  extension module L<MooseX::Meta::TypeConstraint::Intersection> is the only
  place where multiple type constraints are returned; and they are returned
  as an arrayref in violation of the base class' documentation. I'm keeping
  my behaviour as it seems more useful. >>
  
  =item C<< equals($other) >>, C<< is_subtype_of($other) >>, C<< is_supertype_of($other) >>, C<< is_a_type_of($other) >>
  
  Compare two types. See L<Moose::Meta::TypeConstraint> for what these all mean.
  (OK, Moose doesn't define C<is_supertype_of>, but you get the idea, right?)
  
  Note that these have a slightly DWIM side to them. If you create two
  L<Type::Tiny::Class> objects which test the same class, they're considered
  equal. And:
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_subtype_of( $subtype_of_Num );  # true
  
  =item C<< strictly_equals($other) >>, C<< is_strictly_subtype_of($other) >>, C<< is_strictly_supertype_of($other) >>, C<< is_strictly_a_type_of($other) >>
  
  Stricter versions of the type comparison functions. These only care about
  explicit inheritance via C<parent>.
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_strictly_subtype_of( $subtype_of_Num );  # false
  
  =item C<< check($value) >>
  
  Returns true iff the value passes the type constraint.
  
  =item C<< validate($value) >>
  
  Returns the error message for the value; returns an explicit undef if the
  value passes the type constraint.
  
  =item C<< validate_explain($value, $varname) >>
  
  Like C<validate> but instead of a string error message, returns an arrayref
  of strings explaining the reasoning why the value does not meet the type
  constraint, examining parent types, etc.
  
  The C<< $varname >> is an optional string like C<< '$foo' >> indicating the
  name of the variable being checked.
  
  =item C<< assert_valid($value) >>
  
  Like C<< check($value) >> but dies if the value does not pass the type
  constraint.
  
  Yes, that's three very similar methods. Blame L<Moose::Meta::TypeConstraint>
  whose API I'm attempting to emulate. :-)
  
  =item C<< assert_return($value) >>
  
  Like C<< assert_valid($value) >> but returns the value if it passes the type
  constraint.
  
  This seems a more useful behaviour than C<< assert_valid($value) >>. I would
  have just changed C<< assert_valid($value) >> to do this, except that there
  are edge cases where it could break Moose compatibility.
  
  =item C<< get_message($value) >>
  
  Returns the error message for the value; even if the value passes the type
  constraint.
  
  =item C<< coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type.
  
  =item C<< assert_coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type. Throws an exception if this is
  not possible.
  
  =item C<< coercibles >>
  
  Return a type constraint which is the union of type constraints that can be
  coerced to this one (including this one). If this type constraint has no
  coercions, returns itself.
  
  =item C<< can_be_inlined >>
  
  Returns boolean indicating if this type can be inlined.
  
  =item C<< inline_check($varname) >>
  
  Creates a type constraint check for a particular variable as a string of
  Perl code. For example:
  
     print( Types::Standard::Num->inline_check('$foo') );
  
  prints the following output:
  
     (!ref($foo) && Scalar::Util::looks_like_number($foo))
  
  For Moose-compat, there is an alias C<< _inline_check >> for this method.
  
  =item C<< inline_assert($varname) >>
  
  Much like C<inline_check> but outputs a statement of the form:
  
     die ... unless ...;
  
  Note that if this type has a custom error message, the inlined code will
  I<ignore> this custom message!!
  
  =item C<< parameterize(@parameters) >>
  
  Creates a new parameterized type; throws an exception if called on a
  non-parameterizable type.
  
  =item C<< create_child_type(%attributes) >>
  
  Construct a new Type::Tiny object with this object as its parent.
  
  =item C<< child_type_class >>
  
  The class that create_child_type will construct.
  
  =item C<< plus_coercions($type1, $code1, ...) >>
  
  Shorthand for creating a new child type constraint with the same coercions
  as this one, but then adding some extra coercions (at a higher priority than
  the existing ones).
  
  =item C<< plus_fallback_coercions($type1, $code1, ...) >>
  
  Like C<plus_coercions>, but added at a lower priority.
  
  =item C<< minus_coercions($type1, ...) >>
  
  Shorthand for creating a new child type constraint with fewer type coercions.
  
  =item C<< no_coercions >>
  
  Shorthand for creating a new child type constraint with no coercions at all.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeConstraint.
  
  If Mouse is loaded, then C<isa> mocks Mouse::Meta::TypeConstraint.
  
  =item C<< DOES($role) >>
  
  Overridden to advertise support for various roles.
  
  See also L<Type::API::Constraint>, etc.
  
  =item C<< TIESCALAR >>, C<< TIEARRAY >>, C<< TIEHASH >>
  
  These are provided as hooks that wrap L<Type::Tie>. (Type::Tie is distributed
  separately, and can be used with non-Type::Tiny type constraints too.) They
  allow the following to work:
  
     use Types::Standard qw(Int);
     tie my @list, Int;
     push @list, 123, 456;   # ok
     push @list, "Hello";    # dies
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_constraint >>
  
  =item C<< hand_optimized_type_constraint >>
  
  =item C<< has_hand_optimized_type_constraint >>
  
  =item C<< inline_environment >>
  
  =item C<< meta >>
  
  =item C<< type_parameter >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to return the qualified name.
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<assert_return>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<check>.
  
  =item *
  
  The C<< == >> operator is overloaded to call C<equals>.
  
  =item *
  
  The C<< < >> and C<< > >> operators are overloaded to call C<is_subtype_of>
  and C<is_supertype_of>.
  
  =item *
  
  The C<< ~ >> operator is overloaded to call C<complementary_type>.
  
  =item *
  
  The C<< | >> operator is overloaded to build a union of two type constraints.
  See L<Type::Tiny::Union>.
  
  =item *
  
  The C<< & >> operator is overloaded to build the intersection of two type
  constraints. See L<Type::Tiny::Intersection>.
  
  =item *
  
  The C<< + >> operator is overloaded to call C<plus_coercions> or
  C<plus_fallback_coercions> as appropriate.
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< Type::Tiny::SUPPORT_SMARTMATCH >>
  
  Indicates whether the smart match overload is supported on your
  version of Perl.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< $Type::Tiny::DD >>
  
  This in undef by default but may be set to a coderef that Type::Tiny
  and related modules will use to dump data structures in things like
  error messages.
  
  Otherwise Type::Tiny uses it's own routine to dump data structures.
  C<< $DD >> may then be set to a number to limit the lengths of the
  dumps. (Default limit is 72.)
  
  This is a package variable (rather than get/set class methods) to allow
  for easy localization.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>, L<Type::API>.
  
  L<Type::Library>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>, L<Type::Tiny::Intersection>.
  
  L<Moose::Meta::TypeConstraint>,
  L<Mouse::Meta::TypeConstraint>.
  
  L<Type::Params>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 THANKS
  
  Thanks to Matt S Trout for advice on L<Moo> integration.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY

$fatpacked{"Type/Tiny/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_CLASS';
  package Type::Tiny::Class;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::Class::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Class::VERSION   = '0.034';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	return $proto->class->new(@_) if blessed $proto; # DWIM
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Class type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Class type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Class type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply class name" unless exists $opts{class};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub class       { $_[0]{class} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self  = shift;
  	my $class = $self->class;
  	return sub { blessed($_) and $_->isa($class) };
  }
  
  sub _build_inlined
  {
  	my $self  = shift;
  	my $class = $self->class;
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and $var->isa(q[$class])};
  	};
  }
  
  sub _build_default_message
  {
  	no warnings 'uninitialized';
  	my $self = shift;
  	my $c = $self->class;
  	return sub { sprintf '%s did not pass type constraint (not isa %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not isa %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Class;
  	return "Moose::Meta::TypeConstraint::Class"->new(%opts, class => $self->class);
  }
  
  sub plus_constructors
  {
  	my $self = shift;
  	
  	unless (@_)
  	{
  		require Types::Standard;
  		push @_, Types::Standard::HashRef(), "new";
  	}
  	
  	require B;
  	require Types::TypeTiny;
  	
  	my $class = B::perlstring($self->class);
  	
  	my @r;
  	while (@_)
  	{
  		my $source = shift;
  		Types::TypeTiny::TypeTiny->check($source)
  			or _croak "Expected type constraint; got $source";
  		
  		my $constructor = shift;
  		Types::TypeTiny::StringLike->check($constructor)
  			or _croak "Expected string; got $constructor";
  		
  		push @r, $source, sprintf('%s->%s($_)', $class, $constructor);
  	}
  	
  	return $self->plus_coercions(\@r);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self  = shift;
  	my $class = $self->class;
  	
  	my @isa = grep $class->isa($_), do { no strict "refs"; no warnings; @{"$class\::ISA"} };
  	
  	if (@isa == 0)
  	{
  		require Types::Standard;
  		return Types::Standard::Object();
  	}
  	
  	if (@isa == 1)
  	{
  		return ref($self)->new(class => $isa[0])
  	}
  	
  	require Type::Tiny::Intersection;
  	"Type::Tiny::Intersection"->new(
  		type_constraints => [ map ref($self)->new(class => $_), @isa ],
  	);
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	my @isa;
  	if (eval { require mro })
  	{
  		@isa = @{ mro::get_linear_isa(ref $value) };
  	}
  	else
  	{
  		require Class::ISA;
  		@isa = Class::ISA::super_path(ref $value);
  	}
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	require Type::Utils;
  	return [
  		sprintf('"%s" requires that the reference isa %s', $self, $self->class),
  		sprintf('The reference%s isa %s', $display_var, Type::Utils::english_list(@isa)),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Class - type constraints based on the "isa" method
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->isa("Some::Class") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Constructor
  
  =over
  
  =item C<new>
  
  When the constructor is called on an I<instance> of Type::Tiny::Class, it
  passes the call through to the constructor of the class for the constraint.
  So for example:
  
     my $type = Type::Tiny::Class->new(class => "Foo::Bar");
     my $obj  = $type->new(hello => "World");
     say ref($obj);   # prints "Foo::Bar"
  
  This little bit of DWIM was borrowed from L<MooseX::Types::TypeDecorator>,
  but Type::Tiny doesn't take the idea quite as far.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<class>
  
  The class for the constraint.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is automatically calculated, and cannot be passed to the constructor.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< plus_constructors($source, $method_name) >>
  
  Much like C<plus_coercions> but adds coercions that go via a constructor.
  (In fact, this is implemented as a wrapper for C<plus_coercions>.)
  
  Example:
  
     package MyApp::Minion;
     
     use Moose; extends "MyApp::Person";
     
     use Types::Standard qw( HashRef Str );
     use Type::Utils qw( class_type );
     
     my $Person = class_type({ class => "MyApp::Person" });
     
     has boss => (
        is     => "ro",
        isa    => $Person->plus_constructors(
           HashRef,     "new",
           Str,         "_new_from_name",
        ),
        coerce => 1,
     );
     
     package main;
     
     MyApp::Minion->new(
        ...,
        boss => "Bob",  ## via MyApp::Person->_new_from_name
     );
     
     MyApp::Minion->new(
        ...,
        boss => { name => "Bob" },  ## via MyApp::Person->new
     );
  
  Because coercing C<HashRef> via constructor is a common desire, if
  you call C<plus_constructors> with no arguments at all, this is the
  default.
  
     $classtype->plus_constructors(Types::Standard::HashRef, "new")
     $classtype->plus_constructors()  ## identical to above
  
  This is handy for Moose/Mouse/Moo-based classes.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Class>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_CLASS

$fatpacked{"Type/Tiny/Duck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_DUCK';
  package Type::Tiny::Duck;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Duck::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Duck::VERSION   = '0.034';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Duck type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Duck type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Duck type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of methods" unless exists $opts{methods};
  	
  	$opts{methods} = [$opts{methods}] unless ref $opts{methods};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub methods     { $_[0]{methods} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self    = shift;
  	my @methods = @{$self->methods};
  	return sub { blessed($_[0]) and not grep(!$_[0]->can($_), @methods) };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my @methods = @{$self->methods};
  	sub {
  		my $var = $_[1];
  		local $" = q{ };
  		qq{ Scalar::Util::blessed($var) and not grep(!$var->can(\$_), qw/@methods/) };
  	};
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	require Moose::Meta::TypeConstraint::DuckType;
  	return "Moose::Meta::TypeConstraint::DuckType"->new(%opts, methods => $self->methods);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the reference can %s',
  			$self,
  			Type::Utils::english_list(map qq["$_"], @{$self->methods}),
  		),
  		map  sprintf('The reference cannot "%s"', $_),
  		grep !$value->can($_),
  		@{$self->methods}
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Duck - type constraints based on the "can" method
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->can("method") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<methods>
  
  An arrayref of method names.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::DuckType>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_DUCK

$fatpacked{"Type/Tiny/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ENUM';
  package Type::Tiny::Enum;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Enum::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Enum::VERSION   = '0.034';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => 'values';
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new
  {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Enum type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Enum type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Enum type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of values" unless exists $opts{values};
  	
  	my %tmp =
  		map { $_ => 1 }
  		@{ ref $opts{values} eq "ARRAY" ? $opts{values} : [$opts{values}] };
  	$opts{values} = [sort keys %tmp];
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub values      { $_[0]{values} }
  sub constraint  { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	sprintf("Enum[%s]", join q[,], @$self);
  }
  
  sub _build_constraint
  {
  	my $self = shift;
  	my $regexp = join "|", map quotemeta, @$self;
  	return sub { defined and m{\A(?:$regexp)\z} };
  }
  
  sub can_be_inlined
  {
  	!!1;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	my $regexp = join "|", map quotemeta, @$self;
  	$_[0] eq '$_'
  		? "(defined and !ref and m{\\A(?:$regexp)\\z})"
  		: "(defined($_[0]) and !ref($_[0]) and $_[0] =~ m{\\A(?:$regexp)\\z})";
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Enum;
  	return "Moose::Meta::TypeConstraint::Enum"->new(%opts, values => $self->values);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Str();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	!defined($value) ? [
  		sprintf(
  			'"%s" requires that the value is defined',
  			$self,
  		),
  	] :
  	@$self < 13 ? [
  		sprintf(
  			'"%s" requires that the value is equal to %s',
  			$self,
  			Type::Utils::english_list(\"or", map B::perlstring($_), @$self),
  		),
  	] :
  	[
  		sprintf(
  			'"%s" requires that the value is one of an enumerated list of strings',
  			$self,
  		),
  	];
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Enum - string enum type constraints
  
  =head1 DESCRIPTION
  
  Enum type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<values>
  
  Arrayref of allowable value strings. Non-string values (e.g. objects with
  overloading) will be stringified in the constructor.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Str, and cannot be passed to the
  constructor.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<values>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Enum>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ENUM

$fatpacked{"Type/Tiny/Intersection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_INTERSECTION';
  package Type::Tiny::Intersection;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Intersection::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Intersection::VERSION   = '0.034';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Intersection type constraints cannot have a parent constraint" if exists $opts{parent};
  	_croak "Intersection type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Intersection type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[&], @$self;
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) || return for @checks;
  		return !!1;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	sprintf '(%s)', join " and ", map $_->inline_check($_[0]), @$self;
  }
  
  sub has_parent
  {
  	!!@{ $_[0]{type_constraints} };
  }
  
  sub parent
  {
  	$_[0]{type_constraints}[0];
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	for my $type (@$self)
  	{
  		my $deep = $type->validate_explain($value, $varname);
  		return [
  			sprintf(
  				'"%s" requires that the value pass %s',
  				$self,
  				Type::Utils::english_list(map qq["$_"], @$self),
  			),
  			@$deep,
  		] if $deep;
  	}
  	
  	return ["Mysterious!"];
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Intersection - intersection type constraints
  
  =head1 DESCRIPTION
  
  Intersection type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the
  intersection is itself an intersection type constraint, this is "exploded"
  into the new intersection.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  (Technically any of the types in the intersection could be treated as a
  parent type; we choose the first arbitrarily.)
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<MooseX::Meta::TypeConstraint::Intersection>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_INTERSECTION

$fatpacked{"Type/Tiny/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ROLE';
  package Type::Tiny::Role;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Role::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Role::VERSION   = '0.034';
  }
  
  use Scalar::Util qw< blessed weaken >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  my %cache;
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Role type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Role type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Role type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply role name" unless exists $opts{role};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub role        { $_[0]{role} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self = shift;
  	my $role = $self->role;
  	return sub { blessed($_) and do { my $method = $_->can('DOES')||$_->can('isa'); $_->$method($role) } };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my $role = $self->role;
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and do { my \$method = $var->can('DOES')||$var->can('isa'); $var->\$method(q[$role]) }};
  	};
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	my $c = $self->role;
  	return sub { sprintf '%s did not pass type constraint (not DOES %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not DOES %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	return ["Reference provides no DOES method to check roles"] unless $value->can('DOES');
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	return [
  		sprintf('"%s" requires that the reference does %s', $self, $self->role),
  		sprintf("The reference%s doesn't %s", $display_var, $self->role),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Role - type constraints based on the "DOES" method
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->DOES("Some::Role") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<role>
  
  The role for the constraint.
  
  Note that this package doesn't subscribe to any particular flavour of roles
  (L<Moose::Role>, L<Mouse::Role>, L<Moo::Role>, L<Role::Tiny>, etc). It simply
  trusts the object's C<DOES> method (see L<UNIVERSAL>).
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Role>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ROLE

$fatpacked{"Type/Tiny/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_UNION';
  package Type::Tiny::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Union::VERSION   = '0.034';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Union type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Union type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Union type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	my $self = $proto->SUPER::new(%opts);
  	$self->coercion if grep $_->has_coercion, @$self;
  	return $self;
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[|], @$self;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion::Union;
  	my $self = shift;
  	return "Type::Coercion::Union"->new(type_constraint => $self);
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) && return !!1 for @checks;
  		return;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	sprintf '(%s)', join " or ", map $_->inline_check($_[0]), @$self;
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	my @tc = map $_->moose_type, @{$self->type_constraints};
  	
  	require Moose::Meta::TypeConstraint::Union;
  	return "Moose::Meta::TypeConstraint::Union"->new(%opts, type_constraints => \@tc);
  }
  
  sub has_parent
  {
  	defined(shift->parent);
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self = shift;
  	my ($first, @rest) = @$self;
  	
  	for my $parent ($first, $first->parents)
  	{
  		return $parent unless grep !$_->is_a_type_of($parent), @rest;
  	}
  	
  	return;
  }
  
  sub find_type_for
  {
  	my @types = @{+shift};
  	for my $type (@types)
  	{
  		return $type if $type->check(@_);
  	}
  	return;
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the value pass %s',
  			$self,
  			Type::Utils::english_list(\"or", map qq["$_"], @$self),
  		),
  		map {
  			$_->get_message($value),
  			map("    $_", @{ $_->validate_explain($value) || []}),
  		} @$self
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Union - union type constraints
  
  =head1 DESCRIPTION
  
  Union type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the union
  is itself a union type constraint, this is "exploded" into the new union.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  =item C<coercion>
  
  Will typically be a L<Type::Coercion::Union>.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< find_type_for($value) >>
  
  Returns the first individual type constraint in the union which
  C<< $value >> passes.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_UNION

$fatpacked{"Type/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_UTILS';
  package Type::Utils;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Utils::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Utils::VERSION   = '0.034';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use Scalar::Util qw< blessed >;
  use Type::Library;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny HashLike StringLike CodeLike >;
  
  our @EXPORT = qw<
  	declare as where message inline_as
  	class_type role_type duck_type union intersection enum
  	coerce from via
  	declare_coercion to_type
  >;
  our @EXPORT_OK = (
  	@EXPORT,
  	qw<
  		extends type subtype
  		match_on_type compile_match_on_type
  		dwim_type english_list
  	>,
  );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  sub extends
  {
  	_croak "Not a type library" unless caller->isa("Type::Library");
  	my $caller = caller->meta;
  	
  	foreach my $lib (@_)
  	{
  		eval "use $lib; 1" or _croak "Could not load library '$lib': $@";
  		
  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$caller->add_type( $lib->get_type($_) )
  				for sort $lib->meta->type_names;
  			$caller->add_coercion( $lib->get_coercion($_) )
  				for sort $lib->meta->coercion_names;
  		}
  		elsif ($lib->isa('MooseX::Types::Base'))
  		{
  			require Moose::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $moose = Moose::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($moose);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $moose->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		elsif ($lib->isa('MouseX::Types::Base'))
  		{
  			require Mouse::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $mouse = Mouse::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($mouse);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $mouse->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		else
  		{
  			_croak("'$lib' is not a type constraint library");
  		}
  	}
  }
  
  sub declare
  {
  	my %opts;
  	if (@_ % 2 == 0)
  	{
  		%opts = @_;
  	}
  	else
  	{
  		(my($name), %opts) = @_;
  		_croak "Cannot provide two names for type" if exists $opts{name};
  		$opts{name} = $name;
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	if (defined $opts{parent})
  	{
  		$opts{parent} = to_TypeTiny($opts{parent});
  		
  		unless (TypeTiny->check($opts{parent}))
  		{
  			$caller->isa("Type::Library")
  				or _croak("Parent type cannot be a %s", ref($opts{parent})||'non-reference scalar');
  			$opts{parent} = $caller->meta->get_type($opts{parent})
  				or _croak("Could not find parent type");
  		}
  	}
  	
  	my $type;
  	if (defined $opts{parent})
  	{
  		$type = delete($opts{parent})->create_child_type(%opts);
  	}
  	else
  	{
  		my $bless = delete($opts{bless}) || "Type::Tiny";
  		eval "require $bless";
  		$type = $bless->new(%opts);
  	}
  	
  	if ($caller->isa("Type::Library"))
  	{
  		$caller->meta->add_type($type) unless $type->is_anon;
  	}
  	
  	return $type;
  }
  
  *subtype = \&declare;
  *type = \&declare;
  
  sub as (@)
  {
  	parent => @_;
  }
  
  sub where (&;@)
  {
  	constraint => @_;
  }
  
  sub message (&;@)
  {
  	message => @_;
  }
  
  sub inline_as (&;@)
  {
  	inlined => @_;
  }
  
  sub class_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ +shift };
  	
  	if (defined $name)
  	{
  		$opts{name}  = $name unless exists $opts{name};
  		$opts{class} = $name unless exists $opts{class};
  	}
  	
  	$opts{bless} = "Type::Tiny::Class";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub role_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ +shift };
  	
  	if (defined $name)
  	{
  		$opts{name}  = $name unless exists $opts{name};
  		$opts{role}  = $name unless exists $opts{role};
  	}
  	
  	$opts{bless} = "Type::Tiny::Role";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub duck_type
  {
  	my $name    = ref($_[0]) ? undef : shift;
  	my @methods = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{methods} = \@methods;
  	
  	$opts{bless} = "Type::Tiny::Duck";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub enum
  {
  	my $name   = ref($_[0]) ? undef : shift;
  	my @values = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{values} = \@values;
  	
  	$opts{bless} = "Type::Tiny::Enum";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub union
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Union";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub intersection
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ +shift };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Intersection";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub declare_coercion
  {
  	my %opts;
  	$opts{name} = shift if !ref($_[0]);
  	
  	while (HashLike->check($_[0]) and not TypeTiny->check($_[0]))
  	{
  		%opts = (%opts, %{+shift});
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	my $bless = delete($opts{bless}) || "Type::Coercion";
  	eval "require $bless";
  	my $c = $bless->new(%opts);
  	
  	my @C;
  	
  	if ($caller->isa("Type::Library"))
  	{
  		my $meta = $caller->meta;
  		$meta->add_coercion($c) unless $c->is_anon;
  		while (@_)
  		{
  			push @C, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @C, shift;
  		}
  	}
  	
  	$c->add_type_coercions(@C);
  	
  	return $c->freeze;
  }
  
  sub coerce
  {
  	if ((scalar caller)->isa("Type::Library"))
  	{
  		my $meta = (scalar caller)->meta;
  		my ($type) = map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  		my @opts;
  		while (@_)
  		{
  			push @opts, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @opts, shift;
  		}
  		return $type->coercion->add_type_coercions(@opts);
  	}
  	
  	my ($type, @opts) = @_;
  	$type = to_TypeTiny($type);
  	return $type->coercion->add_type_coercions(@opts);
  }
  
  sub from (@)
  {
  	return @_;
  }
  
  sub to_type (@)
  {
  	my $type = shift;
  	unless (TypeTiny->check($type))
  	{
  		caller->isa("Type::Library")
  			or _croak "Target type cannot be a string";
  		$type = caller->meta->get_type($type)
  			or _croak "Could not find target type";
  	}
  	return +{ type_constraint => $type }, @_;
  }
  
  sub via (&;@)
  {
  	return @_;
  }
  
  sub match_on_type
  {
  	my $value = shift;
  	
  	while (@_)
  	{
  		my ($type, $code);
  		if (@_ == 1)
  		{
  			require Types::Standard;
  			($type, $code) = (Types::Standard::Any(), shift);
  		}
  		else
  		{
  			($type, $code) = splice(@_, 0, 2);
  			TypeTiny->($type);
  		}
  		
  		$type->check($value) or next;
  		
  		if (StringLike->check($code))
  		{
  			local $_ = $value;
  			if (wantarray) {
  				my @r = eval "$code";
  				die $@ if $@;
  				return @r;
  			}
  			if (defined wantarray) {
  				my $r = eval "$code";
  				die $@ if $@;
  				return $r;
  			}
  			eval "$code";
  			die $@ if $@;
  			return;
  		}
  		else
  		{
  			CodeLike->($code);
  			local $_ = $value;
  			return $code->($value);
  		}
  	}
  	
  	_croak("No cases matched for %s", Type::Tiny::_dd($value));
  }
  
  sub compile_match_on_type
  {
  	my @code = 'sub { local $_ = $_[0]; ';
  	my @checks;
  	my @actions;
  	
  	my $els = '';
  	
  	while (@_)
  	{
  		my ($type, $code);
  		if (@_ == 1)
  		{
  			require Types::Standard;
  			($type, $code) = (Types::Standard::Any(), shift);
  		}
  		else
  		{
  			($type, $code) = splice(@_, 0, 2);
  			TypeTiny->($type);
  		}
  		
  		if ($type->can_be_inlined)
  		{
  			push @code, sprintf('%sif (%s)', $els, $type->inline_check('$_'));
  		}
  		else
  		{
  			push @checks, $type;
  			push @code, sprintf('%sif ($checks[%d]->check($_))', $els, $#checks);
  		}
  		
  		$els = 'els';
  		
  		if (StringLike->check($code))
  		{
  			push @code, sprintf('  { %s }', $code);
  		}
  		else
  		{
  			CodeLike->($code);
  			push @actions, $code;
  			push @code, sprintf('  { $actions[%d]->(@_) }', $#actions);
  		}
  	}
  	
  	push @code, 'else', '  { Type::Util::_croak("No cases matched for %s", Type::Tiny::_dd($_[0])) }';
  	
  	push @code, '}';  # /sub
  	
  	require Eval::TypeTiny;
  	return Eval::TypeTiny::eval_closure(
  		source      => \@code,
  		environment => {
  			'@actions' => \@actions,
  			'@checks'  => \@checks,
  		},
  	);
  }
  
  {
  	package #hide
  	Type::Registry::DWIM;
  	
  	our @ISA = qw(Type::Registry);
  	
  	sub simple_lookup
  	{
  		my $self = shift;
  		my $r;
  		
  		# If the lookup is chained to a class, then the class' own
  		# type registry gets first refusal.
  		#
  		if (defined $self->{"~~chained"})
  		{
  			my $chained = "Type::Registry"->for_class($self->{"~~chained"});
  			$r = eval { $chained->simple_lookup(@_) } unless $self == $chained;
  			return $r if defined $r;
  		}
  		
  		# Fall back to types in Types::Standard.
  		require Types::Standard;
  		return 'Types::Standard'->get_type($_[0]) if 'Types::Standard'->has_type($_[0]);
  		
  		# Only continue any further if we've been called from Type::Parser.
  		return unless $_[1];
  		
  		# If Moose is loaded...
  		if ($INC{'Moose.pm'})
  		{
  			require Moose::Util::TypeConstraints;
  			require Types::TypeTiny;
  			$r = Moose::Util::TypeConstraints::find_type_constraint($_[0]);
  			return Types::TypeTiny::to_TypeTiny($r) if defined $r;
  		}
  		
  		# If Mouse is loaded...
  		if ($INC{'Mouse.pm'})
  		{
  			require Mouse::Util::TypeConstraints;
  			require Types::TypeTiny;
  			$r = Mouse::Util::TypeConstraints::find_type_constraint($_[0]);
  			return Types::TypeTiny::to_TypeTiny($r) if defined $r;
  		}
  		
  		return unless $_[0] =~ /^\s*(\w+(::\w+)*)\s*$/sm;
  		return unless defined $self->{"~~assume"};
  		
  		# Lastly, if it looks like a class/role name, assume it's
  		# supposed to be a class/role type.
  		#
  		
  		if ($self->{"~~assume"} eq "Type::Tiny::Class")
  		{
  			require Type::Tiny::Class;
  			return "Type::Tiny::Class"->new(class => $_[0]);
  		}
  		
  		if ($self->{"~~assume"} eq "Type::Tiny::Role")
  		{
  			require Type::Tiny::Role;
  			return "Type::Tiny::Role"->new(role => $_[0]);
  		}
  		
  		die;
  	}
  }
  
  our $dwimmer;
  sub dwim_type
  {
  	my ($string, %opts) = @_;
  	$opts{for} = caller unless defined $opts{for};
  	
  	$dwimmer ||= do {
  		require Type::Registry;
  		'Type::Registry::DWIM'->new;
  	};
  	
  	local $dwimmer->{'~~chained'} = $opts{for};
  	local $dwimmer->{'~~assume'}  = $opts{does} ? 'Type::Tiny::Role' : 'Type::Tiny::Class';
  	
  	$dwimmer->lookup($string);
  }
  
  sub english_list
  {
  	my $conjunction = ref($_[0]) eq 'SCALAR' ? ${+shift} : 'and';
  	my @items = sort @_;
  	
  	return $items[0] if @items == 1;
  	return "$items[0] $conjunction $items[1]" if @items == 2;
  	
  	my $tail = pop @items;
  	join(', ', @items, "$conjunction $tail");
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smush smushed
  
  =head1 NAME
  
  Type::Utils - utility functions to make defining and using type constraints a little easier
  
  =head1 SYNOPSIS
  
     package Types::Mine;
     
     use Type::Library -base;
     use Type::Utils -all;
     
     BEGIN { extends "Types::Standard" };
     
     declare "AllCaps",
        as "Str",
        where { uc($_) eq $_ },
        inline_as { my $varname = $_[1]; "uc($varname) eq $varname" };
     
     coerce "AllCaps",
        from "Str", via { uc($_) };
  
  =head1 DESCRIPTION
  
  This module provides utility functions to make defining and using type
  constraints a little easier. 
  
  =head2 Type declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< declare $name, %options >>
  
  =item C<< declare %options >>
  
  Declare a named or anonymous type constraint. Use C<as> and C<where> to
  specify the parent type (if any) and (possibly) refine its definition.
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
     my $EvenInt = declare as Int, where { $_ % 2 == 0 };
  
  B<< NOTE: >>
  If the caller package inherits from L<Type::Library> then any non-anonymous
  types declared in the package will be automatically installed into the
  library.
  
  Hidden gem: if you're inheriting from a type constraint that includes some
  coercions, you can include C<< coercion => 1 >> in the C<< %options >> hash
  to inherit the coercions.
  
  =item C<< subtype $name, %options >>
  
  =item C<< subtype %options >>
  
  Declare a named or anonymous type constraint which is descended from an
  existing type constraint. Use C<as> and C<where> to specify the parent
  type and refine its definition.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< type $name, %options >>
  
  =item C<< type %options >>
  
  Declare a named or anonymous type constraint which is not descended from
  an existing type constraint. Use C<where> to provide a coderef that
  constrains values.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< as $parent >>
  
  Used with C<declare> to specify a parent type constraint:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  =item C<< where { BLOCK } >>
  
  Used with C<declare> to provide the constraint coderef:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  The coderef operates on C<< $_ >>, which is the value being tested.
  
  =item C<< message { BLOCK } >>
  
  Generate a custom error message when a value fails validation.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        message {
           Int->validate($_) or "$_ is not divisible by two";
        };
  
  Without a custom message, the messages generated by Type::Tiny are along
  the lines of I<< Value "33" did not pass type constraint "EvenInt" >>,
  which is usually reasonable.
  
  =item C<< inline_as { BLOCK } >>
  
  Generate a string of Perl code that can be used to inline the type check into
  other functions. If your type check is being used within a L<Moose> or L<Moo>
  constructor or accessor methods, or used by L<Type::Params>, this can lead to
  significant performance improvements.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           my ($constraint, $varname) = @_;
           my $perlcode = 
              $constraint->parent->inline_check($varname)
              . "&& ($varname % 2 == 0)";
           return $perlcode;
        };
     
     warn EvenInt->inline_check('$xxx');  # demonstration
  
  B<Experimental:> your C<inline_as> block can return a list, in which case
  these will be smushed together with "&&". The first item on the list may
  be undef, in which case the undef will be replaced by the inlined parent
  type constraint. (And will throw an exception if there is no parent.)
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           return (undef, "($_ % 2 == 0)");
        };
  
  Returning a list like this is considered experimental, is not tested very
  much, and I offer no guarantees that it will necessarily work with
  Moose/Mouse/Moo.
  
  =item C<< class_type $name, { class => $package, %options } >>
  
  =item C<< class_type { class => $package, %options } >>
  
  Shortcut for declaring a L<Type::Tiny::Class> type constraint.
  
  =item C<< role_type $name, { role => $package, %options } >>
  
  =item C<< role_type { role => $package, %options } >>
  
  Shortcut for declaring a L<Type::Tiny::Role> type constraint.
  
  =item C<< duck_type $name, \@methods >>
  
  =item C<< duck_type \@methods >>
  
  Shortcut for declaring a L<Type::Tiny::Duck> type constraint.
  
  =item C<< union $name, \@constraints >>
  
  =item C<< union \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Union> type constraint.
  
  =item C<< enum $name, \@values >>
  
  =item C<< enum \@values >>
  
  Shortcut for declaring a L<Type::Tiny::Enum> type constraint.
  
  =item C<< intersection $name, \@constraints >>
  
  =item C<< intersection \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Intersection> type constraint.
  
  =back
  
  =head2 Coercion declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< coerce $target, @coercions >>
  
  Add coercions to the target type constraint. The list of coercions is a
  list of type constraint, conversion code pairs. Conversion code can be
  either a string of Perl code or a coderef; in either case the value to
  be converted is C<< $_ >>.
  
  =item C<< from $source >>
  
  Sugar to specify a type constraint in a list of coercions:
  
     coerce EvenInt, from Int, via { $_ * 2 };  # As a coderef...
     coerce EvenInt, from Int, q { $_ * 2 };    # or as a string!
  
  =item C<< via { BLOCK } >>
  
  Sugar to specify a coderef in a list of coercions.
  
  =item C<< declare_coercion $name, \%opts, $type1, $code1, ... >>
  
  =item C<< declare_coercion \%opts, $type1, $code1, ... >>
  
  Declares a coercion that is not explicitly attached to any type in the
  library. For example:
  
     declare_coercion "ArrayRefFromAny", from "Any", via { [$_] };
  
  This coercion will be exportable from the library as a L<Type::Coercion>
  object, but the ArrayRef type exported by the library won't automatically
  use it.
  
  Coercions declared this way are immutable (frozen).
  
  =item C<< to_type $type >>
  
  Used with C<declare_coercion> to declare the target type constraint for
  a coercion, but still without explicitly attaching the coercion to the
  type constraint:
  
     declare_coercion "ArrayRefFromAny",
        to_type "ArrayRef",
        from "Any", via { [$_] };
  
  You should pretty much always use this when declaring an unattached
  coercion because it's exceedingly useful for a type coercion to know what
  it will coerce to - this allows it to skip coercion when no coercion is
  needed (e.g. avoiding coercing C<< [] >> to C<< [ [] ] >>) and allows
  C<assert_coerce> to work properly.
  
  =back
  
  =head2 Type library management
  
  =over
  
  =item C<< extends @libraries >>
  
  Indicates that this type library extends other type libraries, importing
  their type constraints.
  
  Should usually be executed in a C<< BEGIN >> block.
  
  This is not exported by default because it's not fun to export it to Moo,
  Moose or Mouse classes! C<< use Type::Utils -all >> can be used to import
  it into your type library.
  
  =back
  
  =head2 Other
  
  =over
  
  =item C<< match_on_type $value => ($type => \&action, ..., \&default?) >>
  
  Something like a C<switch>/C<case> or C<given>/C<when> construct. Dispatches
  along different code paths depending on the type of the incoming value.
  Example blatantly stolen from the Moose documentation:
  
     sub to_json
     {
        my $value = shift;
        
        return match_on_type $value => (
           HashRef() => sub {
              my $hash = shift;
              '{ '
                 . (
                 join ", " =>
                 map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                 sort keys %$hash
              ) . ' }';
           },
           ArrayRef() => sub {
              my $array = shift;
              '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
           },
           Num()   => q {$_},
           Str()   => q { '"' . $_ . '"' },
           Undef() => q {'null'},
           => sub { die "$_ is not acceptable json type" },
        );
     }
  
  Note that unlike Moose, code can be specified as a string instead of a
  coderef. (e.g. for C<Num>, C<Str> and C<Undef> above.)
  
  For improved performance, try C<compile_match_on_type>.
  
  This function is not exported by default.
  
  =item C<< my $coderef = compile_match_on_type($type => \&action, ..., \&default?) >>
  
  Compile a C<match_on_type> block into a coderef. The following JSON
  converter is about two orders of magnitude faster than the previous
  example:
  
     sub to_json;
     *to_json = compile_match_on_type(
        HashRef() => sub {
           my $hash = shift;
           '{ '
              . (
              join ", " =>
              map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
              sort keys %$hash
           ) . ' }';
        },
        ArrayRef() => sub {
           my $array = shift;
           '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
        },
        Num()   => q {$_},
        Str()   => q { '"' . $_ . '"' },
        Undef() => q {'null'},
        => sub { die "$_ is not acceptable json type" },
     );
  
  Remember to store the coderef somewhere fairly permanent so that you
  don't compile it over and over. C<state> variables (in Perl >= 5.10)
  are good for this. (Same sort of idea as L<Type::Params>.)
  
  This function is not exported by default.
  
  =item C<< dwim_type($string, %options) >>
  
  Given a string like "ArrayRef[Int|CodeRef]", turns it into a type constraint
  object, hopefully doing what you mean.
  
  It uses the syntax of L<Type::Parser>. Firstly the L<Type::Registry>
  for the caller package is consulted; if that doesn't have a match,
  L<Types::Standard> is consulted for type constraint names; and if
  there's still no match, then if a type constraint looks like a class
  name, a new L<Type::Tiny::Class> object is created for it.
  
  Somewhere along the way, it also checks Moose/Mouse's type constraint
  registries if they are loaded.
  
  You can specify an alternative for the caller using the C<for> option.
  If you'd rather create a L<Type::Tiny::Role> object, set the C<does>
  option to true.
  
     # An arrayref of objects, each of which must do role Foo.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);
     
     Type::Registry->for_me->add_types("-Standard");
     Type::Registry->for_me->alias_type("Int" => "Foo");
     
     # An arrayref of integers.
     my $type = dwim_type("ArrayRef[Foo]", does => 1);
  
  While it's probably better overall to use the proper L<Type::Registry>
  interface for resolving type constraint strings, this function often does
  what you want.
  
  It should never die if it fails to find a type constraint (but may die
  if the type constraint string is syntactically malformed), preferring to
  return undef.
  
  This function is not exported by default.
  
  =item C<< english_list(\$conjunction, @items) >>
  
  Joins the items with commas, placing a conjunction before the final item.
  The conjunction is optional, defaulting to "and".
  
     english_list(qw/foo bar baz/);       # "foo, bar, and baz"
     english_list(\"or", qw/quux quuux/); # "quux or quuux"
  
  This function is not exported by default.
  
  =back
  
  =head1 EXPORT
  
  By default, all of the functions documented above are exported, except
  C<subtype> and C<type> (prefer C<declare> instead), C<extends>, C<dwim_type>,
  and C<match_on_type>/C<compile_match_on_type>.
  
  This module uses L<Exporter::Tiny>; see the documentation of that module
  for tips and tricks importing from Type::Utils.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_UTILS

$fatpacked{"Types/Common/Numeric.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_NUMERIC';
  package Types::Common::Numeric;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::Numeric::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::Numeric::VERSION   = '0.034';
  }
  
  use Type::Library -base, -declare => qw(
  	PositiveNum PositiveOrZeroNum
  	PositiveInt PositiveOrZeroInt
  	NegativeNum NegativeOrZeroNum
  	NegativeInt NegativeOrZeroInt
  	SingleDigit
  );
  
  use Types::Standard qw( Num Int );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => 'PositiveNum',
  	parent     => Num,
  	constraint => sub { $_ > 0 },
  	inlined    => sub { undef, qq($_ > 0) },
  	message    => sub { "Must be a positive number" },
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ >= 0) },
  	message    => sub { "Must be a number greater than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'PositiveInt',
  	parent     => Int,
  	constraint => sub { $_ > 0 },
  	inlined    => sub { undef, qq($_ > 0) },
  	message    => sub { "Must be a positive integer" },
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ >= 0) },
  	message    => sub { "Must be an integer greater than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'NegativeNum',
  	parent     => Num,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative number" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ <= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be a number less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'NegativeInt',
  	parent     => Int,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative integer" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be an integer less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'SingleDigit',
  	parent     => Int,
  	constraint => sub { $_ >= -9 and $_ <= 9 },
  	inlined    => sub { undef, qq($_ >= -9), qq($_ <= 9) },
  	message    => sub { "Must be a single digit" },
  );
   
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::Numeric - drop-in replacement for MooseX::Types::Common::Numeric
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::Numeric>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::Numeric>.
  
  =over
  
  =item C<PositiveNum>
  
  =item C<PositiveOrZeroNum>
  
  =item C<PositiveInt>
  
  =item C<PositiveOrZeroInt>
  
  =item C<NegativeNum>
  
  =item C<NegativeOrZeroNum>
  
  =item C<NegativeInt>
  
  =item C<NegativeOrZeroInt>
  
  =item C<SingleDigit>
  
  =back
  
  C<SingleDigit> interestingly accepts the numbers -9 to -1; not
  just 0 to 9. 
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::String>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_NUMERIC

$fatpacked{"Types/Common/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_STRING';
  package Types::Common::String;
  
  use 5.006001;
  use strict;
  use warnings;
  use utf8;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::String::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::String::VERSION   = '0.034';
  }
  
  use Type::Library -base, -declare => qw(
  	SimpleStr
  	NonEmptySimpleStr
  	NumericCode
  	LowerCaseSimpleStr
  	UpperCaseSimpleStr
  	Password
  	StrongPassword
  	NonEmptyStr
  	LowerCaseStr
  	UpperCaseStr
  );
  
  use Types::Standard qw( Str );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => SimpleStr,
  	parent     => Str,
  	constraint => sub { length($_) <= 255 and not /\n/ },
  	inlined    => sub { undef, qq(length($_) <= 255), qq($_ !~ /\\n/) },
  	message    => sub { "Must be a single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NonEmptySimpleStr,
  	parent     => SimpleStr,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub { undef, qq(length($_) > 0) },
  	message    => sub { "Must be a non-empty single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NumericCode,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { /^[0-9]+$/ },
  	inlined    => sub { SimpleStr->inline_check($_), qq($_ =~ m/^[0-9]+\$/) },
  	message    => sub {
  		'Must be a non-empty single line of no more than 255 chars that consists '
  			. 'of numeric characters only'
  	},
  );
  
  NumericCode->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ do { (my $code = $_) =~ s/[[:punct:]]//g; $code } ],
  );
  
  $meta->add_type(
  	name       => Password,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { length($_) > 3 },
  	inlined    => sub { SimpleStr->inline_check($_), qq(length($_) > 3) },
  	message    => sub { "Must be between 4 and 255 chars" },
  );
  
  $meta->add_type(
  	name       => StrongPassword,
  	parent     => Password,
  	constraint => sub { length($_) > 7 and /[^a-zA-Z]/ },
  	inlined    => sub { SimpleStr()->inline_check($_), qq(length($_) > 7), qq($_ =~ /[^a-zA-Z]/) },
  	message    => sub { "Must be between 8 and 255 chars, and contain a non-alpha char" },
  );
  
  $meta->add_type(
  	name       => NonEmptyStr,
  	parent     => Str,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub { undef, qq(length($_) > 0) },
  	message    => sub { "Must not be empty" },
  );
  
  $meta->add_type(
  	name       => LowerCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain upper case letters" },
  );
  
  LowerCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ uc($_) ],
  );
  
  $meta->add_type(
  	name       => LowerCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain pper case letters" },
  );
  
  LowerCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ uc($_) ],
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::String - drop-in replacement for MooseX::Types::Common::String
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::String>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::String>.
  
  =over
  
  =item C<SimpleStr>
  
  =item C<NonEmptySimpleStr>
  
  =item C<NumericCode>
  
  =item C<LowerCaseSimpleStr>
  
  =item C<UpperCaseSimpleStr>
  
  =item C<Password>
  
  =item C<StrongPassword>
  
  =item C<NonEmptyStr>
  
  =item C<LowerCaseStr>
  
  =item C<UpperCaseStr>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::Numeric>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_STRING

$fatpacked{"Types/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD';
  package Types::Standard;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	eval { require re };
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  	if ($] < 5.010) { require Devel::TypeTiny::Perl58Compat };
  }
  
  BEGIN {
  	$Types::Standard::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::VERSION   = '0.034';
  }
  
  use Type::Library -base;
  
  our @EXPORT_OK = qw( slurpy );
  
  use Scalar::Util qw( blessed looks_like_number );
  use Types::TypeTiny ();
  
  sub _is_class_loaded {
  	return !!0 if ref $_[0];
  	return !!0 if not $_[0];
  	my $stash = do { no strict 'refs'; \%{"$_[0]\::"} };
  	return !!1 if exists $stash->{'ISA'};
  	return !!1 if exists $stash->{'VERSION'};
  	foreach my $globref (values %$stash) {
  		return !!1 if *{$globref}{CODE};
  	}
  	return !!0;
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = __PACKAGE__->meta;
  
  sub Stringable (&)
  {
  	package #private
  	Types::Standard::_Stringable;
  	use overload q[""] => sub { $_[0]{text} ||= $_[0]{code}->() }, fallback => 1;
  	bless +{ code => $_[0] };
  }
  
  sub LazyLoad ($$)
  {
  	package #private
  	Types::Standard::LazyLoad;
  	use overload fallback => 1, q[&{}] => sub {
  		my ($typename, $function) = @{$_[0]};
  		my $type  = $meta->get_type($typename);
  		my $class = "Types::Standard::$typename";
  		eval "require $class; 1" or die($@);
  		# Majorly break encapsulation for Type::Tiny :-O
  		for my $key (keys %$type)
  		{
  			next unless ref($type->{$key}) eq __PACKAGE__;
  			my $f = $type->{$key}[1];
  			$type->{$key} = $class->can("__$f");
  		}
  		return $class->can("__$function");
  	};
  	bless \@_;
  }
  
  no warnings;
  
  BEGIN { *STRICTNUM = $ENV{PERL_TYPES_STANDARD_STRICTNUM} ? sub(){!!1} : sub(){!!0} };
  
  my $_any = $meta->add_type({
  	name       => "Any",
  	_is_core   => 1,
  	inlined    => sub { "!!1" },
  });
  
  my $_item = $meta->add_type({
  	name       => "Item",
  	_is_core   => 1,
  	inlined    => sub { "!!1" },
  	parent     => $_any,
  });
  
  $meta->add_type({
  	name       => "Bool",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint => sub { !defined $_ or $_ eq q() or $_ eq '0' or $_ eq '1' },
  	inlined    => sub { "!defined $_[1] or $_[1] eq q() or $_[1] eq '0' or $_[1] eq '1'" },
  });
  
  my $_undef = $meta->add_type({
  	name       => "Undef",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint => sub { !defined $_ },
  	inlined    => sub { "!defined($_[1])" },
  });
  
  my $_def = $meta->add_type({
  	name       => "Defined",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint => sub { defined $_ },
  	inlined    => sub { "defined($_[1])" },
  });
  
  my $_val = $meta->add_type({
  	name       => "Value",
  	_is_core   => 1,
  	parent     => $_def,
  	constraint => sub { not ref $_ },
  	inlined    => sub { "defined($_[1]) and not ref($_[1])" },
  });
  
  my $_str = $meta->add_type({
  	name       => "Str",
  	_is_core   => 1,
  	parent     => $_val,
  	constraint => sub { ref(\$_) eq 'SCALAR' or ref(\(my $val = $_)) eq 'SCALAR' },
  	inlined    => sub {
  		"defined($_[1]) and do { ref(\\$_[1]) eq 'SCALAR' or ref(\\(my \$val = $_[1])) eq 'SCALAR' }"
  	},
  });
  
  my $_laxnum = $meta->add_type({
  	name       => "LaxNum",
  	parent     => $_str,
  	constraint => sub { looks_like_number $_ },
  	inlined    => sub { "defined($_[1]) && !ref($_[1]) && Scalar::Util::looks_like_number($_[1])" },
  });
  
  my $_strictnum = $meta->add_type({
  	name       => "StrictNum",
  	parent     => $_str,
  	constraint => sub {
  		my $val = $_;
  		($val =~ /\A[+-]?[0-9]+\z/) ||
  		( $val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
  		(?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
  		[0-9]*                                #matches 0-9 zero or more times
  		(?:\.[0-9]+)?                         #matches optional .89 or nothing
  		(?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
  		\z/x );
  	},
  	inlined    => sub {
  		'my $val = '.$_[1].';'.
  		Value()->inline_check('$val')
  		.' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
  		. '$val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
  			(?=[0-9]|\.[0-9])                 # matches previous +- only if there is something like 3 or .3
  			[0-9]*                            # matches 0-9 zero or more times
  			(?:\.[0-9]+)?                     # matches optional .89 or nothing
  			(?:[Ee](?:[+-]?[0-9]+))?          # matches E1 or e1 or e-1 or e+1 etc
  		\z/x ); '
  	},
  });
  
  my $_num = $meta->add_type({
  	name       => "Num",
  	_is_core   => 1,
  	parent     => (STRICTNUM ? $_strictnum : $_laxnum),
  });
  
  $meta->add_type({
  	name       => "Int",
  	_is_core   => 1,
  	parent     => $_num,
  	constraint => sub { /\A-?[0-9]+\z/ },
  	inlined    => sub { "defined $_[1] and $_[1] =~ /\\A-?[0-9]+\\z/" },
  });
  
  my $_classn = $meta->add_type({
  	name       => "ClassName",
  	_is_core   => 1,
  	parent     => $_str,
  	constraint => sub { goto \&_is_class_loaded },
  	inlined    => sub { "Types::Standard::_is_class_loaded($_[1])" },
  });
  
  $meta->add_type({
  	name       => "RoleName",
  	parent     => $_classn,
  	constraint => sub { not $_->can("new") },
  	inlined    => sub { "Types::Standard::_is_class_loaded($_[1]) and not $_[1]\->can('new')" },
  });
  
  my $_ref = $meta->add_type({
  	name       => "Ref",
  	_is_core   => 1,
  	parent     => $_def,
  	constraint => sub { ref $_ },
  	inlined    => sub { "!!ref($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Ref') unless @_;
  		
  		my $reftype = shift;
  		Types::TypeTiny::StringLike->check($reftype)
  			or _croak("Parameter to Ref[`a] expected to be string; got $reftype");
  		
  		$reftype = "$reftype";
  		return sub {
  			ref($_[0]) and Scalar::Util::reftype($_[0]) eq $reftype;
  		}
  	},
  	inline_generator => sub
  	{
  		my $reftype = shift;
  		return sub {
  			my $v = $_[1];
  			"ref($v) and Scalar::Util::reftype($v) eq q($reftype)";
  		};
  	},
  	deep_explanation => sub {
  		require B;
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		return if $type->check($value);
  		my $reftype = Scalar::Util::reftype($value);
  		return [
  			sprintf('"%s" constrains reftype(%s) to be equal to %s', $type, $varname, B::perlstring($param)),
  			sprintf('reftype(%s) is %s', $varname, defined($reftype) ? B::perlstring($reftype) : "undef"),
  		];
  	},
  });
  
  $meta->add_type({
  	name       => "CodeRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "CODE" },
  	inlined    => sub { "ref($_[1]) eq 'CODE'" },
  });
  
  $meta->add_type({
  	name       => "RegexpRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref($_) && !!re::is_regexp($_) },
  	inlined    => sub { "ref($_[1]) && !!re::is_regexp($_[1])" },
  });
  
  $meta->add_type({
  	name       => "GlobRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "GLOB" },
  	inlined    => sub { "ref($_[1]) eq 'GLOB'" },
  });
  
  $meta->add_type({
  	name       => "FileHandle",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub {
  		(ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
  		or (blessed($_) && $_->isa("IO::Handle"))
  	},
  	inlined    => sub {
  		"(ref($_[1]) eq \"GLOB\" && Scalar::Util::openhandle($_[1])) ".
  		"or (Scalar::Util::blessed($_[1]) && $_[1]\->isa(\"IO::Handle\"))"
  	},
  });
  
  my $_arr = $meta->add_type({
  	name       => "ArrayRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "ARRAY" },
  	inlined    => sub { "ref($_[1]) eq 'ARRAY'" },
  	constraint_generator => LazyLoad(ArrayRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ArrayRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ArrayRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ArrayRef => 'coercion_generator'),
  });
  
  my $_hash = $meta->add_type({
  	name       => "HashRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "HASH" },
  	inlined    => sub { "ref($_[1]) eq 'HASH'" },
  	constraint_generator => LazyLoad(HashRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(HashRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(HashRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(HashRef => 'coercion_generator'),
  });
  
  $meta->add_type({
  	name       => "ScalarRef",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "SCALAR" or ref $_ eq "REF" },
  	inlined    => sub { "ref($_[1]) eq 'SCALAR' or ref($_[1]) eq 'REF'" },
  	constraint_generator => LazyLoad(ScalarRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ScalarRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ScalarRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ScalarRef => 'coercion_generator'),
  });
  
  my $_obj = $meta->add_type({
  	name       => "Object",
  	_is_core   => 1,
  	parent     => $_ref,
  	constraint => sub { blessed $_ },
  	inlined    => sub { "Scalar::Util::blessed($_[1])" },
  });
  
  $meta->add_type({
  	name       => "Maybe",
  	_is_core   => 1,
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Maybe') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Maybe[`a] expected to be a type constraint; got $param");
  		
  		return sub
  		{
  			my $value = shift;
  			return !!1 unless defined $value;
  			return $param->check($value);
  		};
  	},
  	inline_generator => sub {
  		my $param = shift;
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			my $param_check = $param->inline_check($v);
  			"!defined($v) or $param_check";
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s is defined', Type::Tiny::_dd($value)),
  			sprintf('"%s" constrains the value with "%s" if it is defined', $type, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  my $_map = $meta->add_type({
  	name       => "Map",
  	parent     => $_hash,
  	constraint_generator => LazyLoad(Map => 'constraint_generator'),
  	inline_generator     => LazyLoad(Map => 'inline_generator'),
  	deep_explanation     => LazyLoad(Map => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Map => 'coercion_generator'),
  });
  
  my $_Optional = $meta->add_type({
  	name       => "Optional",
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Optional') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Optional[`a] expected to be a type constraint; got $param");
  		
  		sub { exists($_[0]) ? $param->check($_[0]) : !!1 }
  	},
  	inline_generator => sub {
  		my $param = shift;
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			my $param_check = $param->inline_check($v);
  			"!exists($v) or $param_check";
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s exists', $varname),
  			sprintf('"%s" constrains %s with "%s" if it exists', $type, $varname, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  sub slurpy {
  	my $t = shift;
  	wantarray ? (+{ slurpy => $t }, @_) : +{ slurpy => $t };
  }
  
  $meta->add_type({
  	name       => "Tuple",
  	parent     => $_arr,
  	name_generator => sub
  	{
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], map { ref($_) eq "HASH" ? sprintf("slurpy %s", $_->{slurpy}) : $_ } @a);
  	},
  	constraint_generator => LazyLoad(Tuple => 'constraint_generator'),
  	inline_generator     => LazyLoad(Tuple => 'inline_generator'),
  	deep_explanation     => LazyLoad(Tuple => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Tuple => 'coercion_generator'),
  });
  
  $meta->add_type({
  	name       => "Dict",
  	parent     => $_hash,
  	name_generator => sub
  	{
  		my ($s, @p) = @_;
  		my $l = ref($p[-1]) eq q(HASH) ? pop(@p)->{slurpy} : undef;
  		my %a = @p;
  		sprintf('%s[%s%s]', $s, join(q[,], map sprintf("%s=>%s", $_, $a{$_}), sort keys %a), $l ? ",slurpy $l" : '');
  	},
  	constraint_generator => LazyLoad(Dict => 'constraint_generator'),
  	inline_generator     => LazyLoad(Dict => 'inline_generator'),
  	deep_explanation     => LazyLoad(Dict => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Dict => 'coercion_generator'),
  });
  
  use overload ();
  $meta->add_type({
  	name       => "Overload",
  	parent     => $_obj,
  	constraint => sub { overload::Overloaded($_) },
  	inlined    => sub { "Scalar::Util::blessed($_[1]) and overload::Overloaded($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Overload') unless @_;
  		
  		my @operations = map {
  			Types::TypeTiny::StringLike->check($_)
  				? "$_"
  				: _croak("Parameters to Overload[`a] expected to be a strings; got $_");
  		} @_;
  		
  		return sub {
  			my $value = shift;
  			for my $op (@operations) {
  				return unless overload::Method($value, $op);
  			}
  			return !!1;
  		}
  	},
  	inline_generator => sub {
  		my @operations = @_;
  		return sub {
  			my $v = $_[1];
  			join " and ",
  				"Scalar::Util::blessed($v)",
  				map "overload::Method($v, q[$_])", @operations;
  		};
  	},
  });
  
  our %_StrMatch;
  $meta->add_type({
  	name       => "StrMatch",
  	parent     => $_str,
  	constraint_generator => sub
  	{
  		return $meta->get_type('StrMatch') unless @_;
  		
  		my ($regexp, $checker) = @_;
  		
  		ref($regexp) eq 'Regexp'
  			or _croak("First parameter to StrMatch[`a] expected to be a Regexp; got $regexp");
  		
  		if (@_ > 1)
  		{
  			$checker = Types::TypeTiny::to_TypeTiny($checker);
  			Types::TypeTiny::TypeTiny->check($checker)
  				or _croak("Second parameter to StrMatch[`a] expected to be a type constraint; got $checker")
  		}
  		
  		$checker
  			? sub {
  				my $value = shift;
  				return if ref($value);
  				my @m = ($value =~ $regexp);
  				$checker->check(\@m);
  			}
  			: sub {
  				my $value = shift;
  				!ref($value) and $value =~ $regexp;
  			}
  		;
  	},
  	inline_generator => sub
  	{
  		require B;
  		my ($regexp, $checker) = @_;
  		my $regexp_string = "$regexp";
  		$_StrMatch{$regexp_string} = $regexp;
  		if ($checker)
  		{
  			return unless $checker->can_be_inlined;
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and do { my \$m = [$v =~ \$Types::Standard::_StrMatch{%s}]; %s }",
  					B::perlstring($regexp_string),
  					$checker->inline_check('$m'),
  				;
  			};
  		}
  		else
  		{
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and $v =~ \$Types::Standard::_StrMatch{%s}",
  					B::perlstring($regexp_string),
  				;
  			};
  		}
  	},
  });
  
  $meta->add_type({
  	name       => "OptList",
  	parent     => $_arr,
  	constraint => sub {
  		for my $inner (@$_) {
  			return unless ref($inner) eq q(ARRAY);
  			return unless @$inner == 2;
  			return unless is_Str($inner->[0]);
  		}
  		return !!1;
  	},
  	inlined     => sub {
  		my ($self, $var) = @_;
  		my $Str_check = Str()->inline_check('$inner->[0]');
  		my @code = 'do { my $ok = 1; ';
  		push @code,   sprintf('for my $inner (@{%s}) { no warnings; ', $var);
  		push @code,   sprintf('($ok=0) && last unless ref($inner) eq q(ARRAY) && @$inner == 2 && (%s); ', $Str_check);
  		push @code,   '} ';
  		push @code, '$ok }';
  		return (undef, join(q( ), @code));
  	},
  });
  
  $meta->add_type({
  	name       => "Tied",
  	parent     => $_ref,
  	constraint => sub {
  		!!tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_})
  	},
  	inlined    => sub {
  		my ($self, $var) = @_;
  		$self->parent->inline_check($var)
  		. " and !!tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var})"
  	},
  	name_generator => sub
  	{
  		my $self  = shift;
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require B;
  			return sprintf("%s[%s]", $self, B::perlstring($param));
  		}
  		return sprintf("%s[%s]", $self, $param);
  	},
  	constraint_generator => sub
  	{
  		return $meta->get_type('Tied') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		
  		my $check = $param->compiled_check;
  		return sub {
  			$check->(tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_}));
  		};
  	},
  	inline_generator => sub {
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		return unless $param->can_be_inlined;
  		
  		return sub {
  			require B;
  			my $var = $_[1];
  			sprintf(
  				"%s and do { my \$TIED = tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var}); %s }",
  				Ref()->inline_check($var),
  				$param->inline_check('$TIED')
  			);
  		};
  	},
  });
  
  $meta->add_type({
  	name       => "InstanceOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('InstanceOf') unless @_;
  		require Type::Tiny::Class;
  		my @classes = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Class"->new(class => $_, display_name => sprintf('InstanceOf[%s]', B::perlstring($_)))
  		} @_;
  		return $classes[0] if @classes == 1;
  		
  		require B;
  		require Type::Tiny::Union;
  		return "Type::Tiny::Union"->new(
  			type_constraints => \@classes,
  			display_name     => sprintf('InstanceOf[%s]', join q[,], map B::perlstring($_->class), @classes),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "ConsumerOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('ConsumerOf') unless @_;
  		require B;
  		require Type::Tiny::Role;
  		my @roles = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Role"->new(role => $_, display_name => sprintf('ConsumerOf[%s]', B::perlstring($_)))
  		} @_;
  		return $roles[0] if @roles == 1;
  		
  		require Type::Tiny::Intersection;
  		return "Type::Tiny::Intersection"->new(
  			type_constraints => \@roles,
  			display_name     => sprintf('ConsumerOf[%s]', join q[,], map B::perlstring($_->role), @roles),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "HasMethods",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('HasMethods') unless @_;
  		require B;
  		require Type::Tiny::Duck;
  		return "Type::Tiny::Duck"->new(
  			methods      => \@_,
  			display_name => sprintf('HasMethods[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "Enum",
  	parent     => $_str,
  	constraint_generator => sub {
  		return $meta->get_type('Enum') unless @_;
  		require B;
  		require Type::Tiny::Enum;
  		return "Type::Tiny::Enum"->new(
  			values       => \@_,
  			display_name => sprintf('Enum[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_coercion({
  	name               => "MkOpt",
  	type_constraint    => $meta->get_type("OptList"),
  	type_coercion_map  => [
  		$_arr,    q{ Exporter::Tiny::mkopt($_) },
  		$_hash,   q{ Exporter::Tiny::mkopt($_) },
  		$_undef,  q{ [] },
  	],
  });
  
  $meta->add_coercion({
  	name               => "Join",
  	type_constraint    => $_str,
  	coercion_generator => sub {
  		my ($self, $target, $sep) = @_;
  		Types::TypeTiny::StringLike->check($sep)
  			or _croak("Parameter to Join[`a] expected to be a string; got $sep");
  		require B;
  		$sep = B::perlstring($sep);
  		return (ArrayRef(), qq{ join($sep, \@\$_) });
  	},
  });
  
  $meta->add_coercion({
  	name               => "Split",
  	type_constraint    => $_arr,
  	coercion_generator => sub {
  		my ($self, $target, $re) = @_;
  		ref($re) eq q(Regexp)
  			or _croak("Parameter to Split[`a] expected to be a regular expresssion; got $re");
  		my $regexp_string = "$re";
  		$regexp_string =~ s/\\\//\\\\\//g; # toothpicks
  		return (Str(), qq{ [split /$regexp_string/, \$_] });
  	},
  });
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords booleans vstrings typeglobs
  
  =encoding utf-8
  
  =for stopwords datetimes
  
  =head1 NAME
  
  Types::Standard - bundled set of built-in types for Type::Tiny
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> bundles a few types which seem to be useful.
  
  =head2 Moose-like
  
  The following types are similar to those described in
  L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< Any >>
  
  Absolutely any value passes this type constraint (even undef).
  
  =item C<< Item >>
  
  Essentially the same as C<Any>. All other type constraints in this library
  inherit directly or indirectly from C<Item>.
  
  =item C<< Bool >>
  
  Values that are reasonable booleans. Accepts 1, 0, the empty string and
  undef.
  
  =item C<< Maybe[`a] >>
  
  Given another type constraint, also accepts undef. For example,
  C<< Maybe[Int] >> accepts all integers plus undef.
  
  =item C<< Undef >>
  
  Only undef passes this type constraint.
  
  =item C<< Defined >>
  
  Only undef fails this type constraint.
  
  =item C<< Value >>
  
  Any defined, non-reference value.
  
  =item C<< Str >>
  
  Any string.
  
  (The only difference between C<Value> and C<Str> is that the former accepts
  typeglobs and vstrings.)
  
  Other customers also bought: C<< StringLike >> from L<Types::TypeTiny>.
  
  =item C<< Num >>
  
  See C<LaxNum> and C<StrictNum> below.
  
  =item C<< Int >>
  
  An integer; that is a string of digits 0 to 9, optionally prefixed with a
  hyphen-minus character.
  
  =item C<< ClassName >>
  
  The name of a loaded package. The package must have C<< @ISA >> or
  C<< $VERSION >> defined, or must define at least one sub to be considered
  a loaded package.
  
  =item C<< RoleName >>
  
  Like C<< ClassName >>, but the package must I<not> define a method called
  C<new>. This is subtly different from Moose's type constraint of the same
  name; let me know if this causes you any problems. (I can't promise I'll
  change anything though.)
  
  =item C<< Ref[`a] >>
  
  Any defined reference value, including blessed objects.
  
  Unlike Moose, C<Ref> is a parameterized type, allowing Scalar::Util::reftype
  checks, a la
  
     Ref["HASH"]  # hashrefs, including blessed hashrefs
  
  =item C<< ScalarRef[`a] >>
  
  A value where C<< ref($value) eq "SCALAR" or ref($value) eq "REF" >>.
  
  If parameterized, the referred value must pass the additional constraint.
  For example, C<< ScalarRef[Int] >> must be a reference to a scalar which
  holds an integer value.
  
  =item C<< ArrayRef[`a] >>
  
  A value where C<< ref($value) eq "ARRAY" >>.
  
  If parameterized, the elements of the array must pass the additional
  constraint. For example, C<< ArrayRef[Num] >> must be a reference to an
  array of numbers.
  
  Other customers also bought: C<< ArrayLike >> from L<Types::TypeTiny>.
  
  =item C<< HashRef[`a] >>
  
  A value where C<< ref($value) eq "HASH" >>.
  
  If parameterized, the values of the hash must pass the additional
  constraint. For example, C<< HashRef[Num] >> must be a reference to an
  hash where the values are numbers. The hash keys are not constrained,
  but Perl limits them to strings; see C<Map> below if you need to further
  constrain the hash values.
  
  Other customers also bought: C<< HashLike >> from L<Types::TypeTiny>.
  
  =item C<< CodeRef >>
  
  A value where C<< ref($value) eq "CODE" >>.
  
  Other customers also bought: C<< CodeLike >> from L<Types::TypeTiny>.
  
  =item C<< RegexpRef >>
  
  A value where C<< ref($value) eq "Regexp" >>.
  
  =item C<< GlobRef >>
  
  A value where C<< ref($value) eq "GLOB" >>.
  
  =item C<< FileHandle >>
  
  A file handle.
  
  =item C<< Object >>
  
  A blessed object.
  
  (This also accepts regexp refs.)
  
  =back
  
  =head2 Structured
  
  OK, so I stole some ideas from L<MooseX::Types::Structured>.
  
  =over
  
  =item C<< Map[`k, `v] >>
  
  Similar to C<HashRef> but parameterized with type constraints for both the
  key and value. The constraint for keys would typically be a subtype of
  C<Str>.
  
  =item C<< Tuple[...] >>
  
  Subtype of C<ArrayRef>, accepting an list of type constraints for
  each slot in the array.
  
  C<< Tuple[Int, HashRef] >> would match C<< [1, {}] >> but not C<< [{}, 1] >>.
  
  =item C<< Dict[...] >>
  
  Subtype of C<HashRef>, accepting an list of type constraints for
  each slot in the hash.
  
  For example C<< Dict[name => Str, id => Int] >> allows
  C<< { name => "Bob", id => 42 } >>.
  
  =item C<< Optional[`a] >>
  
  Used in conjunction with C<Dict> and C<Tuple> to specify slots that are
  optional and may be omitted (but not necessarily set to an explicit undef).
  
  C<< Dict[name => Str, id => Optional[Int]] >> allows C<< { name => "Bob" } >>
  but not C<< { name => "Bob", id => "BOB" } >>.
  
  =back
  
  This module also exports a C<slurpy> function, which can be used as follows:
  
     my $type = Tuple[Str, slurpy ArrayRef[Int]];
     
     $type->( ["Hello"] );                # ok
     $type->( ["Hello", 1, 2, 3] );       # ok
     $type->( ["Hello", [1, 2, 3]] );     # not ok
  
  =begin trustme
  
  =item slurpy
  
  =end trustme
  
  =head2 Objects
  
  OK, so I stole some ideas from L<MooX::Types::MooseLike::Base>.
  
  =over
  
  =item C<< InstanceOf[`a] >>
  
  Shortcut for a union of L<Type::Tiny::Class> constraints.
  
  C<< InstanceOf["Foo", "Bar"] >> allows objects blessed into the C<Foo>
  or C<Bar> classes, or subclasses of those.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< ConsumerOf[`a] >>
  
  Shortcut for an intersection of L<Type::Tiny::Role> constraints.
  
  C<< ConsumerOf["Foo", "Bar"] >> allows objects where C<< $o->DOES("Foo") >>
  and C<< $o->DOES("Bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< HasMethods[`a] >>
  
  Shortcut for a L<Type::Tiny::Duck> constraint.
  
  C<< HasMethods["foo", "bar"] >> allows objects where C<< $o->can("foo") >>
  and C<< $o->can("bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =back
  
  =head2 More
  
  There are a few other types exported by this function:
  
  =over
  
  =item C<< Overload[`a] >>
  
  With no parameters, checks that the value is an overloaded object. Can
  be given one or more string parameters, which are specific operations
  to check are overloaded. For example, the following checks for objects
  which overload addition and subtraction.
  
     Overload["+", "-"]
  
  =item C<< Tied[`a] >>
  
  A reference to a tied scalar, array or hash.
  
  Can be parameterized with a type constraint which will be applied to
  the object returned by the C<< tied() >> function. As a convenience,
  can also be parameterized with a string, which will be inflated to a
  L<Type::Tiny::Class>.
  
     use Types::Standard qw(Tied);
     use Type::Utils qw(class_type);
     
     my $My_Package = class_type { class => "My::Package" };
     
     tie my %h, "My::Package";
     \%h ~~ Tied;                   # true
     \%h ~~ Tied[ $My_Package ];    # true
     \%h ~~ Tied["My::Package"];    # true
     
     tie my $s, "Other::Package";
     \$s ~~ Tied;                   # true
     $s  ~~ Tied;                   # false !!
  
  If you need to check that something is specifically a reference to
  a tied hash, use an intersection:
  
     use Types::Standard qw( Tied HashRef );
     
     my $TiedHash = (Tied) & (HashRef);
     
     tie my %h, "My::Package";
     tie my $s, "Other::Package";
     
     \%h ~~ $TiedHash;     # true
     \$s ~~ $TiedHash;     # false
  
  =item C<< StrMatch[`a] >>
  
  A string that matches a regular expression:
  
     declare "Distance",
        as StrMatch[ qr{^([0-9]+)\s*(mm|cm|m|km)$} ];
  
  You can optionally provide a type constraint for the array of subexpressions:
  
     declare "Distance",
        as StrMatch[
           qr{^([0-9]+)\s*(.+)$},
           Tuple[
              Int,
              enum(DistanceUnit => [qw/ mm cm m km /]),
           ],
        ];
  
  =item C<< Enum[`a] >>
  
  As per MooX::Types::MooseLike::Base:
  
     has size => (is => "ro", isa => Enum[qw( S M L XL XXL )]);
  
  =item C<< OptList >>
  
  An arrayref of arrayrefs in the style of L<Data::OptList> output.
  
  =item C<< LaxNum >>, C<< StrictNum >>
  
  In Moose 2.09, the C<Num> type constraint implementation was changed from
  being a wrapper around L<Scalar::Util>'s C<looks_like_number> function to
  a stricter regexp (which disallows things like "-Inf" and "Nan").
  
  Types::Standard provides I<both> implementations. C<LaxNum> is measurably
  faster.
  
  The C<Num> type constraint is currently an alias for C<LaxNum> unless you
  set the C<PERL_TYPES_STANDARD_STRICTNUM> environment variable to true before
  loading Types::Standard, in which case it becomes an alias for C<StrictNum>.
  The constant C<< Types::Standard::STRICTNUM >> can be used to check if
  C<Num> is being strict.
  
  Most people should probably use C<Num> or C<StrictNum>. Don't explicitly
  use C<LaxNum> unless you specifically need an attribute which will accept
  things like "Inf".
  
  =back
  
  =head2 Coercions
  
  None of the types in this type library have any coercions by default.
  However some standalone coercions may be exported. These can be combined
  with type constraints using the C<< + >> operator.
  
  =over
  
  =item C<< MkOpt >>
  
  A coercion from C<ArrayRef>, C<HashRef> or C<Undef> to C<OptList>. Example
  usage in a Moose attribute:
  
     use Types::Standard qw( OptList MkOpt );
     
     has options => (
        is     => "ro",
        isa    => OptList + MkOpt,
        coerce => 1,
     );
  
  =item C<< Split[`a] >>
  
  Split a string on a regexp.
  
     use Types::Standard qw( ArrayRef Str Split );
     
     has name => (
        is     => "ro",
        isa    => (ArrayRef[Str]) + (Split[qr/\s/]),
        coerce => 1,
     );
  
  =item C<< Join[`a] >>
  
  Join an array of strings with a delimiter.
  
     use Types::Standard qw( Str Join );
     
     my $FileLines = Str + Join["\n"];
     
     has file_contents => (
        is     => "ro",
        isa    => $FileLines,
        coerce => 1,
     );
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< Types::Standard::STRICTNUM >>
  
  Indicates whether C<Num> is an alias for C<StrictNum>. (It is usually an
  alias for C<LaxNum>.)
  
  =back
  
  =begin private
  
  =item Stringable
  
  =item LazyLoad
  
  =end private
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>,
  L<MooseX::Types::Structured>.
  
  L<Types::XSD> provides some type constraints based on XML Schema's data
  types; this includes constraints for ISO8601-formatted datetimes, integer
  ranges (e.g. C<< PositiveInteger[maxInclusive=>10] >> and so on.
  
  L<Types::Encodings> provides C<Bytes> and C<Chars> type constraints that
  were formerly found in Types::Standard.
  
  L<Types::Common::Numeric> and L<Types::Common::String> provide replacements
  for L<MooseX::Types::Common>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD

$fatpacked{"Types/Standard/ArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_ARRAYREF';
  package Types::Standard::ArrayRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ArrayRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ArrayRef::VERSION   = '0.034';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ArrayRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ArrayRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $array = shift;
  		$param->check($_) || return for @$array;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'ARRAY' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (\@{$v}) { "
  		.    "\$ok = 0 && last unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $i (0 .. $#$value)
  	{
  		my $item = $value->[$i];
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the array with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->[%d]', $varname, $i)) },
  		]
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, @new) = ($_, 0);';
  			push @code,    'for (@$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('push @new, (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my @new;
  				for my $item (@$value)
  				{
  					return $value unless $coercable_item->check($item);
  					push @new, $param->coerce($item);
  				}
  				return \@new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ArrayRef - internals for the Types::Standard ArrayRef type constraint
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_ARRAYREF

$fatpacked{"Types/Standard/Dict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_DICT';
  package Types::Standard::Dict;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Dict::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Dict::VERSION   = '0.034';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_hash = Types::Standard::HashRef;
  my $_map  = Types::Standard::Map;
  my $_any  = Types::Standard::Any;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my %constraints = @_;
  	
  	while (my ($k, $v) = each %constraints)
  	{
  		$constraints{$k} = Types::TypeTiny::to_TypeTiny($v);
  		Types::TypeTiny::TypeTiny->check($v)
  			or _croak("Parameter to Dict[`a] for key '$k' expected to be a type constraint; got $v");
  	}
  	
  	return sub
  	{
  		my $value = $_[0];
  		if ($slurpy)
  		{
  			my %tmp = map {
  				exists($constraints{$_}) ? () : ($_ => $value->{$_})
  			} keys %$value;
  			return unless $slurpy->check(\%tmp);
  		}
  		else
  		{
  			exists($constraints{$_}) || return for sort keys %$value;
  		}
  		for (sort keys %constraints) {
  			my $c = $constraints{$_};
  			return unless exists($value->{$_}) || $c->is_strictly_a_type_of(Types::Standard::Optional);
  			return unless $c->check( exists $value->{$_} ? $value->{$_} : () );
  		}
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	# We can only inline a parameterized Dict if all the
  	# constraints inside can be inlined.
  	
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	return if $slurpy && !$slurpy->can_be_inlined;
  	
  	# Is slurpy a very loose type constraint?
  	# i.e. Any, Item, Defined, Ref, or HashRef
  	my $slurpy_is_any = $slurpy && $_hash->is_a_type_of( $slurpy );
  	
  	# Is slurpy a parameterized Map, or expressable as a parameterized Map?
  	my $slurpy_is_map = $slurpy
  		&& $slurpy->is_parameterized
  		&& ((
  			$slurpy->parent->strictly_equals($_map)
  			&& $slurpy->parameters
  		)||(
  			$slurpy->parent->strictly_equals($_hash)
  			&& [ $_any, $slurpy->parameters->[0] ]
  		));
  	
  	my %constraints = @_;
  	for my $c (values %constraints)
  	{
  		next if $c->can_be_inlined;
  		return;
  	}
  	
  	my $regexp = join "|", map quotemeta, sort keys %constraints;
  	return sub
  	{
  		require B;
  		my $h = $_[1];
  		join " and ",
  			"ref($h) eq 'HASH'",
  			( $slurpy_is_any ? '1'
  			: $slurpy_is_map ? do {
  				'(not grep {'
  				."my \$v = ($h)->{\$_};"
  				.sprintf(
  					'not((%s) and (%s))',
  					$slurpy_is_map->[0]->inline_check('$_'),
  					$slurpy_is_map->[1]->inline_check('$v'),
  				) ."} keys \%{$h})"
  			}
  			: $slurpy ? do {
  				'do {'
  				. "my \$slurpy_tmp = +{ map /\\A(?:$regexp)\\z/ ? () : (\$_ => ($h)->{\$_}), keys \%{$h} };"
  				. $slurpy->inline_check('$slurpy_tmp')
  				. '}'
  			}
  			: "not(grep !/\\A(?:$regexp)\\z/, keys \%{$h})" ),
  			( map {
  				my $k = B::perlstring($_);
  				$constraints{$_}->is_strictly_a_type_of( Types::Standard::Optional )
  					? $constraints{$_}->inline_check("$h\->{$k}")
  					: ( "exists($h\->{$k})", $constraints{$_}->inline_check("$h\->{$k}") )
  			} sort keys %constraints ),
  	}
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my @params = @{ $type->parameters };
  	
  	my $slurpy = ref($params[-1]) eq q(HASH) ? pop(@params)->{slurpy} : undef;
  	my %constraints = @params;
  			
  	for my $k (sort keys %constraints)
  	{
  		next if $constraints{$k}->parent == Types::Standard::Optional && !exists $value->{$k};
  		next if $constraints{$k}->check($value->{$k});
  		
  		return [
  			sprintf('"%s" requires key %s to appear in hash', $type, B::perlstring($k))
  		] unless exists $value->{$k};
  		
  		return [
  			sprintf('"%s" constrains value at key %s of hash with "%s"', $type, B::perlstring($k), $constraints{$k}),
  			@{ $constraints{$k}->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	if ($slurpy)
  	{
  		my %tmp = map {
  			exists($constraints{$_}) ? () : ($_ => $value->{$_})
  		} keys %$value;
  		
  		my $explain = $slurpy->validate_explain(\%tmp, '$slurpy');
  		return [
  			sprintf('"%s" requires the hashref of additional key/value pairs to conform to "%s"', $type, $slurpy),
  			@$explain,
  		] if $explain;
  	}
  	else
  	{
  		for my $k (sort keys %$value)
  		{
  			return [
  				sprintf('"%s" does not allow key %s to appear in hash', $type, B::perlstring($k))
  			] unless exists $constraints{$k};
  		}
  	}
  	
  	return;
  }
  
  my $label_counter = 0;
  our ($keycheck_counter, @KEYCHECK) = -1;
  sub __coercion_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my ($parent, $child, %dict) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	my $all_inlinable = 1;
  	for my $tc (values %dict)
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}
  	$all_inlinable = 0 if $slurpy && !$slurpy->can_be_inlined;
  	$all_inlinable = 0 if $slurpy && $slurpy->has_coercion && !$slurpy->coercion->can_be_inlined;
  	
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			require B;
  			
  			my $keycheck = join "|", map quotemeta, sort { length($b) <=> length($a) or $a cmp $b } keys %dict;
  			$keycheck = $KEYCHECK[++$keycheck_counter] = qr{^($keycheck)$}ms; # regexp for legal keys
  			
  			my $label = sprintf("DICTLABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %tmp, %new) = ($_, 0);';
  			push @code,       "$label: {";
  			if ($slurpy)
  			{
  				push @code, sprintf('my $slurped = +{ map +($_=~$%s::KEYCHECK[%d])?():($_=>$orig->{$_}), keys %%$orig };', __PACKAGE__, $keycheck_counter);
  				if ($slurpy->has_coercion)
  				{
  					push @code, sprintf('my $coerced = %s;', $slurpy->coercion->inline_coercion('$slurped'));
  					push @code, sprintf('((%s)&&(%s))?(%%new=%%$coerced):(($return_orig = 1), last %s);', $_hash->inline_check('$coerced'), $slurpy->inline_check('$coerced'), $label);
  				}
  				else
  				{
  					push @code, sprintf('(%s)?(%%new=%%$slurped):(($return_orig = 1), last %s);', $slurpy->inline_check('$slurped'), $label);
  				}
  			}
  			else
  			{
  				push @code, sprintf('($_ =~ $%s::KEYCHECK[%d])||(($return_orig = 1), last %s) for sort keys %%$orig;', __PACKAGE__, $keycheck_counter, $label);
  			}
  			for my $k (keys %dict)
  			{
  				my $ct = $dict{$k};
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of(Types::Standard::Optional);
  				my $K = B::perlstring($k);
  				
  				push @code, "if (exists \$orig->{$K}) {" if $ct_optional;
  				if ($ct_coerce)
  				{
  					push @code, sprintf('%%tmp = (); $tmp{x} = %s;', $ct->coercion->inline_coercion("\$orig->{$K}"));
  					push @code, sprintf(
  #						$ct_optional
  #							? 'if (%s) { $new{%s}=$tmp{x} }'
  #							:
  						'if (%s) { $new{%s}=$tmp{x} } else { $return_orig = 1; last %s }',
  						$ct->inline_check('$tmp{x}'),
  						$K,
  						$label,
  					);
  				}
  				else
  				{
  					push @code, sprintf(
  #						$ct_optional
  #							? 'if (%s) { $new{%s}=$orig->{%s} }'
  #							:
  						'if (%s) { $new{%s}=$orig->{%s} } else { $return_orig = 1; last %s }',
  						$ct->inline_check("\$orig->{$K}"),
  						$K,
  						$K,
  						$label,
  					);
  				}
  				push @code, '}' if $ct_optional;
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			#warn "CODE:: @code";
  			"@code";
  		});
  	}
  	
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				
  				if ($slurpy)
  				{
  					my %slurped = map exists($dict{$_}) ? () : ($_ => $value->{$_}), keys %$value;
  					
  					if ($slurpy->check(\%slurped))
  					{
  						%new = %slurped;
  					}
  					elsif ($slurpy->has_coercion)
  					{
  						my $coerced = $slurpy->coerce(\%slurped);
  						$slurpy->check($coerced) ? (%new = %$coerced) : (return $value);
  					}
  					else
  					{
  						return $value;
  					}
  				}
  				else
  				{
  					for my $k (keys %$value)
  					{
  						return $value unless exists $dict{$k};
  					}
  				}
  
  				for my $k (keys %dict)
  				{
  					my $ct = $dict{$k};
  					my @accept;
  					
  					if (exists $value->{$k} and $ct->check($value->{$k}))
  					{
  						@accept = $value->{$k};
  					}
  					elsif (exists $value->{$k} and $ct->has_coercion)
  					{
  						my $x = $ct->coerce($value->{$k});
  						@accept = $x if $ct->check($x);
  					}
  					elsif (exists $value->{$k})
  					{
  						return $value;
  					}
  					
  					if (@accept)
  					{
  						$new{$k} = $accept[0];
  					}
  					elsif (not $ct->is_a_type_of(Types::Standard::Optional))
  					{
  						return $value;
  					}
  				}
  				
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Dict - internals for the Types::Standard Dict type constraint
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_DICT

$fatpacked{"Types/Standard/HashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_HASHREF';
  package Types::Standard::HashRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::HashRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::HashRef::VERSION   = '0.034';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::HashRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to HashRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $hash = shift;
  		$param->check($_) || return for values %$hash;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		"ref($v) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (values \%{$v}) { "
  		.    "\$ok = 0 && last unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $k (sort keys %$value)
  	{
  		my $item = $value->{$k};
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the hash with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{$_} = (%s);', $param->coercion->inline_coercion('$orig->{$_}'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $coercable_item->check($value->{$k});
  					$new{$k} = $param->coerce($value->{$k});
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::HashRef - internals for the Types::Standard HashRef type constraint
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_HASHREF

$fatpacked{"Types/Standard/Map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_MAP';
  package Types::Standard::Map;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Map::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Map::VERSION   = '0.034';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = Types::Standard->meta;
  
  no warnings;
  
  sub __constraint_generator
  {
  	return $meta->get_type('Map') unless @_;
  	
  	my ($keys, $values) = map Types::TypeTiny::to_TypeTiny($_), @_;
  	Types::TypeTiny::TypeTiny->check($keys)
  		or _croak("First parameter to Map[`k,`v] expected to be a type constraint; got $keys");
  	Types::TypeTiny::TypeTiny->check($values)
  		or _croak("Second parameter to Map[`k,`v] expected to be a type constraint; got $values");
  	
  	return sub
  	{
  		my $hash = shift;
  		$keys->check($_)   || return for keys %$hash;
  		$values->check($_) || return for values %$hash;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my ($k, $v) = @_;
  	return unless $k->can_be_inlined && $v->can_be_inlined;
  	my $k_check = $k->inline_check('$k');
  	my $v_check = $v->inline_check('$v');
  	return sub {
  		my $h = $_[1];
  		"ref($h) eq 'HASH' and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$v (values \%{$h}) { "
  		.    "\$ok = 0 && last unless $v_check "
  		.  "}; "
  		.  "for my \$k (keys \%{$h}) { "
  		.    "\$ok = 0 && last unless $k_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my ($kparam, $vparam) = @{ $type->parameters };
  	
  	for my $k (sort keys %$value)
  	{
  		unless ($kparam->check($k))
  		{
  			return [
  				sprintf('"%s" constrains each key in the hash with "%s"', $type, $kparam),
  				@{ $kparam->validate_explain($k, sprintf('key %s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  		
  		unless ($vparam->check($value->{$k}))
  		{
  			return [
  				sprintf('"%s" constrains each value in the hash with "%s"', $type, $vparam),
  				@{ $vparam->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $kparam, $vparam) = @_;
  	return unless $kparam->has_coercion || $vparam->has_coercion;
  	
  	my $kcoercable_item = $kparam->has_coercion ? $kparam->coercion->_source_type_union : $kparam;
  	my $vcoercable_item = $vparam->has_coercion ? $vparam->coercion->_source_type_union : $vparam;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ((!$kparam->has_coercion or $kparam->coercion->can_be_inlined)
  	and (!$vparam->has_coercion or $vparam->coercion->can_be_inlined)
  	and $kcoercable_item->can_be_inlined
  	and $vcoercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $kcoercable_item->inline_check('$_'));
  			push @code, sprintf('$return_orig++ && last unless (%s);', $vcoercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{(%s)} = (%s);',
  				$kparam->has_coercion ? $kparam->coercion->inline_coercion('$_') : '$_',
  				$vparam->has_coercion ? $vparam->coercion->inline_coercion('$orig->{$_}') : '$orig->{$_}',
  			);
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $kcoercable_item->check($k) && $vcoercable_item->check($value->{$k});
  					$new{$kparam->has_coercion ? $kparam->coerce($k) : $k} =
  						$vparam->has_coercion ? $vparam->coerce($value->{$k}) : $value->{$k};
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Map - internals for the Types::Standard Map type constraint
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_MAP

$fatpacked{"Types/Standard/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_SCALARREF';
  package Types::Standard::ScalarRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ScalarRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ScalarRef::VERSION   = '0.034';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ScalarRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ScalarRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $ref = shift;
  		$param->check($$ref) || return;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	return sub {
  		my $v = $_[1];
  		my $param_check = $param->inline_check("\${$v}");
  		"(ref($v) eq 'SCALAR' or ref($v) eq 'REF') and $param_check";
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $item ($$value)
  	{
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains the referenced scalar value with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('${%s}', $varname)) },
  		];
  	}
  	
  	return;
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $new) = ($_, 0);';
  			push @code,    'for ($$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('$new = (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\$new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my $new;
  				for my $item ($$value)
  				{
  					return $value unless $coercable_item->check($item);
  					$new = $param->coerce($item);
  				}
  				return \$new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ScalarRef - internals for the Types::Standard ScalarRef type constraint
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_SCALARREF

$fatpacked{"Types/Standard/Tuple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_TUPLE';
  package Types::Standard::Tuple;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Tuple::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Tuple::VERSION   = '0.034';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_Optional = Types::Standard::Optional;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  		Types::TypeTiny::TypeTiny->check($slurpy)
  			or _croak("Slurpy parameter to Tuple[...] expected to be a type constraint; got $slurpy");
  	}
  	
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	for (@constraints)
  	{
  		Types::TypeTiny::TypeTiny->check($_)
  			or _croak("Parameters to Tuple[...] expected to be type constraints; got $_");
  	}
  		
  	return sub
  	{
  		my $value = $_[0];
  		if ($#constraints < $#$value)
  		{
  			defined($slurpy) && $slurpy->check(
  				$slurpy->is_a_type_of(Types::Standard::HashRef)
  					? +{@$value[$#constraints+1 .. $#$value]}
  					: +[@$value[$#constraints+1 .. $#$value]]
  			) or return;
  		}
  		for my $i (0 .. $#constraints)
  		{
  			$i <= $#$value or $constraints[$i]->is_strictly_a_type_of($_Optional) or return;
  			$constraints[$i]->check(exists $value->[$i] ? $value->[$i] : ()) or return;
  		}
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = pop(@constraints)->{slurpy};
  	}
  	
  	return if grep { not $_->can_be_inlined } @constraints;
  	return if defined $slurpy && !$slurpy->can_be_inlined;
  	
  	my $tmpl = defined($slurpy) && $slurpy->is_a_type_of(Types::Standard::HashRef)
  		? "do { my \$tmp = +{\@{%s}[%d..\$#{%s}]}; %s }"
  		: "do { my \$tmp = +[\@{%s}[%d..\$#{%s}]]; %s }";
  	
  	my $min = 0 + grep !$_->is_strictly_a_type_of($_Optional), @constraints;
  	
  	return sub
  	{
  		my $v = $_[1];
  		join " and ",
  			"ref($v) eq 'ARRAY'",
  			"scalar(\@{$v}) >= $min",
  			($slurpy
  				? sprintf($tmpl, $v, $#constraints+1, $v, $slurpy->inline_check('$tmp'))
  				: sprintf("\@{$v} <= %d", scalar @constraints)
  			),
  			map { $constraints[$_]->inline_check("$v\->[$_]") } 0 .. $#constraints;
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	
  	my @constraints = @{ $type->parameters };
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  	}
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	
  	if ($#constraints < $#$value and not $slurpy)
  	{
  		return [
  			sprintf('"%s" expects at most %d values in the array', $type, $#constraints),
  			sprintf('%d values found; too many', $#$value),
  		];
  	}
  	
  	for my $i (0 .. $#constraints)
  	{
  		next if $constraints[$i]->is_strictly_a_type_of( Types::Standard::Optional ) && $i > $#$value;
  		next if $constraints[$i]->check($value->[$i]);
  		
  		return [
  			sprintf('"%s" constrains value at index %d of array with "%s"', $type, $i, $constraints[$i]),
  			@{ $constraints[$i]->validate_explain($value->[$i], sprintf('%s->[%s]', $varname, $i)) },
  		];
  	}
  	
  	if (defined($slurpy))
  	{
  		my $tmp = $slurpy->is_a_type_of(Types::Standard::HashRef)
  			? +{@$value[$#constraints+1 .. $#$value]}
  			: +[@$value[$#constraints+1 .. $#$value]];
  		$slurpy->check($tmp) or return [
  			sprintf(
  				'Array elements from index %d are slurped into a %s which is constrained with "%s"',
  				$#constraints+1,
  				$slurpy->is_a_type_of(Types::Standard::HashRef) ? 'hashref' : 'arrayref',
  				$slurpy,
  			),
  			@{ $slurpy->validate_explain($tmp, '$SLURPY') },
  		];
  	}
  	
  	return;
  }
  
  my $label_counter = 0;
  sub __coercion_generator
  {
  	my ($parent, $child, @tuple) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	my $slurpy;
  	if (exists $tuple[-1] and ref $tuple[-1] eq "HASH")
  	{
  		$slurpy = pop(@tuple)->{slurpy};
  	}
  	
  	my $all_inlinable = 1;
  	for my $tc (@tuple, ($slurpy ? $slurpy : ()))
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		last if!$all_inlinable;
  	}
  	
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my $label = sprintf("TUPLELABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, @tmp, @new) = ($_, 0);';
  			push @code,       "$label: {";
  			push @code,       sprintf('(($return_orig = 1), last %s) if @$orig > %d;', $label, scalar @tuple) unless $slurpy;
  			for my $i (0 .. $#tuple)
  			{
  				my $ct = $tuple[$i];
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of(Types::Standard::Optional);
  				
  				if ($ct_coerce)
  				{
  					push @code, sprintf('@tmp = (); $tmp[0] = %s;', $ct->coercion->inline_coercion("\$orig->[$i]"));
  					push @code, sprintf(
  						$ct_optional
  							? 'if (%s) { $new[%d]=$tmp[0] }'
  							: 'if (%s) { $new[%d]=$tmp[0] } else { $return_orig = 1; last %s }',
  						$ct->inline_check('$tmp[0]'),
  						$i,
  						$label,
  					);
  				}
  				else
  				{
  					push @code, sprintf(
  						$ct_optional
  							? 'if (%s) { $new[%d]=$orig->[%s] }'
  							: 'if (%s) { $new[%d]=$orig->[%s] } else { $return_orig = 1; last %s }',
  						$ct->inline_check("\$orig->[$i]"),
  						$i,
  						$i,
  						$label,
  					);
  				}
  			}
  			if ($slurpy)
  			{
  				my $size = @tuple;
  				push @code, sprintf('if (@$orig > %d) {', $size);
  				push @code, sprintf('my $tail = [ @{$orig}[%d .. $#$orig] ];', $size);
  				push @code, $slurpy->has_coercion
  					? sprintf('$tail = %s;', $slurpy->coercion->inline_coercion('$tail'))
  					: q();
  				push @code, sprintf(
  					'(%s) ? push(@new, @$tail) : ($return_orig++);',
  					$slurpy->inline_check('$tail'),
  				);
  				push @code, '}';
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				
  				if (!$slurpy and @$value > @tuple)
  				{
  					return $value;
  				}
  				
  				my @new;
  				for my $i (0 .. $#tuple)
  				{
  					my $ct = $tuple[$i];
  					my @accept;
  					
  					if (exists $value->[$i] and $ct->check($value->[$i]))
  					{
  						@accept = $value->[$i];
  					}
  					elsif (exists $value->[$i] and $ct->has_coercion)
  					{
  						my $x = $ct->coerce($value->[$i]);
  						@accept = $x if $ct->check($x);
  					}
  					else
  					{
  						return $value;
  					}
  					
  					if (@accept)
  					{
  						$new[$i] = $accept[0];
  					}
  					elsif (not $ct->is_a_type_of(Types::Standard::Optional))
  					{
  						return $value;
  					}
  				}
  				
  				if ($slurpy and @$value > @tuple)
  				{
  					my $tmp = $slurpy->has_coercion
  						? $slurpy->coerce([ @{$value}[@tuple .. $#$value] ])
  						: [ @{$value}[@tuple .. $#$value] ];
  					$slurpy->check($tmp) ? push(@new, @$tmp) : return($value);
  				}
  				
  				return \@new;
  			},
  		);
  	};
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Tuple - internals for the Types::Standard Tuple type constraint
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_TUPLE

$fatpacked{"Types/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_TYPETINY';
  package Types::TypeTiny;
  
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.034';
  
  use Scalar::Util qw< blessed refaddr weaken >;
  
  our @EXPORT_OK = ( __PACKAGE__->type_names, qw/to_TypeTiny/ );
  
  my %cache;
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  sub meta
  {
  	return $_[0];
  }
  
  sub has_type
  {
  	defined(shift->get_coercion(@_))
  }
  
  sub get_type
  {
  	my $self = shift;
  	my $func = $self->can(@_) or return;
  	my $type = $func->();
  	return $type if blessed($type) && $type->isa("Type::Tiny");
  	return;
  }
  
  sub type_names
  {
  	qw( CodeLike StringLike TypeTiny HashLike ArrayLike );
  }
  
  sub has_coercion
  {
  	defined(shift->get_coercion(@_))
  }
  
  sub get_coercion
  {
  	();
  }
  
  sub coercion_names
  {
  	();
  }
  
  sub StringLike ()
  {
  	require Type::Tiny;
  	$cache{StringLike} ||= "Type::Tiny"->new(
  		name       => "StringLike",
  		constraint => sub {    !ref($_   ) or Scalar::Util::blessed($_   ) && overload::Method($_   , q[""])  },
  		inlined    => sub { qq/!ref($_[1]) or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[""])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub HashLike ()
  {
  	require Type::Tiny;
  	$cache{HashLike} ||= "Type::Tiny"->new(
  		name       => "HashLike",
  		constraint => sub {    ref($_   ) eq q[HASH] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[%{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[HASH] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\%{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub ArrayLike ()
  {
  	require Type::Tiny;
  	$cache{ArrayLike} ||= "Type::Tiny"->new(
  		name       => "ArrayLike",
  		constraint => sub {    ref($_   ) eq q[ARRAY] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[@{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[ARRAY] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\@{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub CodeLike ()
  {
  	require Type::Tiny;
  	$cache{CodeLike} ||= "Type::Tiny"->new(
  		name       => "CodeLike",
  		constraint => sub {    ref($_   ) eq q[CODE] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[&{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[CODE] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\&{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub TypeTiny ()
  {
  	require Type::Tiny;
  	$cache{TypeTiny} ||= "Type::Tiny"->new(
  		name       => "TypeTiny",
  		constraint => sub {  Scalar::Util::blessed($_   ) && $_   ->isa(q[Type::Tiny])  },
  		inlined    => sub { my $var = $_[1]; "Scalar::Util::blessed($var) && $var\->isa(q[Type::Tiny])" },
  		library    => __PACKAGE__,
  	);
  }
  
  my %ttt_cache;
  
  sub to_TypeTiny
  {
  	my $t = $_[0];
  	
  	return $t unless ref $t;
  	return $t if ref($t) =~ /^Type::Tiny\b/;
  	
  	return $ttt_cache{ refaddr($t) } if $ttt_cache{ refaddr($t) };
  	
  	if (my $class = blessed $t)
  	{
  		return $t                           if $class->isa("Type::Tiny");
  		goto \&_TypeTinyFromMoose           if $class->isa("Moose::Meta::TypeConstraint");
  		goto \&_TypeTinyFromMoose           if $class->isa("MooseX::Types::TypeDecorator");
  		goto \&_TypeTinyFromValidationClass if $class->isa("Validation::Class::Simple");
  		goto \&_TypeTinyFromValidationClass if $class->isa("Validation::Class");
  		goto \&_TypeTinyFromGeneric         if $t->can("check") && $t->can("get_message"); # i.e. Type::API::Constraint
  	}
  	
  	goto \&_TypeTinyFromCodeRef if ref($t) eq q(CODE);
  	
  	$t;
  }
  
  sub _TypeTinyFromMoose
  {
  	my $t = $_[0];
  	
  	if (ref $t->{"Types::TypeTiny::to_TypeTiny"})
  	{
  		return $t->{"Types::TypeTiny::to_TypeTiny"};
  	}
  	
  	if ($t->name ne '__ANON__')
  	{
  		require Types::Standard;
  		my $ts = 'Types::Standard'->get_type($t->name);
  		return $ts if $ts->{_is_core};
  	}
  	
  	my %opts;
  	$opts{display_name} = $t->name;
  	$opts{constraint}   = $t->constraint;
  	$opts{parent}       = to_TypeTiny($t->parent)              if $t->has_parent;
  	$opts{inlined}      = sub { shift; $t->_inline_check(@_) } if $t->can_be_inlined;
  	$opts{message}      = sub { $t->get_message($_) }          if $t->has_message;
  	$opts{moose_type}   = $t;
  	
  	require Type::Tiny;
  	my $new = 'Type::Tiny'->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	
  	$new->{coercion} = do {
  		require Type::Coercion::FromMoose;
  		'Type::Coercion::FromMoose'->new(type_constraint => $new);
  	} if $t->has_coercion;
  	
  	return $new;
  }
  
  sub _TypeTinyFromValidationClass
  {
  	my $t = $_[0];
  	
  	require Type::Tiny;
  	require Types::Standard;
  	
  	my %opts = (
  		parent            => Types::Standard::HashRef(),
  		_validation_class => $t,
  	);
  	
  	if ($t->VERSION >= "7.900048")
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = eval { $t->validate };
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = (eval { $t->validate } ? "OK" : $t->errors_to_string);
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  	}
  	else  # need to use hackish method
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate };
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate } ? "OK" : $t->errors_to_string;
  		};
  	}
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	
  	$new->coercion->add_type_coercions(
  		Types::Standard::HashRef() => sub {
  			my %params = %$_;
  			for my $k (keys %params)
  				{ delete $params{$_} unless $t->get_fields($k) };
  			$t->params->clear;
  			$t->params->add(%params);
  			eval { $t->validate };
  			$t->get_hash;
  		},
  	);
  	
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  sub _TypeTinyFromGeneric
  {
  	my $t = $_[0];
  	
  	# XXX - handle inlining??
  	
  	my %opts = (
  		constraint => sub { $t->check(@_ ? @_ : $_) },
  		message    => sub { $t->get_message(@_ ? @_ : $_) },
  	);
  	
  	$opts{display_name} = $t->name if $t->can("name");
  	
  	$opts{coercion} = sub { $t->coerce(@_ ? @_ : $_) }
  		if $t->can("has_coercion") && $t->has_coercion && $t->can("coerce");
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  sub _TypeTinyFromCodeRef
  {
  	my $t = $_[0];
  	
  	my %opts = (
  		constraint => sub {
  			return !!eval { $t->($_) };
  		},
  		message => sub {
  			local $@;
  			eval { $t->($_); 1 } or do { chomp $@; return $@ if $@ };
  			return sprintf('%s did not pass type constraint', Type::Tiny::_dd($_));
  		},
  	);
  
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords arrayfication hashification
  
  =head1 NAME
  
  Types::TypeTiny - type constraints used internally by Type::Tiny
  
  =head1 DESCRIPTION
  
  Dogfooding.
  
  This isn't a real Type::Library-based type library; that would involve
  too much circularity. But it exports some type constraints which, while
  designed for use within Type::Tiny, may be more generally useful.
  
  =head2 Types
  
  =over
  
  =item C<< StringLike >>
  
  Accepts strings and objects overloading stringification.
  
  =item C<< HashLike >>
  
  Accepts hashrefs and objects overloading hashification.
  
  =item C<< ArrayLike >>
  
  Accepts arrayrefs and objects overloading arrayfication.
  
  =item C<< CodeLike >>
  
  Accepts coderefs and objects overloading codification.
  
  =item C<< TypeTiny >>
  
  Accepts blessed L<Type::Tiny> objects.
  
  =back
  
  =head2 Coercion Functions
  
  =over
  
  =item C<< to_TypeTiny($constraint) >>
  
  Promotes (or "demotes" if you prefer) a Moose::Meta::TypeConstraint object
  to a Type::Tiny object.
  
  Can also handle L<Validation::Class> objects. Type constraints built from 
  Validation::Class objects deliberately I<ignore> field filters when they
  do constraint checking (and go to great lengths to do so); using filters for
  coercion only. (The behaviour of C<coerce> if we don't do that is just too
  weird!)
  
  Can also handle any object providing C<check> and C<get_message> methods.
  (This includes L<Mouse::Meta::TypeConstraint> objects.) If the object also
  provides C<has_coercion> and C<coerce> methods, these will be used too.
  
  Can also handle coderefs (but not blessed coderefs or objects overloading
  C<< &{} >>). Coderefs are expected to return true iff C<< $_ >> passes the
  constraint. If C<< $_ >> fails the type constraint, they may either return
  false, or die with a helpful error message.
  
  =back
  
  =head2 Methods
  
  These are implemented so that C<< Types::TypeTiny->meta->get_type($foo) >>
  works, for rough compatibility with a real L<Type::Library> type library.
  
  =over
  
  =item C<< meta >>
  
  =item C<< type_names >>
  
  =item C<< get_type($name) >>
  
  =item C<< has_type($name) >>
  
  =item C<< coercion_names >>
  
  =item C<< get_coercion($name) >>
  
  =item C<< has_coercion($name) >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_TYPETINY

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  use 5.008001;
  package YAML;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  YAML - YAML Ain't Markup Language (tm)
  
  =head1 NOTE
  
  This module has been released to CPAN as YAML::Old, and soon YAML.pm
  will be changed to just be a frontend interface module for all the
  various Perl YAML implementation modules, including YAML::Old.
  
  If you want robust and fast YAML processing using the normal Dump/Load
  API, please consider switching to YAML::XS. It is by far the best Perl
  module for YAML at this time. It requires that you have a C compiler,
  since it is written in C.
  
  If you really need to use this version of YAML.pm it will always be
  available as YAML::Old.
  
  If you don't care which YAML module use, as long as it's the best one
  installed on your system, use YAML::Any.
  
  The rest of this documentation is left unchanged, until YAML.pm is
  switched over to the new UI-only version.
  
  =head1 SYNOPSIS
  
      use YAML;
      
      # Load a YAML stream of 3 YAML documents into Perl data structures.
      my ($hashref, $arrayref, $string) = Load(<<'...');
      ---
      name: ingy
      age: old
      weight: heavy
      # I should comment that I also like pink, but don't tell anybody.
      favorite colors:
          - red
          - green
          - blue
      ---
      - Clark Evans
      - Oren Ben-Kiki
      - Ingy dt Net
      --- >
      You probably think YAML stands for "Yet Another Markup Language". It
      ain't! YAML is really a data serialization language. But if you want
      to think of it as a markup, that's OK with me. A lot of people try
      to use XML as a serialization format.
      
      "YAML" is catchy and fun to say. Try it. "YAML, YAML, YAML!!!"
      ...
      
      # Dump the Perl data structures back into YAML.
      print Dump($string, $arrayref, $hashref);
      
      # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
      use Data::Dumper;
      print Dumper($string, $arrayref, $hashref);
  
  =head1 DESCRIPTION
  
  The YAML.pm module implements a YAML Loader and Dumper based on the YAML
  1.0 specification. L<http://www.yaml.org/spec/>
  
  YAML is a generic data serialization language that is optimized for
  human readability. It can be used to express the data structures of most
  modern programming languages. (Including Perl!!!)
  
  For information on the YAML syntax, please refer to the YAML
  specification.
  
  =head1 WHY YAML IS COOL
  
  =over 4
  
  =item YAML is readable for people.
  
  It makes clear sense out of complex data structures. You should find
  that YAML is an exceptional data dumping tool. Structure is shown
  through indentation, YAML supports recursive data, and hash keys are
  sorted by default. In addition, YAML supports several styles of scalar
  formatting for different types of data.
  
  =item YAML is editable.
  
  YAML was designed from the ground up to be an excellent syntax for
  configuration files. Almost all programs need configuration files, so
  why invent a new syntax for each one? And why subject users to the
  complexities of XML or native Perl code?
  
  =item YAML is multilingual.
  
  Yes, YAML supports Unicode. But I'm actually referring to programming
  languages. YAML was designed to meet the serialization needs of Perl,
  Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be
  interoperable between those languages. That means YAML serializations
  produced by Perl can be processed by Python.
  
  =item YAML is taint safe.
  
  Using modules like Data::Dumper for serialization is fine as long as you
  can be sure that nobody can tamper with your data files or
  transmissions. That's because you need to use Perl's C<eval()> built-in
  to deserialize the data. Somebody could add a snippet of Perl to erase
  your files.
  
  YAML's parser does not need to eval anything.
  
  =item YAML is full featured.
  
  YAML can accurately serialize all of the common Perl data structures and
  deserialize them again without losing data relationships. Although it is
  not 100% perfect (no serializer is or can be perfect), it fares as well
  as the popular current modules: Data::Dumper, Storable, XML::Dumper and
  Data::Denter.
  
  YAML.pm also has the ability to handle code (subroutine) references and
  typeglobs. (Still experimental) These features are not found in Perl's
  other serialization modules.
  
  =item YAML is extensible.
  
  The YAML language has been designed to be flexible enough to solve it's
  own problems. The markup itself has 3 basic construct which resemble
  Perl's hash, array and scalar. By default, these map to their Perl
  equivalents. But each YAML node also supports a tagging mechanism (type
  system) which can cause that node to be interpreted in a completely
  different manner. That's how YAML can support object serialization and
  oddball structures like Perl's typeglob.
  
  =back
  
  =head1 YAML IMPLEMENTATIONS IN PERL
  
  This module, YAML.pm, is really just the interface module for YAML
  modules written in Perl. The basic interface for YAML consists of two
  functions: C<Dump> and C<Load>. The real work is done by the modules
  YAML::Dumper and YAML::Loader.
  
  Different YAML module distributions can be created by subclassing
  YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple
  consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.
  
  Why would there be more than one implementation of YAML? Well, despite
  YAML's offering of being a simple data format, YAML is actually very
  deep and complex. Implementing the entirety of the YAML specification is
  a daunting task.
  
  For this reason I am currently working on 3 different YAML implementations.
  
  =over
  
  =item YAML
  
  The main YAML distribution will keeping evolving to support the entire
  YAML specification in pure Perl. This may not be the fastest or most
  stable module though. Currently, YAML.pm has lots of known bugs. It is
  mostly a great tool for dumping Perl data structures to a readable form.
  
  =item YAML::Tiny
  
  The point of YAML::Tiny is to strip YAML down to the 90% that people
  use most and offer that in a small, fast, stable, pure Perl form.
  YAML::Tiny will simply die when it is asked to do something it can't.
  
  =item YAML::Syck
  
  C<libsyck> is the C based YAML processing library used by the Ruby
  programming language (and also Python, PHP and Pugs). YAML::Syck is the
  Perl binding to C<libsyck>. It should be very fast, but may have
  problems of its own. It will also require C compilation.
  
  NOTE: Audrey Tang has actually completed this module and it works great
        and is 10 times faster than YAML.pm.
  
  =back
  
  In the future, there will likely be even more YAML modules. Remember,
  people other than Ingy are allowed to write YAML modules!
  
  =head1 FUNCTIONAL USAGE
  
  YAML is completely OO under the hood. Still it exports a few useful top
  level functions so that it is dead simple to use. These functions just
  do the OO stuff for you. If you want direct access to the OO API see the
  documentation for YAML::Dumper and YAML::Loader.
  
  =head2 Exported Functions
  
  The following functions are exported by YAML.pm by default. The reason
  they are exported is so that YAML works much like Data::Dumper. If you
  don't want functions to be imported, just use YAML with an empty
  import list:
  
      use YAML ();
  
  =over 4
  
  =item Dump(list-of-Perl-data-structures)
  
  Turn Perl data into YAML. This function works very much like
  Data::Dumper::Dumper(). It takes a list of Perl data strucures and
  dumps them into a serialized form. It returns a string containing the
  YAML stream. The structures can be references or plain scalars.
  
  =item Load(string-containing-a-YAML-stream)
  
  Turn YAML into Perl data. This is the opposite of Dump. Just like
  Storable's thaw() function or the eval() function in relation to
  Data::Dumper. It parses a string containing a valid YAML stream into a
  list of Perl data structures.
  
  =back
  
  =head2 Exportable Functions
  
  These functions are not exported by default but you can request them in
  an import list like this:
  
      use YAML qw'freeze thaw Bless';
  
  =over 4
  
  =item freeze() and thaw()
  
  Aliases to Dump() and Load() for Storable fans. This will also allow
  YAML.pm to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
  
  =item DumpFile(filepath, list)
  
  Writes the YAML stream to a file instead of just returning a string.
  
  =item LoadFile(filepath)
  
  Reads the YAML stream from a file instead of a string.
  
  =item Bless(perl-node, [yaml-node | class-name])
  
  Associate a normal Perl node, with a yaml node. A yaml node is an object
  tied to the YAML::Node class. The second argument is either a yaml node
  that you've already created or a class (package) name that supports a
  yaml_dump() function. A yaml_dump() function should take a perl node and
  return a yaml node. If no second argument is provided, Bless will create
  a yaml node. This node is not returned, but can be retrieved with the
  Blessed() function.
  
  Here's an example of how to use Bless. Say you have a hash containing
  three keys, but you only want to dump two of them. Furthermore the keys
  must be dumped in a certain order. Here's how you do that:
  
      use YAML qw(Dump Bless);
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash)->keys(['banana', 'apple']);
      print Dump $hash;
  
  produces:
  
      ---
      apple: good
      banana: bad
      cauliflower: ugly
      ---
      banana: bad
      apple: good
  
  Bless returns the tied part of a yaml-node, so that you can call the
  YAML::Node methods. This is the same thing that YAML::Node::ynode()
  returns. So another way to do the above example is:
  
      use YAML qw(Dump Bless);
      use YAML::Node;
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash);
      $ynode = ynode(Blessed($hash));
      $ynode->keys(['banana', 'apple']);
      print Dump $hash;
  
  Note that Blessing a Perl data structure does not change it anyway. The
  extra information is stored separately and looked up by the Blessed
  node's memory address.
  
  =item Blessed(perl-node)
  
  Returns the yaml node that a particular perl node is associated with
  (see above). Returns undef if the node is not (YAML) Blessed.
  
  =back
  
  =head1 GLOBAL OPTIONS
  
  YAML options are set using a group of global variables in the YAML
  namespace. This is similar to how Data::Dumper works.
  
  For example, to change the indentation width, do something like:
  
      local $YAML::Indent = 3;
  
  The current options are:
  
  =over 4
  
  =item DumperClass
  
  You can override which module/class YAML uses for Dumping data.
  
  =item LoaderClass
  
  You can override which module/class YAML uses for Loading data.
  
  =item Indent
  
  This is the number of space characters to use for each indentation level
  when doing a Dump(). The default is 2.
  
  By the way, YAML can use any number of characters for indentation at any
  level. So if you are editing YAML by hand feel free to do it anyway that
  looks pleasing to you; just be consistent for a given level.
  
  =item SortKeys
  
  Default is 1. (true)
  
  Tells YAML.pm whether or not to sort hash keys when storing a document.
  
  YAML::Node objects can have their own sort order, which is usually what
  you want. To override the YAML::Node order and sort the keys anyway, set
  SortKeys to 2.
  
  =item Stringify
  
  Default is 0. (false)
  
  Objects with string overloading should honor the overloading and dump the
  stringification of themselves, rather than the actual object's guts.
  
  =item UseHeader
  
  Default is 1. (true)
  
  This tells YAML.pm whether to use a separator string for a Dump
  operation. This only applies to the first document in a stream.
  Subsequent documents must have a YAML header by definition.
  
  =item UseVersion
  
  Default is 0. (false)
  
  Tells YAML.pm whether to include the YAML version on the
  separator/header.
  
      --- %YAML:1.0
  
  =item AnchorPrefix
  
  Default is ''.
  
  Anchor names are normally numeric. YAML.pm simply starts with '1' and
  increases by one for each new anchor. This option allows you to specify a
  string to be prepended to each anchor number.
  
  =item UseCode
  
  Setting the UseCode option is a shortcut to set both the DumpCode and
  LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump
  Perl code references as Perl (using B::Deparse) and to load them back
  into memory using eval(). The reason this has to be an option is that
  using eval() to parse untrusted code is, well, untrustworthy.
  
  =item DumpCode
  
  Determines if and how YAML.pm should serialize Perl code references. By
  default YAML.pm will dump code references as dummy placeholders (much
  like Data::Dumper). If DumpCode is set to '1' or 'deparse', code
  references will be dumped as actual Perl code.
  
  DumpCode can also be set to a subroutine reference so that you can
  write your own serializing routine. YAML.pm passes you the code ref. You
  pass back the serialization (as a string) and a format indicator. The
  format indicator is a simple string like: 'deparse' or 'bytecode'.
  
  =item LoadCode
  
  LoadCode is the opposite of DumpCode. It tells YAML if and how to
  deserialize code references. When set to '1' or 'deparse' it will use
  C<eval()>. Since this is potentially risky, only use this option if you
  know where your YAML has been.
  
  LoadCode can also be set to a subroutine reference so that you can write
  your own deserializing routine. YAML.pm passes the serialization (as a
  string) and a format indicator. You pass back the code reference.
  
  =item UseBlock
  
  YAML.pm uses heuristics to guess which scalar style is best for a given
  node. Sometimes you'll want all multiline scalars to use the 'block'
  style. If so, set this option to 1.
  
  NOTE: YAML's block style is akin to Perl's here-document.
  
  =item UseFold
  
  If you want to force YAML to use the 'folded' style for all multiline
  scalars, then set $UseFold to 1.
  
  NOTE: YAML's folded style is akin to the way HTML folds text,
        except smarter.
  
  =item UseAliases
  
  YAML has an alias mechanism such that any given structure in memory gets
  serialized once. Any other references to that structure are serialized
  only as alias markers. This is how YAML can serialize duplicate and
  recursive structures.
  
  Sometimes, when you KNOW that your data is nonrecursive in nature, you
  may want to serialize such that every node is expressed in full. (ie as
  a copy of the original). Setting $YAML::UseAliases to 0 will allow you
  to do this. This also may result in faster processing because the lookup
  overhead is by bypassed.
  
  THIS OPTION CAN BE DANGEROUS. *If* your data is recursive, this option
  *will* cause Dump() to run in an endless loop, chewing up your computers
  memory. You have been warned.
  
  =item CompressSeries
  
  Default is 1.
  
  Compresses the formatting of arrays of hashes:
  
      -
        foo: bar
      - 
        bar: foo
  
  becomes:
  
      - foo: bar
      - bar: foo
  
  Since this output is usually more desirable, this option is turned on by
  default.
  
  =back
  
  =head1 YAML TERMINOLOGY
  
  YAML is a full featured data serialization language, and thus has its
  own terminology.
  
  It is important to remember that although YAML is heavily influenced by
  Perl and Python, it is a language in its own right, not merely just a
  representation of Perl structures.
  
  YAML has three constructs that are conspicuously similar to Perl's hash,
  array, and scalar. They are called mapping, sequence, and string
  respectively. By default, they do what you would expect. But each
  instance may have an explicit or implicit tag (type) that makes it
  behave differently. In this manner, YAML can be extended to represent
  Perl's Glob or Python's tuple, or Ruby's Bigint.
  
  =over 4
  
  =item stream
  
  A YAML stream is the full sequence of unicode characters that a YAML
  parser would read or a YAML emitter would write. A stream may contain
  one or more YAML documents separated by YAML headers.
  
      ---
      a: mapping
      foo: bar
      ---
      - a
      - sequence
  
  =item document
  
  A YAML document is an independent data structure representation within a
  stream. It is a top level node. Each document in a YAML stream must
  begin with a YAML header line. Actually the header is optional on the
  first document.
  
      ---
      This: top level mapping
      is:
          - a
          - YAML
          - document
  
  =item header
  
  A YAML header is a line that begins a YAML document. It consists of
  three dashes, possibly followed by more info. Another purpose of the
  header line is that it serves as a place to put top level tag and anchor
  information.
  
      --- !recursive-sequence &001
      - * 001
      - * 001
  
  =item node
  
  A YAML node is the representation of a particular data stucture. Nodes
  may contain other nodes. (In Perl terms, nodes are like scalars.
  Strings, arrayrefs and hashrefs. But this refers to the serialized
  format, not the in-memory structure.)
  
  =item tag
  
  This is similar to a type. It indicates how a particular YAML node
  serialization should be transferred into or out of memory. For instance
  a Foo::Bar object would use the tag 'perl/Foo::Bar':
  
      - !perl/Foo::Bar
          foo: 42
          bar: stool
  
  =item collection
  
  A collection is the generic term for a YAML data grouping. YAML has two
  types of collections: mappings and sequences. (Similar to hashes and arrays)
  
  =item mapping
  
  A mapping is a YAML collection defined by unordered key/value pairs with
  unique keys. By default YAML mappings are loaded into Perl hashes.
  
      a mapping:
          foo: bar
          two: times two is 4
  
  =item sequence
  
  A sequence is a YAML collection defined by an ordered list of elements. By
  default YAML sequences are loaded into Perl arrays.
  
      a sequence:
          - one bourbon
          - one scotch
          - one beer
  
  =item scalar
  
  A scalar is a YAML node that is a single value. By default YAML scalars
  are loaded into Perl scalars.
  
      a scalar key: a scalar value
  
  YAML has many styles for representing scalars. This is important because
  varying data will have varying formatting requirements to retain the
  optimum human readability.
  
  =item plain scalar
  
  A plain scalar is unquoted. All plain scalars are automatic candidates
  for "implicit tagging". This means that their tag may be determined
  automatically by examination. The typical uses for this are plain alpha
  strings, integers, real numbers, dates, times and currency.
  
      - a plain string
      - -42
      - 3.1415
      - 12:34
      - 123 this is an error
  
  =item single quoted scalar
  
  This is similar to Perl's use of single quotes. It means no escaping
  except for single quotes which are escaped by using two adjacent
  single quotes.
  
      - 'When I say ''\n'' I mean "backslash en"'
  
  =item double quoted scalar
  
  This is similar to Perl's use of double quotes. Character escaping can
  be used.
  
      - "This scalar\nhas two lines, and a bell -->\a"
  
  =item folded scalar
  
  This is a multiline scalar which begins on the next line. It is
  indicated by a single right angle bracket. It is unescaped like the
  single quoted scalar. Line folding is also performed.
  
      - > 
       This is a multiline scalar which begins on
       the next line. It is indicated by a single
       carat. It is unescaped like the single
       quoted scalar. Line folding is also
       performed.
  
  =item block scalar
  
  This final multiline form is akin to Perl's here-document except that
  (as in all YAML data) scope is indicated by indentation. Therefore, no
  ending marker is required. The data is verbatim. No line folding.
  
      - |
          QTY  DESC          PRICE  TOTAL
          ---  ----          -----  -----
            1  Foo Fighters  $19.95 $19.95
            2  Bar Belles    $29.95 $59.90
  
  =item parser
  
  A YAML processor has four stages: parse, load, dump, emit.
  
  A parser parses a YAML stream. YAML.pm's Load() function contains a
  parser.
  
  =item loader
  
  The other half of the Load() function is a loader. This takes the
  information from the parser and loads it into a Perl data structure.
  
  =item dumper
  
  The Dump() function consists of a dumper and an emitter. The dumper
  walks through each Perl data structure and gives info to the emitter.
  
  =item emitter
  
  The emitter takes info from the dumper and turns it into a YAML stream.
  
  NOTE:
  In YAML.pm the parser/loader and the dumper/emitter code are currently
  very closely tied together. In the future they may be broken into
  separate stages.
  
  =back
  
  For more information please refer to the immensely helpful YAML
  specification available at L<http://www.yaml.org/spec/>.
  
  =head1 ysh - The YAML Shell
  
  The YAML distribution ships with a script called 'ysh', the YAML shell.
  ysh provides a simple, interactive way to play with YAML. If you type in
  Perl code, it displays the result in YAML. If you type in YAML it turns
  it into Perl code.
  
  To run ysh, (assuming you installed it along with YAML.pm) simply type:
  
      ysh [options]
  
  Please read the C<ysh> documentation for the full details. There are
  lots of options.
  
  =head1 BUGS & DEFICIENCIES
  
  If you find a bug in YAML, please try to recreate it in the YAML Shell
  with logging turned on ('ysh -L'). When you have successfully reproduced
  the bug, please mail the LOG file to the author (ingy@cpan.org).
  
  WARNING: This is still *ALPHA* code. Well, most of this code has been
  around for years...
  
  BIGGER WARNING: YAML.pm has been slow in the making, but I am committed
  to having top notch YAML tools in the Perl world. The YAML team is close
  to finalizing the YAML 1.1 spec. This version of YAML.pm is based off of
  a very old pre 1.0 spec. In actuality there isn't a ton of difference,
  and this YAML.pm is still fairly useful. Things will get much better in
  the future.
  
  =head1 RESOURCES
  
  L<http://lists.sourceforge.net/lists/listinfo/yaml-core> is the mailing
  list. This is where the language is discussed and designed.
  
  L<http://www.yaml.org> is the official YAML website.
  
  L<http://www.yaml.org/spec/> is the YAML 1.0 specification.
  
  L<http://yaml.kwiki.org> is the official YAML wiki.
  
  =head1 SEE ALSO
  
  See YAML::XS. Fast!
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  is resonsible for YAML.pm.
  
  The YAML serialization language is the result of years of collaboration
  between Oren Ben-Kiki, Clark Evans and Ingy dt Net. Several others
  have added help along the way.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005, 2006, 2008, 2011-2012. Ingy dt Net.
  
  Copyright (c) 2001, 2002, 2005. Brian Ingerson.
  
  Some parts copyright (c) 2009 - 2010 Adam Kennedy
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  package YAML::Any;
  
  our $VERSION = '0.84';
  
  use strict;
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::Croak(@_);
  }
  
  1;
  
  =head1 NAME
  
  YAML::Any - Pick a YAML implementation and use it.
  
  =head1 SYNOPSIS
  
      use YAML::Any;
      $YAML::Indent = 3;
      my $yaml = Dump(@objects);
  
  =head1 DESCRIPTION
  
  There are several YAML implementations that support the Dump/Load API.
  This module selects the best one available and uses it.
  
  =head1 ORDER
  
  Currently, YAML::Any will choose the first one of these YAML
  implementations that is installed on your system:
  
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  
  =head1 OPTIONS
  
  If you specify an option like:
  
      $YAML::Indent = 4;
  
  And YAML::Any is using YAML::XS, it will use the proper variable:
  $YAML::XS::Indent.
  
  =head1 SUBROUTINES
  
  Like all the YAML modules that YAML::Any uses, the following subroutines
  are exported by default:
  
      Dump
      Load
  
  and the following subroutines are exportable by request:
  
      DumpFile
      LoadFile
  
  =head1 METHODS
  
  YAML::Any provides the following class methods.
  
  =over
  
  =item YAML::Any->order;
  
  This method returns a list of the current possible implementations that
  YAML::Any will search for.
  
  =item YAML::Any->implementation;
  
  This method returns the implementation the YAML::Any will use. This
  result is obtained by finding the first member of YAML::Any->order that
  is either already loaded in C<%INC> or that can be loaded using
  C<require>. If no implementation is found, an error will be thrown.
  
  =back
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008. Ingy dt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  our $VERSION = '0.84';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';    
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo); 
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and 
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {  
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0], 
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) = 
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} = 
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) = 
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash. 
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
          
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last 
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper - YAML class for dumping Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Dumper;
      my $dumper = YAML::Dumper->new;
      $dumper->indent_width(4);
      print $dumper->dump({foo => 'bar'});
  
  =head1 DESCRIPTION
  
  YAML::Dumper is the module that YAML.pm used to serialize Perl objects to
  YAML. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
      
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper::Base - Base class for YAML Dumper classes
  
  =head1 SYNOPSIS
  
      package YAML::Dumper::Something;
      use YAML::Dumper::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Dumper::Base is a base class for creating YAML dumper classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)} 
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION 
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR 
       YAML_PARSE_ERR_NO_ANCHOR 
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  
  our @ISA = 'YAML::Error';
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Error - Error formatting class for YAML modules
  
  =head1 SYNOPSIS
  
      $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias);
      $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
  
  =head1 DESCRIPTION
  
  This module provides a C<die> and a C<warn> facility.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  our $VERSION = '0.84';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';    
  my $LIT_CHAR_RX = "\\$LIT_CHAR";    
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS') 
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE') 
        if length($self->stream) and 
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) = 
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) = 
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) { 
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE'); 
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--; 
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR') 
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface); 
  }
  
  # Morph a node to it's explicit type  
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
          
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign) 
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
              
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) = 
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE') 
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^"((?:\\"|[^"])*)"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:''|[^'])*)'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`\^]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately  
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/ or die;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and 
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or die;
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
          
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos; 
      
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and 
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION') 
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
     
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader - YAML class for loading Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Loader;
      my $loader = YAML::Loader->new;
      my $hash = $loader->load(<<'...');
      foo: bar
      ...
  
  =head1 DESCRIPTION
  
  YAML::Loader is the module that YAML.pm used to deserialize YAML to Perl
  objects. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader::Base - Base class for YAML Loader classes
  
  =head1 SYNOPSIS
  
      package YAML::Loader::Something;
      use YAML::Loader::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Loader::Base is a base class for creating YAML loader classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict;
  use warnings;
  package YAML::Marshall;
  
  our $VERSION = '0.84';
  
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Marshall - YAML marshalling class you can mixin to your classes
  
  =head1 SYNOPSIS
  
      package Bar;
      use Foo -base;
      use YAML::Marshall -mixin;
  
  =head1 DESCRIPTION
  
  For classes that want to handle their own YAML serialization.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo; $VERSION = '0.84';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict;
  use warnings;
  package YAML::Node;
  
  our $VERSION = '0.84';
  
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
  	$self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
  	$self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
  	$self = tied(*{$_[0]});
      }
      else {
  	$self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
  		    ($type eq 'HASH') ? 'mapping' :
  		    $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
  	yaml_scalar->new($self, $_[1]);
  	return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};    
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{TAG} = YAML::Tag->new($value);
  	return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{KEYS} = $value;
  	return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}}; 
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
  	return (grep {$_ eq $key} @{$self->{KEYS}}) 
  	       ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
  	$self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
  	$self->{HASH}{$key} = $value;
      }
      else {
  	if (not grep {$_ eq $key} @{$self->{KEYS}}) {
  	    push(@{$self->{KEYS}}, $key);
  	}
  	$self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
  	$return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
  	$return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
  	if ($self->{KEYS}[$i] eq $key) {
  	    splice(@{$self->{KEYS}}, $i, 1);
  	}
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Node - A generic data node that encapsulates YAML information
  
  =head1 SYNOPSIS
  
      use YAML;
      use YAML::Node;
      
      my $ynode = YAML::Node->new({}, 'ingerson.com/fruit');
      %$ynode = qw(orange orange apple red grape green);
      print Dump $ynode;
  
  yields:
  
      --- !ingerson.com/fruit
      orange: orange
      apple: red
      grape: green
  
  =head1 DESCRIPTION
  
  A generic node in YAML is similar to a plain hash, array, or scalar node
  in Perl except that it must also keep track of its type. The type is a
  URI called the YAML type tag.
  
  YAML::Node is a class for generating and manipulating these containers.
  A YAML node (or ynode) is a tied hash, array or scalar. In most ways it
  behaves just like the plain thing. But you can assign and retrieve and
  YAML type tag URI to it. For the hash flavor, you can also assign the
  order that the keys will be retrieved in. By default a ynode will offer
  its keys in the same order that they were assigned.
  
  YAML::Node has a class method call new() that will return a ynode. You
  pass it a regular node and an optional type tag. After that you can
  use it like a normal Perl node, but when you YAML::Dump it, the magical
  properties will be honored.
  
  This is how you can control the sort order of hash keys during a YAML
  serialization. By default, YAML sorts keys alphabetically. But notice
  in the above example that the keys were Dumped in the same order they
  were assigned.
  
  YAML::Node exports a function called ynode(). This function returns the tied object so that you can call special methods on it like ->keys().
  
  keys() works like this:
  
      use YAML;
      use YAML::Node;
      
      %$node = qw(orange orange apple red grape green);
      $ynode = YAML::Node->new($node);
      ynode($ynode)->keys(['grape', 'apple']);
      print Dump $ynode;
  
  produces:
  
      ---
      grape: green
      apple: red
  
  It tells the ynode which keys and what order to use.
  
  ynodes will play a very important role in how programs use YAML. They
  are the foundation of how a Perl class can marshall the Loading and
  Dumping of its objects.
  
  The upcoming versions of YAML.pm will have much more information on this.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  Copyright (c) 2002. Brian Ingerson. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict;
  use warnings;
  package YAML::Tag;
  
  our $VERSION = '0.84';
  
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Tag - Tag URI object class for YAML
  
  =head1 SYNOPSIS
  
      use YAML::Tag;
  
  =head1 DESCRIPTION
  
  Used by YAML::Node.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  
  sub yaml_dump {
      my $self = shift;
      my $ynode = YAML::Node->new({}, '!perl/glob:');
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value; 
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  
  my $dummy_warned = 0; 
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }    
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Types - Marshall Perl internal data types to/from YAML
  
  =head1 SYNOPSIS
  
      $::foo = 42;
      print YAML::Dump(*::foo);
  
      print YAML::Dump(qr{match me});
  
  =head1 DESCRIPTION
  
  This module has the helper classes for transferring objects,
  subroutines, references, globs, regexps and file handles to and
  from YAML.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TYPES

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use strictures 1;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
OO

$fatpacked{"strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES';
  package strictures;
  
  use strict;
  use warnings FATAL => 'all';
  
  BEGIN {
    *_PERL_LT_5_8_4 = ($] < 5.008004) ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '1.005001'; # 1.5.1
  
  sub VERSION {
    for ($_[1]) {
      last unless defined && !ref && int != 1;
      die "Major version specified as $_ - this is strictures version 1";
    }
    # disable this since Foo->VERSION(undef) correctly returns the version
    # and that can happen either if our caller passes undef explicitly or
    # because the for above autovivified $_[1] - I could make it stop but
    # it's pointless since we don't want to blow up if the caller does
    # something valid either.
    no warnings 'uninitialized';
    shift->SUPER::VERSION(@_);
  }
  
  our $extra_load_states;
  
  our $Smells_Like_VCS = (-e '.git' || -e '.svn' || -e '.hg'
    || (-e '../../dist.ini'
        && (-e '../../.git' || -e '../../.svn' || -e '../../.hg' )));
  
  sub import {
    strict->import;
    warnings->import(FATAL => 'all');
  
    my $extra_tests = do {
      if (exists $ENV{PERL_STRICTURES_EXTRA}) {
        if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}) {
          die 'PERL_STRICTURES_EXTRA checks are not available on perls older than 5.8.4: '
            . "please unset \$ENV{PERL_STRICTURES_EXTRA}\n";
        }
        $ENV{PERL_STRICTURES_EXTRA};
      } elsif (! _PERL_LT_5_8_4) {
        !!((caller)[1] =~ /^(?:t|xt|lib|blib)/
           and $Smells_Like_VCS)
      }
    };
    if ($extra_tests) {
      $extra_load_states ||= do {
  
        my (%rv, @failed);
        foreach my $mod (qw(indirect multidimensional bareword::filehandles)) {
          eval "require $mod; \$rv{'$mod'} = 1;" or do {
            push @failed, $mod;
  
            # courtesy of the 5.8 require bug
            # (we do a copy because 5.16.2 at least uses the same read-only
            # scalars for the qw() list and it doesn't seem worth a $^V check)
  
            (my $file = $mod) =~ s|::|/|g;
            delete $INC{"${file}.pm"};
          };
        }
  
        if (@failed) {
          my $failed = join ' ', @failed;
          print STDERR <<EOE;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  EOE
        }
  
        \%rv;
      };
  
      indirect->unimport(':fatal') if $extra_load_states->{indirect};
      multidimensional->unimport if $extra_load_states->{multidimensional};
      bareword::filehandles->unimport if $extra_load_states->{'bareword::filehandles'};
    }
  }
  
  1;
  
  __END__
  =head1 NAME
  
  strictures - turn on strict and make all warnings fatal
  
  =head1 SYNOPSIS
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
  
  except when called from a file which matches:
  
    (caller)[1] =~ /^(?:t|xt|lib|blib)/
  
  and when either C<.git>, C<.svn>, or C<.hg> is present in the current directory (with
  the intention of only forcing extra tests on the author side) -- or when C<.git>,
  C<.svn>, or C<.hg> is present two directories up along with C<dist.ini> (which would
  indicate we are in a C<dzil test> operation, via L<Dist::Zilla>) --
  or when the C<PERL_STRICTURES_EXTRA> environment variable is set, in which case
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  Note that C<PERL_STRICTURES_EXTRA> may at some point add even more tests, with only a minor
  version increase, but any changes to the effect of C<use strictures> in
  normal mode will involve a major version bump.
  
  If any of the extra testing modules are not present, L<strictures> will
  complain loudly, once, via C<warn()>, and then shut up. But you really
  should consider installing them, they're all great anti-footgun tools.
  
  =head1 DESCRIPTION
  
  I've been writing the equivalent of this module at the top of my code for
  about a year now. I figured it was time to make it shorter.
  
  Things like the importer in C<use Moose> don't help me because they turn
  warnings on but don't make them fatal -- which from my point of view is
  useless because I want an exception to tell me my code isn't warnings-clean.
  
  Any time I see a warning from my code, that indicates a mistake.
  
  Any time my code encounters a mistake, I want a crash -- not spew to STDERR
  and then unknown (and probably undesired) subsequent behaviour.
  
  I also want to ensure that obvious coding mistakes, like indirect object
  syntax (and not so obvious mistakes that cause things to accidentally compile
  as such) get caught, but not at the cost of an XS dependency and not at the
  cost of blowing things up on another machine.
  
  Therefore, L<strictures> turns on additional checking, but only when it thinks
  it's running in a test file in a VCS checkout -- although if this causes
  undesired behaviour this can be overridden by setting the
  C<PERL_STRICTURES_EXTRA> environment variable.
  
  If additional useful author side checks come to mind, I'll add them to the
  C<PERL_STRICTURES_EXTRA> code path only -- this will result in a minor version increase (e.g.
  1.000000 to 1.001000 (1.1.0) or similar). Any fixes only to the mechanism of
  this code will result in a sub-version increase (e.g. 1.000000 to 1.000001
  (1.0.1)).
  
  If the behaviour of C<use strictures> in normal mode changes in any way, that
  will constitute a major version increase -- and the code already checks
  when its version is tested to ensure that
  
    use strictures 1;
  
  will continue to only introduce the current set of strictures even if 2.0 is
  installed.
  
  =head1 METHODS
  
  =head2 import
  
  This method does the setup work described above in L</DESCRIPTION>
  
  =head2 VERSION
  
  This method traps the C<< strictures->VERSION(1) >> call produced by a use line
  with a version number on it and does the version check.
  
  =head1 EXTRA TESTING RATIONALE
  
  Every so often, somebody complains that they're deploying via C<git pull>
  and that they don't want L<strictures> to enable itself in this case -- and that
  setting C<PERL_STRICTURES_EXTRA> to 0 isn't acceptable (additional ways to
  disable extra testing would be welcome but the discussion never seems to get
  that far).
  
  In order to allow us to skip a couple of stages and get straight to a
  productive conversation, here's my current rationale for turning the
  extra testing on via a heuristic:
  
  The extra testing is all stuff that only ever blows up at compile time;
  this is intentional. So the oft-raised concern that it's different code being
  tested is only sort of the case -- none of the modules involved affect the
  final optree to my knowledge, so the author gets some additional compile
  time crashes which he/she then fixes, and the rest of the testing is
  completely valid for all environments.
  
  The point of the extra testing -- especially C<no indirect> -- is to catch
  mistakes that newbie users won't even realise are mistakes without
  help. For example,
  
    foo { ... };
  
  where foo is an & prototyped sub that you forgot to import -- this is
  pernicious to track down since all I<seems> fine until it gets called
  and you get a crash. Worse still, you can fail to have imported it due
  to a circular require, at which point you have a load order dependent
  bug which I've seen before now I<only> show up in production due to tiny
  differences between the production and the development environment. I wrote
  L<http://shadow.cat/blog/matt-s-trout/indirect-but-still-fatal/> to explain
  this particular problem before L<strictures> itself existed.
  
  As such, in my experience so far L<strictures>' extra testing has
  I<avoided> production versus development differences, not caused them.
  
  Additionally, L<strictures>' policy is very much "try and provide as much
  protection as possible for newbies -- who won't think about whether there's
  an option to turn on or not" -- so having only the environment variable
  is not sufficient to achieve that (I get to explain that you need to add
  C<use strict> at least once a week on freenode #perl -- newbies sometimes
  completely skip steps because they don't understand that that step
  is important).
  
  I make no claims that the heuristic is perfect -- it's already been evolved
  significantly over time, especially for 1.004 where we changed things to
  ensure it only fires on files in your checkout (rather than L<strictures>-using
  modules you happened to have installed, which was just silly). However, I
  hope the above clarifies why a heuristic approach is not only necessary but
  desirable from a point of view of providing new users with as much safety as possible,
  and will allow any future discussion on the subject to focus on "how do we
  minimise annoyance to people deploying from checkouts intentionally".
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<indirect>
  
  =item *
  
  L<multidimensional>
  
  =item *
  
  L<bareword::filehandles>
  
  =back
  
  =head1 COMMUNITY AND SUPPORT
  
  =head2 IRC channel
  
  irc.perl.org #toolchain
  
  (or bug 'mst' in query on there or freenode)
  
  =head2 Git repository
  
  Gitweb is on http://git.shadowcat.co.uk/ and the clone URL is:
  
    git clone git://git.shadowcat.co.uk/p5sagit/strictures.git
  
  The web interface to the repository is at:
  
    http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=p5sagit/strictures.git
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@gmail.com>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the strictures L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
STRICTURES

$fatpacked{"x86_64-linux/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CWD';
  package Cwd;
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
  
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.40';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  eval {
    if ( $] >= 5.006 ) {
      require XSLoader;
      XSLoader::load( __PACKAGE__, $xs_version);
    } else {
      require DynaLoader;
      push @ISA, 'DynaLoader';
      __PACKAGE__->bootstrap( $xs_version );
    }
  };
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  foreach my $try ('/bin/pwd',
  		 '/usr/bin/pwd',
  		 '/QOpenSys/bin/pwd', # OS/400 PASE.
  		) {
  
      if( -x $try ) {
          $pwd_cmd = $try;
          last;
      }
  }
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if somenone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
      # Localize %ENV entries in a way that won't create new hash keys
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV);
      local @ENV{@localize};
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      $newdir =~ s|///*|/|g unless $^O eq 'MSWin32';
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      $ENV{'PWD'} = `cmd /c cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd_simple {
      $ENV{'PWD'} = `cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd {
      # Need to avoid taking any sort of reference to the typeglob or the code in
      # the optree, so that this tests the runtime state of things, as the
      # ExtUtils::MakeMaker tests for "miniperl" need to be able to fake things at
      # runtime by deleting the subroutine. *foo{THING} syntax on a symbol table
      # lookup avoids needing a string eval, which has been reported to cause
      # problems (for reasons that we haven't been able to get to the bottom of -
      # rt.cpan.org #56225)
      if (*{$DynaLoader::{boot_DynaLoader}}{CODE}) {
  	$ENV{'PWD'} = Win32::GetCwd();
      }
      else { # miniperl
  	chomp($ENV{'PWD'} = `cd`);
      }
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      if (!defined &Dos::GetCwd) {
          $ENV{'PWD'} = `command /c cd`;
          chomp $ENV{'PWD'};
          $ENV{'PWD'} =~ s:\\:/:g ;
      } else {
          $ENV{'PWD'} = Dos::GetCwd();
      }
      return $ENV{'PWD'};
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      $ENV{'PWD'} = `/usr/bin/fullpath -t`;
      chomp $ENV{'PWD'};
      return $ENV{'PWD'};
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      $ENV{'PWD'} = EPOC::getcwd();
      return $ENV{'PWD'};
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
X86_64-LINUX_CWD

$fatpacked{"x86_64-linux/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_FILE_SPEC

$fatpacked{"x86_64-linux/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp' );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
X86_64-LINUX_FILE_SPEC_CYGWIN

$fatpacked{"x86_64-linux/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still work in progress ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX_FILE_SPEC_EPOC

$fatpacked{"x86_64-linux/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      *{$meth} = sub {&$sub('File::Spec', @_)};
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
X86_64-LINUX_FILE_SPEC_FUNCTIONS

$fatpacked{"x86_64-linux/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR} );
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX_FILE_SPEC_MAC

$fatpacked{"x86_64-linux/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $tmpdir = $_[0]->_tmpdir( @d, '/tmp', '/'  );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_FILE_SPEC_OS2

$fatpacked{"x86_64-linux/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub _tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      my @dirlist = @_;
      {
  	no strict 'refs';
  	if (${"\cTAINT"}) { # Check for taint mode on perl >= 5.8.0
              require Scalar::Util;
  	    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
  	}
  	elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	    @dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;
  	}
      }
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      return $tmpdir;
  }
  
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" );
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
      my ($path_volume) = $self->splitpath($path, 1);
      my ($base_volume) = $self->splitpath($base, 1);
  
      # Can't relativize across volumes
      return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
      # For UNC paths, the user might give a volume like //foo/bar that
      # strictly speaking has no directory portion.  Treat it as if it
      # had the root directory for that volume.
      if (!length($base_directories) and $self->file_name_is_absolute($base)) {
        $base_directories = $self->rootdir;
      }
      }
      else {
  	my $wd= ($self->splitpath($self->_cwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
X86_64-LINUX_FILE_SPEC_UNIX

$fatpacked{"x86_64-linux/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicity requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
              }
  
  	$sdir = $self->eliminate_macros($sdir) unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
  	    $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
  
  	    # Special case for VMS absolute directory specs: these will have
  	    # had device prepended during trip through Unix syntax in
  	    # eliminate_macros(), since Unix syntax has no way to express
  	    # "absolute from the top of this device's directory tree".
  	    if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
                  } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
              } else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
  		$rslt = $self->eliminate_macros($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $file : vmsify($file);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      my $self = shift @_;
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
          return $tmpdir;
      }
  
      $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /:[^<\[]/);
  }
  
  =item splitpath (override)
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
          my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
          $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
            $dir = vmspath($dir);
        }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      return vmspath(File::Spec::Unix::abs2rel( $self, @_ ))
          if grep m{/}, @_;
  
      my($path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      for ($path, $base) { $_ = $self->canonpath($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
          if ($path =~ m/\//) {
  	    $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
  		       ? vmspath($path)             # whether it's a directory
  		       : vmsify($path) );
          }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
              $sep = '.'
                  if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                       $path_directories =~ m{^[^.\[<]}s
                  ) ;
              $base_directories = "$base_directories$sep$path_directories";
              $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  # eliminate_macros() and fixpath() are MakeMaker-specific methods
  # which are used inside catfile() and catdir().  MakeMaker has its own
  # copies as of 6.06_03 which are the canonical ones.  We leave these
  # here, in peace, so that File::Spec continues to work with MakeMakers
  # prior to 6.06_03.
  # 
  # Please consider these two methods deprecated.  Do not patch them,
  # patch the ones in ExtUtils::MM_VMS instead.
  #
  # Update:  MakeMaker 6.48 is still using these routines on VMS.
  # so they need to be kept up to date with ExtUtils::MM_VMS.
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless (defined $path) && ($path ne '');
      $self = {} unless ref $self;
  
      if ($path =~ /\s/) {
        return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
      }
  
      my $npath = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  # Deprecated.  See the note above for eliminate_macros().
  
  # Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  # in any directory specification, in order to avoid juxtaposing two
  # VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  # are all macro, so that we can tell how long the expansion is, and avoid
  # overrunning DCL's command buffer when MM[KS] is running.
  
  # fixpath() checks to see whether the result matches the name of a
  # directory in the current default directory and returns a directory or
  # file specification accordingly.  C<$is_dir> can be set to true to
  # force fixpath() to consider the path to be a directory or false to force
  # it to be a file.
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ /\s/) {
        return join ' ',
               map { $self->fixpath($_,$force_path) }
  	     split /\s+/, $path;
      }
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
      $fixedpath;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
X86_64-LINUX_FILE_SPEC_VMS

$fatpacked{"x86_64-linux/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
X86_64-LINUX_FILE_SPEC_WIN32

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # List::Util.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle
    pairmap pairgrep pairfirst pairs pairkeys pairvalues
  );
  our $VERSION    = "1.35";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce BLOCK LIST
  
  Reduces LIST by calling BLOCK, in a scalar context, multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a>
  and C<$b> set to the first two elements of the list, subsequent
  calls will be done by setting C<$a> to the result of the previous
  call and C<$b> to the next element in the list.
  
  Returns the result of the last call to BLOCK. If LIST is empty then
  C<undef> is returned. If LIST only contains one element then that
  element is returned and BLOCK is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to
  implement the other list-reduction functions in this module. (They are
  not in fact implemented like this, but instead in a more efficient
  manner in individual C functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then
  make sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this
  generic idea.
  
  =head2 any BLOCK LIST
  
  Similar to C<grep> in that it evaluates BLOCK setting C<$_> to each element
  of LIST in turn. C<any> returns true if any element makes the BLOCK return a
  true value. If BLOCK never returns true or LIST was empty then it returns
  false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all BLOCK LIST
  
  Similar to C<any>, except that it requires all elements of the LIST to make
  the BLOCK return true. If any element returns false, then it returns true. If
  the BLOCK never returns false or the LIST was empty then it returns true.
  
  =head2 none BLOCK LIST
  
  =head2 notall BLOCK LIST
  
  Similar to C<any> and C<all>, but with the return sense inverted. C<none>
  returns true if no value in the LIST causes the BLOCK to return true, and
  C<notall> returns true if not all of the values do.
  
  =head2 first BLOCK LIST
  
  Similar to C<grep> in that it evaluates BLOCK setting C<$_> to each element
  of LIST in turn. C<first> returns the first element where the result from
  BLOCK is a true value. If BLOCK never returns true or LIST was empty then
  C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max LIST
  
  Returns the entry in the list with the highest numerical value. If the
  list is empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr LIST
  
  Similar to C<max>, but treats all the entries in the list as strings
  and returns the highest string as defined by the C<gt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min LIST
  
  Similar to C<max> but returns the entry in the list with the lowest
  numerical value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr LIST
  
  Similar to C<min>, but treats all the entries in the list as strings
  and returns the lowest string as defined by the C<lt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product LIST
  
  Returns the product of all the elements in LIST. If LIST is empty then C<1> is
  returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum LIST
  
  Returns the sum of all the elements in LIST. If LIST is empty then
  C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0 LIST
  
  Similar to C<sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume
  an even-sized list of pairs. The pairs may be key/value associations from a
  hash, or just a list of values. The functions will all preserve the original
  ordering of the pairs, and will not be confused by multiple pairs having the
  same "key" value - nor even do they require that the first of each pair be a
  plain string.
  
  =cut
  
  =head2 pairgrep BLOCK KVLIST
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the BLOCK multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  KVLIST.
  
  Returns an even-sized list of those pairs for which the BLOCK returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size
  of the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  Similar to C<grep>, C<pairgrep> aliases C<$a> and C<$b> to elements of the
  given list. Any modifications of it by the code block will be visible to
  the caller.
  
  =head2 pairfirst BLOCK KVLIST
  
  Similar to the C<first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the BLOCK multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  KVLIST.
  
  Returns the first pair of values from the list for which the BLOCK returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  Similar to C<grep>, C<pairfirst> aliases C<$a> and C<$b> to elements of the
  given list. Any modifications of it by the code block will be visible to
  the caller.
  
  =head2 pairmap BLOCK KVLIST
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the BLOCK multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  KVLIST.
  
  Returns the concatenation of all the values returned by the BLOCK in list
  context, or the count of the number of items that would have been returned
  in scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  Similar to C<map>, C<pairmap> aliases C<$a> and C<$b> to elements of the
  given list. Any modifications of it by the code block will be visible to
  the caller.
  
  =head2 pairs KVLIST
  
  A convenient shortcut to operating on even-sized lists of pairs, this
  function returns a list of ARRAY references, each containing two items from
  the given list. It is a more efficient version of
  
      pairmap { [ $a, $b ] } KVLIST
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach ( pairs @KVLIST ) {
         my ( $key, $value ) = @$_;
         ...
      }
  
  =head2 pairkeys KVLIST
  
  A convenient shortcut to operating on even-sized lists of pairs, this
  function returns a list of the the first values of each of the pairs in
  the given list. It is a more efficient version of
  
      pairmap { $a } KVLIST
  
  =head2 pairvalues KVLIST
  
  A convenient shortcut to operating on even-sized lists of pairs, this
  function returns a list of the the second values of each of the pairs in
  the given list. It is a more efficient version of
  
      pairmap { $b } KVLIST
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle LIST
  
  Returns the elements of LIST in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce
  will return an incorrect result. This will show up as test 7 of
  reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.35";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Scalar::Util.pm
  #
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed
    dualvar
    isdual
    isvstring
    isweak
    looks_like_number
    openhandle
    readonly
    refaddr
    reftype
    set_prototype
    tainted
    weaken
  );
  our $VERSION    = "1.35";
  $VERSION   = eval $VERSION;
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines. The
  subroutines defined are
  
  =head2 blessed EXPR
  
  If EXPR evaluates to a blessed reference the name of the package
  that it is blessed into is returned. Otherwise C<undef> is returned.
  
     $scalar = "foo";
     $class  = blessed $scalar;           # undef
  
     $ref    = [];
     $class  = blessed $ref;              # undef
  
     $obj    = bless [], "Foo";
     $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet
  false.
  
  =head2 dualvar NUM, STRING
  
  Returns a scalar that has the value NUM in a numeric context and the
  value STRING in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual EXPR
  
  If EXPR is a scalar that is a dualvar, the result is true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content
  through numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is
  actually implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring EXPR
  
  If EXPR is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number EXPR
  
  Returns true if perl thinks EXPR is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle FH
  
  Returns FH if FH may be used as a filehandle and is open, or FH is a tied
  handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly SCALAR
  
  Returns true if SCALAR is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 refaddr EXPR
  
  If EXPR evaluates to a reference the internal memory address of
  the referenced value is returned. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype EXPR
  
  If EXPR evaluates to a reference the type of the variable referenced
  is returned. Otherwise C<undef> is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 set_prototype CODEREF, PROTOTYPE
  
  Sets the prototype of the given function, or deletes it if PROTOTYPE is
  undef. Returns the CODEREF.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted EXPR
  
  Return true if the result of EXPR is tainted
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head2 weaken REF
  
  REF will be turned into a weak reference. This means that it will not
  hold a reference count on the object it references. Also when the reference
  count on that object reaches zero, REF will be set to undef.
  
  This is useful for keeping copies of references , but you don't want to
  prevent the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference,
  the copy will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never
  be destroyed because there is now always a strong reference to them in the
  @object array.
  
  =head2 isweak EXPR
  
  If EXPR is a scalar which is a weak reference the result is true.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to use
  C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its functions
  so that those without access to a C compiler may still use it. However some of the functions
  are only available when a C compiler was available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.05';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
X86_64-LINUX_SUB_NAME

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE



use strict;
use warnings;
$|++;

use App::Task::Base;
use App::Task::Command::Start;
use App::Task::Command::Ready;
use App::Task::Command::Deploy;
use App::Task::Command::Status;
use App::Task::Command::Cleanup;

my $task = App::Task::Base->new;
$task->run;
